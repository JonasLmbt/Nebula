<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nebula</title>

  <style>
  :root{
    --bg: rgba(20,20,28,0.78);
    --panel: rgba(255,255,255,0.06);
    --text: #e9e9f1;
    --muted: #9aa0aa;
  --accent: #66eaff; /* updated according to latest style snippet */
    --accent-soft: rgba(102,234,255,0.25);
    --good: #43d17f;
    --warn: #e0c14d;
    --bad: #e05a5a;
    --row: rgba(255,255,255,0.03);
    --row-hover: rgba(255,255,255,0.06);
    --menu: #1f2230;
    --shadow: 0 12px 30px rgba(0,0,0,0.35);
    --grip: 8px;
  }

  /* Reset / Base */
  html,body{margin:0;height:100%}
  body{
    background:var(--bg);
    color:var(--text);
    font:14px/1.4 system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Arial, sans-serif;
    -webkit-font-smoothing:antialiased;
    user-select:none;
  }
  /* Hide scrollbars */
  *::-webkit-scrollbar{width:0;height:0;background:transparent}
  *{scrollbar-width:none;-ms-overflow-style:none}

  /* Topbar */
  .topbar{
    display:flex;align-items:center;gap:10px;padding:10px 12px;background:var(--panel);
    -webkit-app-region:drag;
  }
  .brand{display:flex;align-items:center}
  .brand img{height:32px;opacity:.95;display:block} /* reduced for precise topbar spacing */
  .spacer{flex:1}
  .icon-btn,.search{ -webkit-app-region:no-drag }
  .icon-btn{
    width:30px;height:30px;display:grid;place-items:center;border-radius:8px;border:0;
    background:transparent;color:#cfd6e3;cursor:pointer; /* Farbe laut neuem Snippet */
  }
  .icon-btn:hover{background:var(--row-hover);color:var(--accent)}
  /* Unified icon styling (SVG sprite via <use>) */
  .icon{width:16px;height:16px;display:block;opacity:.9}
  /* Inline icon utility: keep SVG inline within text without breaking lines */
  .icon-inline{display:inline-block;vertical-align:text-bottom;line-height:0}
  .nav-icon .icon{width:18px;height:18px;opacity:.85}
  .icon-btn--danger:hover{background:rgba(224,90,90,0.20);color:#ff6b6b;filter:drop-shadow(0 0 6px rgba(255,107,107,0.25))}

  /* Search */
  .search{display:flex;align-items:center;gap:6px;padding:6px 10px;background:var(--row);border-radius:12px}
  .search .svg{width:14px;height:14px;opacity:.6}
  .search input{background:transparent;border:0;outline:0;color:var(--text);width:280px;font-size:13px}

  /* Content / Table */
  /* Reduced vertical padding to tighten space above table */
  .content{padding:4px 10px 4px}
  .table-wrap{padding:0 6px 4px;overflow-x:auto}
  table{width:100%;border-collapse:collapse;table-layout:auto;box-sizing:border-box}
  #table{font-size:var(--table-font-size,14px)}
  colgroup col.c-lvl{min-width:64px;width:auto}
  colgroup col.c-name{min-width:140px;width:auto}
  colgroup col.c-ws{min-width:50px;width:auto}
  colgroup col.c-fkdr, colgroup col.c-wlr, colgroup col.c-bblr{min-width:70px;width:auto}
  colgroup col.c-fk, colgroup col.c-wins{min-width:80px;width:auto}
  colgroup col.c-actions{min-width:50px;width:50px}

  thead th{
    text-align:left;font-weight:600;color:var(--muted);font-size:12px;padding:3px 6px;cursor:pointer; /* reduced vertical padding */
    -webkit-app-region:no-drag;
  }
  th.metric-h, td.metric{ text-align:right;font-variant-numeric:tabular-nums; font-feature-settings:"tnum" 1,"lnum" 1 }
  tbody td{
    padding:2px 6px;border-top:1px solid rgba(255,255,255,0.06);white-space:nowrap;overflow:hidden;text-overflow:ellipsis; /* tighter rows */
    line-height:1.3;
  }
  tbody tr:hover{background:var(--row-hover)}
  .lvl{font-weight:600}
  .name{font-weight:600;color:#6bd3ff}
  .rank-tag{font-weight:700;margin-right:6px}
  .metric{text-align:right}
  .good{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)}

  /* sort indicators */
  thead th[data-sort-key]{position:relative}
  thead th.sort-asc::after, thead th.sort-desc::after{
    content:"";display:inline-block;margin-left:6px;border:5px solid transparent;opacity:.6
  }
  thead th.sort-asc::after{border-bottom-color:var(--muted)}
  thead th.sort-desc::after{border-top-color:var(--muted)}

  /* Row actions / menu */
  .actions{ text-align:right; position:relative; overflow:visible }
  .menu{
    position:absolute; right:8px; top:28px; background:var(--menu); border-radius:8px; box-shadow:var(--shadow);
    padding:6px; min-width:120px; display:none; z-index:10000;
  }
  .menu.open{display:block}
  .menu button{display:block;width:100%;text-align:left;background:transparent;border:0;color:var(--text);padding:8px 10px;border-radius:6px;cursor:pointer}
  .menu button:hover{background:var(--row-hover)}
  /* Pinned row styling */
  tr.pinned { background: rgba(255,255,255,0.08); }
  tr.pinned:hover { background: rgba(255,255,255,0.10); }
  .pin-indicator { margin-left:4px; color: var(--accent); filter: drop-shadow(0 0 2px rgba(102,234,255,0.4)); }
  thead th.sorted { color: var(--accent); }

  /* Resize grips */
  .grip{position:fixed;z-index:1000;-webkit-app-region:no-drag}
  .g-top{top:0;left:0;right:0;height:var(--grip);cursor:n-resize}
  .g-bottom{bottom:0;left:0;right:0;height:var(--grip);cursor:s-resize}
  .g-left{top:0;bottom:0;left:0;width:var(--grip);cursor:w-resize}
  .g-right{top:0;bottom:0;right:0;width:var(--grip);cursor:e-resize}
  .g-tl{top:0;left:0;width:var(--grip);height:var(--grip);cursor:nw-resize}
  .g-tr{top:0;right:0;width:var(--grip);height:var(--grip);cursor:ne-resize}
  .g-bl{bottom:0;left:0;width:var(--grip);height:var(--grip);cursor:sw-resize}
  .g-br{bottom:0;right:0;width:var(--grip);height:var(--grip);cursor:se-resize}

  /* Sidebar / Toolbar */
  .sidebar{
    position:fixed;left:0;top:0;bottom:0;width:260px;transform:translateX(-100%);
    transition:transform .22s cubic-bezier(.2,.9,.2,1);
    background:rgba(30,30,36,0.96);color:var(--text);box-shadow:var(--shadow);z-index:2000;
    -webkit-app-region:no-drag;display:flex;flex-direction:column;overflow:hidden;
  }
  .sidebar.open{transform:translateX(0)}
  .sidebar-inner{display:flex;flex-direction:column;height:100%;padding:14px}
  .nav{display:flex;flex-direction:column;gap:6px;margin-top:6px}
  .nav-item{
    display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:8px;background:transparent;color:var(--text);
    border:0;text-align:left;cursor:pointer;-webkit-app-region:no-drag;font-weight:500;
  }
  .nav-item:hover{background:var(--row-hover)}
  .nav-item.active{background:rgba(255,255,255,0.04);font-weight:700}
  .nav-icon{width:22px;display:inline-block;text-align:center}
  .nav-label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .nav-sep{height:1px;background:rgba(255,255,255,0.03);margin:10px 0;border-radius:2px}
  .sidebar-footer{margin-top:auto;display:flex;flex-direction:column;gap:8px;padding-bottom:0}
  .user-row{display:flex;align-items:center;gap:8px;margin-top:8px;color:var(--muted);padding-top:8px;border-top:1px solid rgba(255,255,255,0.02)}
  .user-icon{width:20px;display:inline-block;text-align:center}

  /* Buttons */
  .btn{border:0;padding:9px 10px;border-radius:6px;background:transparent;color:var(--text);cursor:pointer;-webkit-app-region:no-drag}
  .btn.primary{background:#ffb400;color:#111;font-weight:700}
  .btn.community{border:1px solid rgba(255,255,255,0.06);color:var(--accent)}

  /* Panels */
  .panel{display:none;padding:14px;height:calc(100vh - 50px);overflow-y:auto}
  .panel.active{display:block}

  /* Settings section containers */
  .settings-content{display:none}
  .settings-content.active{display:block}

  /* Nicks */
  .nicks-list{background:var(--panel);border-radius:12px;overflow:hidden;margin-top:12px}
  .nick-row{display:flex;align-items:center;padding:12px 16px;border-bottom:1px solid rgba(255,255,255,0.04)}
  .nick-row:last-child{border:0}
  .nick-name{flex:1;margin-right:14px;font-weight:500}
  .nick-real{color:var(--muted);margin-right:14px}
  .delete-btn{opacity:.5;padding:6px;cursor:pointer;border:0;background:transparent;color:var(--text)}
  .delete-btn:hover{opacity:1}
  .add-btn{
    position:fixed;right:20px;bottom:20px;width:48px;height:48px;border-radius:24px;background:var(--accent);color:#111;border:0;
    font-size:24px;cursor:pointer;box-shadow:0 4px 12px var(--accent-soft);transition:transform .2s ease
  }
  .add-btn:hover{transform:scale(1.05);box-shadow:0 6px 16px rgba(102,234,255,0.5)}

  .nick-indicator{display:inline-flex;align-items:center;margin-left:6px;opacity:.7;cursor:help}
  .party-indicator{display:inline-flex;align-items:center;margin-left:4px;opacity:.8;cursor:help;color:var(--accent)}
  .self-indicator{display:inline-flex;align-items:center;margin-left:4px;opacity:1;cursor:help}
  .nick-indicator .icon{width:16px;height:16px}
  .party-indicator .icon{width:16px;height:16px}
  .self-indicator .icon{width:16px;height:16px}

  /* Forms */
  .add-nick-form{background:var(--panel);border-radius:12px;padding:20px;margin-bottom:16px}
  .add-nick-form h2{margin:0 0 16px;font-size:18px;font-weight:600}
  .form-row{margin-bottom:12px}
  .form-label{display:flex;align-items:center;gap:10px;background:rgba(0,0,0,0.2);padding:8px 12px;border-radius:8px}
  .form-label .icon{opacity:.7}
  .form-label input{flex:1;background:transparent;border:0;outline:0;color:var(--text);font-size:14px;padding:4px 0}
  .form-submit{width:100%;background:var(--accent);color:#111;border:0;padding:10px;border-radius:8px;font-weight:600;cursor:pointer;margin-top:4px;transition:all .2s ease}
  .form-submit:hover{transform:scale(1.02);box-shadow:0 4px 12px var(--accent-soft)}

  /* Settings */
  .settings-section{background:var(--panel);border-radius:8px;margin-top:16px;padding:20px}
  .settings-section h2{margin:0 0 20px;font-size:18px;font-weight:600;display:flex;align-items:center;gap:8px}
  .settings-icon .icon{width:18px;height:18px}
  .settings-row{margin-bottom:16px;display:flex;align-items:center}
  .settings-label{flex:0 0 120px;color:var(--muted)}
  .settings-select{background:rgba(0,0,0,0.2);color:var(--text);border:0;padding:8px 12px;border-radius:6px;min-width:200px}

  /* Stats list */
  .stats-list{display:flex;flex-direction:column;gap:4px}
  .stat-row{display:flex;align-items:center;padding:8px 12px;background:rgba(0,0,0,0.2);border-radius:8px;gap:12px}
  .stat-drag{cursor:move;color:var(--muted);font-size:16px}
  .stat-toggle{flex:1;display:flex;align-items:center;gap:8px;cursor:pointer}
  .stat-settings-btn{background:transparent;border:0;color:var(--text);opacity:.7;cursor:pointer;padding:4px 8px;border-radius:4px}
  .stat-settings-btn:hover{opacity:1;background:rgba(255,255,255,0.05)}

  /* Dynamic stat layout editor */
  /* unify background: remove nested panel look */
  .layout-editor{margin-top:16px;padding:14px;background:transparent;border:1px dashed rgba(255,255,255,0.12);border-radius:12px;display:flex;flex-direction:column;gap:14px}
  .layout-editor h3{margin:0;font-size:15px;font-weight:600;display:flex;align-items:center;gap:8px}
  .layout-palette{display:flex;flex-wrap:wrap;gap:8px}
  .stat-pill{padding:6px 10px;background:rgba(255,255,255,0.07);border-radius:24px;font-size:12px;font-weight:500;cursor:grab;user-select:none;display:flex;align-items:center;gap:6px;position:relative}
  .stat-pill[data-used="1"]{opacity:.35;filter:grayscale(60%);cursor:not-allowed}
  .stat-pill.disabled{opacity:.35;filter:grayscale(80%);cursor:not-allowed}
  .layout-slots{display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:8px}
  .slot{background:rgba(255,255,255,0.05);border:1px dashed rgba(255,255,255,0.14);border-radius:10px;min-height:46px;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);position:relative;padding:4px;transition:.15s}
  .slot.filled{border-style:solid;color:var(--text);font-weight:500}
  .slot.drag-over{outline:2px solid var(--accent);outline-offset:2px}
  .slot .slot-remove{position:absolute;top:4px;right:4px;background:rgba(0,0,0,0.4);border:0;color:var(--muted);width:20px;height:20px;border-radius:6px;cursor:pointer;font-size:14px;display:flex;align-items:center;justify-content:center}
  .slot .slot-remove:hover{color:#fff;background:rgba(0,0,0,0.65)}
  .layout-help{font-size:11px;color:var(--muted);line-height:1.4}

  /* Modal / Color rules */
  .modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:9000}
  .modal.open{display:flex;align-items:center;justify-content:center;animation:fadeIn .25s ease}
  @keyframes fadeIn{from{opacity:0}to{opacity:1}}
  .modal-content{background:linear-gradient(145deg,rgba(25,28,32,0.95),rgba(30,34,38,0.95));backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.08);box-shadow:0 8px 32px -8px rgba(0,0,0,0.6);border-radius:16px;width:92%;max-width:560px;max-height:88vh;overflow:auto;display:flex;flex-direction:column}
  .modal-header{padding:18px 24px;border-bottom:1px solid rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:space-between}
  .modal-header h3{margin:0;font-size:17px;font-weight:600;letter-spacing:.5px;display:flex;align-items:center;gap:8px}
  .modal-header h3 .stat-full-name{opacity:.6;font-weight:400;font-size:13px}
  .modal-close{background:rgba(255,255,255,0.04);border:0;color:var(--muted);font-size:20px;cursor:pointer;width:36px;height:36px;border-radius:10px;display:flex;align-items:center;justify-content:center;transition:.15s}
  .modal-close:hover{background:rgba(255,255,255,0.08);color:#fff}
  .modal-body{padding:22px 24px;display:flex;flex-direction:column;gap:20px}
  
  /* Simple notification modal (for alerts) */
  .notification-modal .modal-content{max-width:400px;text-align:center}
  .notification-modal .modal-body{padding:28px 24px;align-items:center}
  .notification-modal .message{font-size:15px;line-height:1.6;color:var(--text)}
  .notification-modal .ok-btn{margin-top:16px;padding:10px 24px;background:var(--accent);color:#0b1e24;border:0;border-radius:8px;font-weight:600;font-size:14px;cursor:pointer;transition:.15s}
  .notification-modal .ok-btn:hover{filter:brightness(1.1);transform:translateY(-1px)}
  .color-rules{display:flex;flex-direction:column;gap:10px;margin:0}
  .color-rule{display:grid;grid-template-columns:70px 90px 90px 1fr 40px;align-items:center;gap:10px;background:rgba(255,255,255,0.03);padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,0.05);position:relative;transition:.15s}
  .color-rule:hover{background:rgba(255,255,255,0.05);border-color:rgba(255,255,255,0.09)}
  .rule-operator,.rule-value{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.15);color:var(--text);border-radius:8px;padding:6px 8px;font-size:13px}
  .rule-operator:focus,.rule-value:focus{outline:2px solid var(--accent);outline-offset:2px}
  .color-picker{display:flex;align-items:center;gap:8px}
  .color-preview{width:34px;height:24px;border-radius:8px;border:1px solid rgba(255,255,255,0.15);box-shadow:inset 0 0 0 2px rgba(0,0,0,0.3)}
  .color-input{width:90px;height:32px;padding:0;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.15);border-radius:8px;cursor:pointer}
  .color-input::-webkit-color-swatch{border:0;border-radius:6px}
  .color-input::-webkit-color-swatch-wrapper{padding:4px}
  .rule-delete{background:rgba(255,255,255,0.05);border:0;color:var(--muted);cursor:pointer;border-radius:8px;width:32px;height:32px;display:flex;align-items:center;justify-content:center;font-size:18px;transition:.15s}
  .rule-delete:hover{background:rgba(255,0,0,0.25);color:#fff}
  .add-rule-btn{width:100%;padding:12px 16px;background:rgba(255,255,255,0.04);border:1px dashed rgba(255,255,255,0.15);color:var(--text);border-radius:12px;cursor:pointer;font-weight:500;letter-spacing:.5px}
  .add-rule-btn:hover{background:rgba(255,255,255,0.07);border-style:solid}

  /* Settings navigation */
  .settings-nav{display:flex;flex-direction:column;gap:1px;background:var(--panel);border-radius:12px;overflow:hidden}
  .settings-nav-item{display:flex;align-items:center;gap:10px;padding:14px 16px;background:var(--panel);border:0;color:var(--text);font-size:14px;text-align:left;cursor:pointer}
  .settings-nav-item:hover{background:rgba(255,255,255,0.03)}
  .settings-nav-item.active{font-weight:700}
  .settings-nav-item .nav-icon{width:20px;text-align:center;font-size:16px}
  .settings-nav-item .nav-label{flex:1;font-weight:500}
  .nav-arrow{font-size:12px;opacity:.5;margin-left:4px;transition:transform .2s}
  .settings-nav-item.active .nav-arrow{transform:rotate(180deg)}
  .nav-item.expanded .nav-arrow{transform:rotate(180deg)}
  .nav-item.expanded .nav-icon .icon{transform:rotate(45deg);}
  .nav-icon .icon{transition:transform .25s ease;}
  .settings-submenu{display:none;margin-left:24px;margin-top:4px;border-left:1px solid rgba(255,255,255,0.1)}
  .settings-submenu.expanded{display:block}
  .nav-item.sub-item{padding:8px 12px;font-size:13px}
  .nav-item.sub-item .nav-icon{font-size:14px}
  /* Removed: green text for stats */

  /* Keyboard grid */
  .kb-grid{display:flex;flex-direction:column;gap:10px}
  .kb-row{display:flex;align-items:center;gap:12px;background:rgba(0,0,0,0.2);padding:12px;border-radius:8px}
  .kb-action{flex:1}
  .kb-input{min-width:160px; text-align:center; padding:10px 12px; border-radius:8px; background:rgba(255,255,255,0.06); cursor:pointer}
  .kb-input.listening{outline:2px solid var(--accent)}
  .kb-help{padding:10px 12px;background:rgba(255,255,255,0.03);border-radius:8px;font-size:13px;line-height:1.5}
  /* Nicks help box (like kb-help) */
  .nicks-help{padding:10px 12px;background:rgba(255,255,255,0.03);border-radius:8px;font-size:13px;line-height:1.5;color:var(--muted);margin-bottom:16px}

  /* Settings inputs & controls */
  .settings-input{width:100%;padding:8px 12px;background:var(--row);border:1px solid rgba(255,255,255,0.1);border-radius:8px;color:var(--text);font-size:14px;outline:0}
  .settings-input:focus{border-color:var(--accent)}
  .settings-select{width:100%;padding:8px 12px;background:var(--row);border:1px solid rgba(255,255,255,0.1);border-radius:8px;color:var(--text);font-size:14px;cursor:pointer;outline:0}
  .settings-select:focus{border-color:var(--accent)}
  .settings-textarea{width:100%;padding:8px 12px;background:var(--row);border:1px solid rgba(255,255,255,0.1);border-radius:8px;color:var(--text);font-size:13px;outline:0;resize:vertical}
  .settings-textarea:focus{border-color:var(--accent)}
  /* Unified accent checkbox (used in Sources + Appearance) */
  .accent-checkbox{
    -webkit-appearance:none;appearance:none;width:20px;height:20px;margin:2px 0 0 0;cursor:pointer;flex-shrink:0;
    border:2px solid var(--accent);border-radius:6px;background:rgba(255,255,255,0.05);position:relative;transition:.18s;
    display:inline-block;
  }
  .accent-checkbox:hover{box-shadow:0 0 0 3px rgba(102,234,255,0.18)}
  .accent-checkbox:focus{outline:2px solid var(--accent);outline-offset:2px}
  .accent-checkbox:checked{background:var(--accent);border-color:var(--accent);}
  .accent-checkbox:checked::after{content:"";display:none}
  /* Apply same accent style automatically to all settings checkboxes without needing the class */
  .settings-checkbox input[type="checkbox"]{
    -webkit-appearance:none;appearance:none;width:20px;height:20px;margin:2px 0 0 0;cursor:pointer;flex-shrink:0;
    border:2px solid var(--accent);border-radius:6px;background:rgba(255,255,255,0.05);position:relative;transition:.18s;display:inline-block;
  }
  .settings-checkbox input[type="checkbox"]:hover{box-shadow:0 0 0 3px rgba(102,234,255,0.18)}
  .settings-checkbox input[type="checkbox"]:focus{outline:2px solid var(--accent);outline-offset:2px}
  .settings-checkbox input[type="checkbox"]:checked{background:var(--accent);border-color:var(--accent)}
  .settings-checkbox input[type="checkbox"]:checked::after{content:"";display:none}
  /* Accent range sliders */
  input[type="range"]{ -webkit-appearance:none; appearance:none; width:100%; height:6px; background:rgba(255,255,255,0.12); border-radius:4px; outline:none; cursor:pointer; }
  input[type="range"]:focus{outline:2px solid var(--accent);outline-offset:2px}
  input[type="range"]::-webkit-slider-runnable-track{height:6px;background:rgba(255,255,255,0.12);border-radius:4px}
  input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:16px; height:16px; border-radius:50%; background:var(--accent); border:2px solid #04161c; margin-top:-5px; box-shadow:0 0 0 3px rgba(102,234,255,0.25); transition:.15s }
  input[type="range"]:hover::-webkit-slider-thumb{box-shadow:0 0 0 4px rgba(102,234,255,0.35)}
  input[type="range"]::-moz-range-track{height:6px;background:rgba(255,255,255,0.12);border-radius:4px}
  input[type="range"]::-moz-range-thumb{width:16px;height:16px;border-radius:50%;background:var(--accent);border:2px solid #04161c;box-shadow:0 0 0 3px rgba(102,234,255,0.25)}
  input[type="range"]::-ms-track{height:6px;background:transparent;border-color:transparent;color:transparent}
  input[type="range"]::-ms-fill-lower,input[type="range"]::-ms-fill-upper{background:rgba(255,255,255,0.12);border-radius:4px}
  input[type="range"]::-ms-thumb{width:16px;height:16px;border-radius:50%;background:var(--accent);border:2px solid #04161c;box-shadow:0 0 0 3px rgba(102,234,255,0.25)}
  /* Nick select (transparent + accent for value) */
  .nick-select{background:transparent;border:1px solid rgba(255,255,255,0.12);color:var(--accent);padding:8px 10px;border-radius:8px;font-size:13px;backdrop-filter:blur(4px);cursor:pointer}
  .nick-select:hover{border-color:var(--accent);box-shadow:0 0 0 3px rgba(102,234,255,0.12)}
  .nick-select:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 3px rgba(102,234,255,0.2)}
  .nick-select option{color:var(--text);background:#1f2230}
  
  /* Toggle switch */
  .toggle-switch{position:relative;width:44px;height:24px;display:inline-block}
  .toggle-switch input{opacity:0;width:0;height:0}
  .toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:rgba(255,255,255,0.1);border-radius:24px;transition:.3s}
  .toggle-slider:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background:white;border-radius:50%;transition:.3s}
  .toggle-switch input:checked + .toggle-slider{background:var(--accent)}
  .toggle-switch input:checked + .toggle-slider:before{transform:translateX(20px)}
  
  /* Checkbox */
  .settings-checkbox{display:flex;align-items:flex-start;gap:8px;padding:8px 0;cursor:pointer;user-select:none}
  .settings-checkbox input[type="checkbox"]{width:18px;height:18px;margin:2px 0 0 0;cursor:pointer;flex-shrink:0}
  .settings-checkbox span{flex:1}
  .settings-checkbox small{display:block;margin-top:4px}
  
  /* Plus badge */
  .plus-badge{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:2px 8px;border-radius:4px;font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:0.3px}
  
  /* Settings subsections */
  .settings-subsection{margin-bottom:24px;padding-bottom:24px;border-bottom:1px solid rgba(255,255,255,0.06)}
  .settings-subsection:last-child{border-bottom:0;margin-bottom:0;padding-bottom:0}
  .source-options{margin-left:0;display:flex;flex-direction:column;gap:4px}

  /* Profile Panel Styles */
  .profile-container{display:flex;flex-direction:column;gap:20px;padding:0}
  .profile-card{background:var(--panel);border-radius:16px;padding:24px;border:1px solid rgba(255,255,255,0.06)}
  .profile-header{display:flex;align-items:center;gap:16px}
  .profile-avatar{width:80px;height:80px;border-radius:50%;background:linear-gradient(135deg,rgba(102,234,255,0.15),rgba(102,234,255,0.05));border:3px solid var(--accent);display:flex;align-items:center;justify-content:center;font-size:36px;font-weight:700;color:var(--accent);position:relative;overflow:hidden}
  .profile-avatar img{width:100%;height:100%;object-fit:cover;border-radius:50%}
  .profile-avatar.empty::before{content:"";position:absolute;width:48px;height:48px;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2366eaff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2'/%3E%3Ccircle cx='12' cy='7' r='4'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:center;background-size:contain;opacity:0.6}
  .profile-info{flex:1;display:flex;flex-direction:column;gap:6px}
  .profile-username{font-size:24px;font-weight:700;margin:0;display:flex;align-items:center;gap:8px}
  .profile-status{font-size:13px;color:var(--muted);display:flex;align-items:center;gap:6px}
  .profile-status .status-dot{width:8px;height:8px;border-radius:50%;background:var(--accent);box-shadow:0 0 8px var(--accent)}
  .profile-status.offline .status-dot{background:#666;box-shadow:none}
  .profile-actions{display:flex;gap:10px;margin-top:8px}
  .discord-btn{display:flex;align-items:center;gap:8px;padding:10px 20px;background:#5865F2;color:#fff;border:0;border-radius:8px;font-weight:600;cursor:pointer;transition:all .2s ease;font-size:14px}
  .discord-btn:hover{background:#4752C4;transform:translateY(-1px);box-shadow:0 4px 12px rgba(88,101,242,0.4)}
  .discord-btn:active{transform:translateY(0)}
  .discord-btn .icon{width:20px;height:20px}
  .profile-section{margin-top:8px}
  .profile-section h3{margin:0 0 12px;font-size:16px;font-weight:600;display:flex;align-items:center;gap:8px}
  .profile-section h3 .icon{width:18px;height:18px}
  .profile-stat-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
  .profile-stat{background:rgba(0,0,0,0.2);padding:12px 16px;border-radius:10px;display:flex;flex-direction:column;gap:4px}
  .profile-stat-label{font-size:11px;text-transform:uppercase;letter-spacing:0.5px;color:var(--muted);font-weight:600}
  .profile-stat-value{font-size:20px;font-weight:700;color:var(--accent)}
  .plus-card{background:linear-gradient(145deg,rgba(102,114,234,0.1),rgba(118,75,162,0.1));border:1px solid rgba(102,114,234,0.3)}
  .plus-card .plus-icon{font-size:48px;text-align:center;margin-bottom:12px;filter:drop-shadow(0 0 12px rgba(102,114,234,0.5))}
  .plus-status{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;background:rgba(0,0,0,0.2);border-radius:10px;margin-top:12px}
  .plus-status.active{background:linear-gradient(135deg,rgba(102,234,255,0.15),rgba(102,234,255,0.05));border:1px solid var(--accent)}
  
  /* Payment button hover effects */
  .payment-btn-monthly:hover{background:var(--accent)!important;color:white!important;transform:translateY(-2px);box-shadow:0 6px 16px rgba(102,114,234,0.3)!important}
  .payment-btn-yearly:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(32,178,170,0.4)!important}
  .sync-info{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;background:rgba(0,0,0,0.2);border-radius:10px;margin-top:12px}
  .sync-time{font-size:12px;color:var(--muted)}
  .logout-btn{padding:8px 16px;background:rgba(255,255,255,0.05);color:var(--muted);border:1px solid rgba(255,255,255,0.1);border-radius:8px;cursor:pointer;transition:.2s}
  .logout-btn:hover{background:rgba(224,90,90,0.15);color:#ff6b6b;border-color:#ff6b6b}

  /* Session Panel Styles */
  .session-container{display:flex;flex-direction:column;height:100%}
  .session-header{margin-bottom:16px}
  .session-player{display:flex;align-items:center;margin-top:12px}
  .session-content{flex:1;overflow-y:auto}
  #sessionStatsContainer{min-height:200px}
  .session-stat-row{margin-bottom:8px;display:flex;align-items:center;justify-content:space-between}
  .session-stat-label{font-weight:600;color:var(--text)}
  .session-stat-value{font-family:monospace;font-size:13px}
  .session-stat-start{color:var(--muted)}
  .session-stat-arrow{color:var(--accent);margin:0 6px}
  .session-stat-current{color:var(--text)}
  .session-stat-diff{font-weight:600;margin-left:6px}
  .session-stat-diff.positive{color:#22c55e}
  .session-stat-diff.negative{color:#ef4444}
  .session-stat-diff.neutral{color:var(--muted)}
  .session-category{margin-top:20px;margin-bottom:12px}
  .session-category:first-child{margin-top:0}
  .session-category-title{font-size:15px;font-weight:700;color:var(--accent);margin-bottom:8px;display:flex;align-items:center;gap:6px}

  /* --- Client Selection Redesign --- */
  #clientSelectGrid{--btn-h:34px}
  .client-btn{
    position:relative;display:flex;align-items:center;justify-content:center;gap:6px;
    background:linear-gradient(145deg,rgba(40,44,52,0.65),rgba(34,38,46,0.65));
    border:1px solid rgba(255,255,255,0.08);color:var(--text);font-size:12px;font-weight:600;
    padding:6px 10px;border-radius:8px;cursor:pointer;letter-spacing:.4px;min-height:var(--btn-h);
    transition:.18s cubic-bezier(.25,.8,.25,1);backdrop-filter:blur(6px);
  }
  .client-btn:hover{border-color:var(--accent);color:#fff;box-shadow:0 0 0 3px rgba(102,234,255,0.15)}
  .client-btn:active{transform:scale(.96)}
  .client-btn.active{
    background:linear-gradient(135deg,var(--accent) 0%,#41c4e6 100%);
    color:#0b1e24;border-color:var(--accent);box-shadow:0 4px 14px -4px rgba(102,234,255,0.5);
  }
  .client-btn[data-detected="1"]:not(.active){
    outline:2px solid var(--accent);outline-offset:2px;
  }
  .client-btn .badge{background:rgba(255,255,255,0.15);padding:2px 5px;border-radius:6px;font-size:10px;font-weight:700;letter-spacing:.5px}
  .client-btn.active .badge{background:rgba(0,0,0,0.25);color:#fff}
  #clientStatus{margin-top:4px;font-size:12px;line-height:1.4;padding:6px 10px;border-radius:6px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.06)}
  #clientStatus.warn{background:rgba(224,193,77,0.15);border-color:rgba(224,193,77,0.4);color:#f3d98a}
  #clientStatus.ok{background:rgba(67,209,127,0.18);border-color:rgba(67,209,127,0.45);color:#7bf3af}
  #autoDetectBtn{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.15);color:var(--text);font-weight:600}
  #autoDetectBtn:hover{background:var(--accent);color:#04161c;border-color:var(--accent);box-shadow:0 4px 12px -2px rgba(102,234,255,0.5)}
  #customPathRow input{font-size:12px}
  #applyCustomPathBtn{background:linear-gradient(135deg,var(--accent) 0%,#41c4e6 100%);color:#06242b;font-weight:600}
  #applyCustomPathBtn:hover{filter:brightness(1.07)}
  </style>
</head>

<body>
  <!-- Nebula icon sprite (stroke=2, round caps/joins, currentColor) -->
  <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
    <symbol id="i-refresh" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 12a9 9 0 0 1-9 9 9 9 0 1 1 6.3-15.3"/><path d="M21 3v6h-6"/>
    </symbol>
    <symbol id="i-clear" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M3 6h18"/><path d="M8 6V4h8v2"/><path d="M6 6l1 13h10l1-13"/><path d="M10 10v7M14 10v7"/>
    </symbol>
    <symbol id="i-min" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M5 12h14"/></symbol>
    <symbol id="i-close" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M18 6L6 18M6 6l12 12"/></symbol>

    <!-- Sidebar -->
    <symbol id="i-overlay" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M3 11l9-7 9 7"/><path d="M5 10v10h14V10"/>
    </symbol>
    <symbol id="i-nicks" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="8" cy="8.5" r="3"/><path d="M2.5 19c1.6-3 4-4.5 6.5-4.5s4.9 1.5 6.5 4.5"/>
      <path d="M16 5h4M16 9h6M16 13h5" />
    </symbol>
    <symbol id="i-settings" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="3"/>
      <path d="M4 12h2.5M17.5 12H20"/>
      <path d="M12 4v2.5M12 17.5V20"/>
      <path d="M6.6 6.6l1.8 1.8M15.6 15.6l1.8 1.8"/>
      <path d="M6.6 17.4l1.8-1.8M15.6 8.4l1.8-1.8"/>
    </symbol>
    <symbol id="i-basic" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M4 7h12"/><circle cx="16" cy="7" r="2.5"/>
      <path d="M4 17h8"/><circle cx="10" cy="17" r="2.5"/>
    </symbol>
    <symbol id="i-client" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <rect x="3" y="5" width="18" height="14" rx="2"/>
      <path d="M7 9h5M7 13h3M14 13h3"/>
      <path d="M14 9h3"/>
    </symbol>
    <symbol id="i-appearance" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="7"/><path d="M5 12h14M12 5v14"/>
    </symbol>
    <symbol id="i-sources" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M3 16l6-6 4 4 8-8"/><path d="M14 6h7v7"/>
    </symbol>
    <symbol id="i-stats" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <rect x="3" y="5" width="18" height="14" rx="2"/><path d="M9 5v14M15 5v14"/>
    </symbol>
    <symbol id="i-shortcuts" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <rect x="3" y="6" width="18" height="12" rx="2"/><path d="M7 10h2M11 10h2M15 10h2M9 14h6"/>
    </symbol>
    <symbol id="i-profile" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="8" r="4"/><path d="M4 20c1.8-3.2 4.7-5 8-5s6.2 1.8 8 5"/>
    </symbol>
    <!-- Additional icons for settings subitems -->
    <symbol id="i-file" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
      <path d="M14 2v6h6"/>
    </symbol>
    <symbol id="i-ghost" viewBox="0 0 24 24" fill="currentColor">
      <path d="M12 2c-4.42 0-8 3.58-8 8v12l2-2 2 2 2-2 2 2 2-2 2 2 2-2V10c0-4.42-3.58-8-8-8zM9 10a1 1 0 1 1 0 2 1 1 0 0 1 0-2zm6 1a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
    </symbol>
    <symbol id="i-party" viewBox="0 0 24 24" fill="currentColor">
      <path d="M16 11c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3zm-8 0c1.66 0 3-1.34 3-3S9.66 5 8 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
    </symbol>
    <symbol id="i-discord" viewBox="0 0 24 24" fill="currentColor">
      <path d="M20.317 4.492c-1.53-.69-3.17-1.2-4.885-1.49a.075.075 0 0 0-.079.036c-.21.369-.444.85-.608 1.23a18.565 18.565 0 0 0-5.487 0 12.923 12.923 0 0 0-.617-1.23A.077.077 0 0 0 8.562 3c-1.714.29-3.354.8-4.885 1.491a.07.07 0 0 0-.032.027C.533 9.093-.32 13.555.099 17.961a.08.08 0 0 0 .031.055 20.03 20.03 0 0 0 5.993 2.98.078.078 0 0 0 .084-.026 13.83 13.83 0 0 0 1.226-1.963.074.074 0 0 0-.041-.104 13.201 13.201 0 0 1-1.872-.878.075.075 0 0 1-.008-.125c.126-.093.252-.19.372-.287a.075.075 0 0 1 .078-.01c3.927 1.764 8.18 1.764 12.061 0a.075.075 0 0 1 .079.009c.12.098.245.195.372.288a.075.075 0 0 1-.006.125c-.598.344-1.22.635-1.873.877a.075.075 0 0 0-.041.105c.36.687.772 1.341 1.225 1.962a.077.077 0 0 0 .084.028 19.963 19.963 0 0 0 6.002-2.981.076.076 0 0 0 .032-.054c.5-5.094-.838-9.52-3.549-13.442a.06.06 0 0 0-.031-.028zM8.02 15.278c-1.182 0-2.157-1.069-2.157-2.38 0-1.312.956-2.38 2.157-2.38 1.21 0 2.176 1.077 2.157 2.38 0 1.312-.956 2.38-2.157 2.38zm7.975 0c-1.183 0-2.157-1.069-2.157-2.38 0-1.312.955-2.38 2.157-2.38 1.21 0 2.176 1.077 2.157 2.38 0 1.312-.946 2.38-2.157 2.38z"/>
    </symbol>
    <symbol id="i-cloud" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"/>
    </symbol>
    <symbol id="i-plus" viewBox="0 0 24 24" fill="currentColor">
      <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/>
    </symbol>
    <symbol id="i-target" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="10"/>
      <circle cx="12" cy="12" r="6"/>
      <circle cx="12" cy="12" r="2"/>
    </symbol>
    <!-- Self/Own user indicator -->
    <symbol id="i-self" viewBox="0 0 24 24" fill="currentColor">
      <circle cx="12" cy="8" r="4" stroke="currentColor" stroke-width="2" fill="none"/><path d="M4 20c1.8-3.2 4.7-5 8-5s6.2 1.8 8 5" stroke="currentColor" stroke-width="2" fill="none"/><circle cx="18" cy="6" r="3" fill="currentColor"/>
    </symbol>
    <symbol id="i-check" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="20,6 9,17 4,12"/>
    </symbol>
    <!-- Step icons for Discord login guide -->
    <symbol id="i-step-1" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="11" fill="var(--accent)" stroke="none"/>
      <text x="12" y="16" text-anchor="middle" font-family="sans-serif" font-size="12" font-weight="bold" fill="white">1</text>
    </symbol>
    <symbol id="i-step-2" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="11" fill="var(--accent)" stroke="none"/>
      <text x="12" y="16" text-anchor="middle" font-family="sans-serif" font-size="12" font-weight="bold" fill="white">2</text>
    </symbol>
    <symbol id="i-step-3" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="11" fill="var(--accent)" stroke="none"/>
      <text x="12" y="16" text-anchor="middle" font-family="sans-serif" font-size="12" font-weight="bold" fill="white">3</text>
    </symbol>
    <symbol id="i-user" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
      <circle cx="12" cy="7" r="4"/>
    </symbol>
    <symbol id="i-key" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="7" cy="7" r="3"/>
      <path d="m21 12-4.4-4.4a1.5 1.5 0 0 0-2.12 0L9.5 12.5a1.5 1.5 0 0 0 0 2.12L14 19l7-7z"/>
      <path d="M16 8 2 22"/>
      <path d="m8 16 6-6"/>
    </symbol>
    <symbol id="i-info" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="10"/>
      <path d="m9 12 2 2 4-4"/>
    </symbol>
    <symbol id="i-session" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="3"/>
      <path d="M12 1v6"/>
      <path d="M12 17v6"/>
      <path d="m4.2 4.2 4.2 4.2"/>
      <path d="m15.6 15.6 4.2 4.2"/>
      <path d="M1 12h6"/>
      <path d="M17 12h6"/>
      <path d="m4.2 19.8 4.2-4.2"/>
      <path d="m15.6 8.4 4.2-4.2"/>
    </symbol>
    <symbol id="i-pin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M16 3l5 5-5 5-4-4-6 6-2-2 6-6-4-4 5-5z"/>
    </symbol>
  </svg>
  <div class="topbar">
    <button id="menuBtn" class="icon-btn" aria-label="Menu" title="Menu">
      <svg class="svg" viewBox="0 0 24 24" fill="currentColor">
        <path d="M3 6h18v2H3V6zm0 5h18v2H3v-2zm0 5h18v2H3v-2z"/>
      </svg>
    </button>
  <div class="brand"><img src="../../assets/nebula-lettering.svg" alt="Nebula"></div>
    <div class="spacer"></div>

    <!-- Refresh -->
    <button id="refresh" class="icon-btn" aria-label="Refresh" title="Refresh">
      <svg class="icon" aria-hidden="true"><use href="#i-refresh"/></svg>
    </button>

    <!-- Clear all -->
    <button id="clearAll" class="icon-btn" aria-label="Clear all players" title="Clear all players">
      <svg class="icon" aria-hidden="true"><use href="#i-clear"/></svg>
    </button>

    <!-- Search -->
    <div class="search">
      <svg class="svg" viewBox="0 0 24 24" fill="currentColor">
        <path d="M15.5 14h-.79l-.28-.27A6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79L20 21.5 21.5 20 15.5 14zM9.5 14A4.5 4.5 0 1 1 14 9.5 4.5 4.5 0 0 1 9.5 14z"/>
      </svg>
      <input id="playerInput" placeholder="Search player(s), comma-separated" />
    </div>

    <!-- Minimize -->
    <button id="minBtn" class="icon-btn" aria-label="Minimize" title="Minimize">
      <svg class="icon" aria-hidden="true"><use href="#i-min"/></svg>
    </button>

    <!-- Close -->
    <button id="closeBtn" class="icon-btn icon-btn--danger" aria-label="Close" title="Close">
      <svg class="icon" aria-hidden="true"><use href="#i-close"/></svg>
    </button>


  </div>

  <aside id="sidebar" class="sidebar" aria-hidden="true">
    <div class="sidebar-inner">
      <nav class="nav">
        <button class="nav-item active" data-panel="overlay">
          <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-overlay"/></svg></span>
          <span class="nav-label">Overlay</span>
        </button>

        <button class="nav-item" data-panel="session">
          <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-session"/></svg></span>
          <span class="nav-label">Session</span>
        </button>

        <button class="nav-item" data-panel="nicks">
          <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-nicks"/></svg></span>
          <span class="nav-label">Nicks</span>
        </button>

  <!-- Direct settings entries -->
        <div class="nav-sep"></div>
        <button class="nav-item" data-panel="columns">
          <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-stats"/></svg></span>
          <span class="nav-label">Columns</span>
        </button>
        <button class="nav-item" data-panel="sources">
          <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-sources"/></svg></span>
          <span class="nav-label">Sources</span>
        </button>
        <button class="nav-item" data-panel="keyboard">
          <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-shortcuts"/></svg></span>
          <span class="nav-label">Keyboard Shortcuts</span>
        </button>
        <button class="nav-item" data-panel="appearance">
          <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-appearance"/></svg></span>
          <span class="nav-label">Appearance</span>
        </button>
        <button class="nav-item" data-panel="client">
          <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-client"/></svg></span>
          <span class="nav-label">Client Selection</span>
        </button>
        <div class="nav-sep"></div>
        <button class="nav-item" data-panel="profile">
          <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-profile"/></svg></span>
          <span class="nav-label">Profile</span>
        </button>
      
    </div>
  </aside>

  <div class="content">
    <!-- Overlay Panel -->
    <div class="panel" id="panel-overlay">
      <div class="table-wrap">
        <table id="table">
          <colgroup>
            <col class="c-lvl"><col class="c-name"><col class="c-ws">
            <col class="c-fkdr"><col class="c-wlr"><col class="c-bblr">
            <col class="c-fk"><col class="c-wins"><col class="c-actions">
          </colgroup>
          <thead>
            <tr>
              <th data-sort-key="level">Lvl</th>
              <th>Name</th>
              <th class="metric-h" data-sort-key="ws">WS</th>
              <th class="metric-h" data-sort-key="fkdr">FKDR</th>
              <th class="metric-h" data-sort-key="wlr">WLR</th>
              <th class="metric-h" data-sort-key="bblr">BBLR</th>
              <th class="metric-h" data-sort-key="fk">F. Kills</th>
              <th class="metric-h" data-sort-key="wins">Wins</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </div>
    </div>

    <!-- Session Panel -->
    <div class="panel" id="panel-session">
      <div class="session-container">
        <div class="session-header">
          <div class="session-info">
            <h2 style="margin:0 0 8px;font-size:18px;font-weight:600;display:flex;align-items:center;gap:8px">
              <span class="settings-icon">
                <svg class="icon" aria-hidden="true"><use href="#i-session"/></svg>
              </span>
              <span id="sessionTitle">Session Stats</span>
            </h2>
            <div class="session-player">
              <img id="sessionAvatar" src="https://crafatar.com/avatars/MHF_Steve?size=48&default=MHF_Steve&overlay" 
                   style="width:48px;height:48px;border-radius:8px;margin-right:12px;" alt="Player Avatar">
              <div>
                <div id="sessionIgn" style="font-size:16px;font-weight:600;color:var(--text);">No player selected</div>
                <div id="sessionTime" style="font-size:12px;color:var(--muted);margin-top:2px;">Session not started</div>
              </div>
            </div>
          </div>
        </div>

        <div class="session-content">
          <div id="sessionStatsContainer" style="background:var(--panel);border-radius:12px;padding:20px;margin-top:16px;">
            <div id="sessionStats" style="font-size:14px;line-height:1.6;">
              <div style="text-align:center;color:var(--muted);padding:40px 20px;">
                <svg class="icon" aria-hidden="true" style="width:48px;height:48px;margin-bottom:12px;opacity:0.5;"><use href="#i-session"/></svg>
                <div style="font-size:16px;margin-bottom:8px;">No Session Active</div>
                <div style="font-size:13px;">Enter your Minecraft IGN in Profile settings and start playing to track session stats!</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Nicks Panel -->
    <div class="panel" id="panel-nicks">
      <h2 style="margin:0 0 16px;font-size:18px;font-weight:600;display:flex;align-items:center;gap:8px">
        <span class="settings-icon">
          <svg class="icon" aria-hidden="true"><use href="#i-nicks"/></svg>
        </span>
        Nickname Handling
      </h2>
      <div
        style="
          padding:12px 14px;
          border-radius:10px;
          background:var(--panel);
          display:flex;
          flex-direction:column;
          gap:12px;
        "
      >
        <div style="font-size:13px;color:var(--text);line-height:1.5">
          Manage how <b>nicked players</b> are displayed in the overlay. You can assign nicknames to their
          real player names and decide how they should appear. When a registered nickname is detected, a
          <svg class="icon icon-inline" style="width:16px;height:16px;vertical-align:-2px" aria-hidden="true" title="Nick recognised">
            <use href="#i-ghost"/>
          </svg>
          icon appears next to the name so you recognize them instantly.
        </div>
        <label style="display:flex;flex-direction:column;gap:6px">
          <select id="nickDisplayMode" class="nick-select">
            <option value="nick">Show nickname (real stats)</option>
            <option value="real">Show real name</option>
          </select>
        </label>
        <div style="font-size:11.5px;color:var(--muted);line-height:1.5">
          The displayed name can be either the nickname or the real one —
          <b>stats always reflect the real player</b>. The
          <svg class="icon icon-inline" style="width:14px;height:14px;vertical-align:-2px" aria-hidden="true">
            <use href="#i-ghost"/>
          </svg>
          icon is always shown; the tooltip reveals the alternate name.
        </div>
      </div>
      <!-- Add Nick Form -->
      <div class="add-nick-form" id="addNickForm" style="display:none;margin:20px 0 16px;">
        <h3 style="margin:0 0 16px;font-size:16px;font-weight:600">Add new nick</h3>
        <div class="form-row">
          <label class="form-label">
            <svg class="icon" aria-hidden="true"><use href="#i-nicks"/></svg>
            <input type="text" id="nickInput" placeholder="Nick" />
          </label>
        </div>
        <div class="form-row">
          <label class="form-label">
            <svg class="icon" aria-hidden="true"><use href="#i-target"/></svg>
            <input type="text" id="realNameInput" placeholder="Real name" />
          </label>
        </div>
        <button class="form-submit" id="saveNickBtn">ADD</button>
      </div>

      <!-- Nicks List -->
      <div class="nicks-list" id="nicksList" style="margin:12px 0 12px;">
        <!-- Nicks werden hier per JS eingefügt -->
      </div>
      <button class="add-btn" id="addNickBtn" title="Add nick" style="margin-top:4px;">+</button>
    </div>

  <!-- Client & Account Panel (was part of Basic Settings) -->
  <div class="panel" id="panel-client">
        <div class="settings-section">
          <h2>
            <span class="settings-icon"><svg class="icon" aria-hidden="true"><use href="#i-basic"/></svg></span>
            Client & API Management
          </h2>

          <div class="settings-subsection">
            <h3 style="margin: 20px 0 12px; font-size: 16px; font-weight: 600; display:flex; align-items:center; gap:8px;">
              <svg class="icon" aria-hidden="true"><use href="#i-client"/></svg>
              Client Selection
            </h3>
            
            <!-- Log File Dropdown -->
            <div class="settings-subrow" style="display:flex;flex-direction:column;gap:12px;">
              <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
                <span class="settings-icon" style="width:24px;text-align:center"><svg class="icon" aria-hidden="true"><use href="#i-file"/></svg></span>
                <label class="settings-label" style="margin:0;">Minecraft Client</label>
                <button id="autoDetectBtn" type="button" style="margin-left:auto;background:var(--row);border:1px solid rgba(255,255,255,0.1);color:var(--text);padding:6px 12px;border-radius:8px;font-size:12px;cursor:pointer;">Auto-Detect</button>
              </div>
              <div id="clientSelectGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(110px,1fr));gap:8px;width:100%;">
                <button class="client-btn" data-client="badlion"><span class="badge">BL</span> Badlion</button>
                <button class="client-btn" data-client="lunar"><span class="badge">LC</span> Lunar</button>
                <button class="client-btn" data-client="vanilla"><span class="badge">VN</span> Vanilla</button>
                <button class="client-btn" data-client="pvplounge"><span class="badge">PL</span> PvPLounge</button>
                <button class="client-btn" data-client="labymod"><span class="badge">LM</span> LabyMod</button>
                <button class="client-btn" data-client="feather"><span class="badge">FT</span> Feather</button>
                <button class="client-btn" data-client="custom"><span class="badge">C</span> Custom...</button>
              </div>
              <div id="customPathRow" style="display:none;flex-direction:column;gap:4px;">
                <input id="customLogPathInput" type="text" placeholder="Absolute path to latest.log" style="width:100%;padding:8px 12px;background:var(--row);border:1px solid rgba(255,255,255,0.15);border-radius:8px;color:var(--text);font-size:12px;" />
                <div style="display:flex;align-items:center;gap:8px;">
                  <button id="applyCustomPathBtn" type="button" style="background:var(--accent);border:0;color:#fff;padding:6px 14px;border-radius:6px;font-size:12px;cursor:pointer;">Apply Path</button>
                  <small style="color:var(--muted);font-size:11px;">Changing the path resets player/party lists.</small>
                </div>
              </div>
              <div id="clientStatus" class="ok">No client selected yet.</div>
            </div>
          </div>
          <!-- API Management subsection -->
          <div class="settings-subsection">
            <h3 style="margin: 0 0 10px; font-size: 16px; font-weight: 600; display:flex; align-items:center; gap:8px;">
              <svg class="icon" aria-hidden="true"><use href="#i-cloud"/></svg>
              Hypixel API Management
            </h3>
            
            <!-- API Status -->
            <div class="settings-row" style="margin-bottom:12px;">
              <span class="settings-icon" style="width:24px;text-align:center;"><svg class="icon" aria-hidden="true"><use href="#i-info"/></svg></span>
              <div style="flex: 1;">
                <div id="apiStatus" style="font-size:13px;color:var(--muted);">
                  <div id="backendStatus">Checking backend...</div>
                  <div id="userKeyStatus">No user key configured</div>
                </div>
              </div>
            </div>

            <!-- User API Key Input -->
            <div class="settings-row" style="margin-bottom:8px;">
              <span class="settings-icon" style="width:24px;text-align:center"><svg class="icon" aria-hidden="true"><use href="#i-key"/></svg></span>
              <div style="flex: 1; display: flex; flex-direction: column; gap: 6px;">
                <div style="display:flex;gap:8px;align-items:center;">
                  <input id="apiKeyInput" type="password" placeholder="Your Hypixel API Key (optional)" class="settings-input" style="flex:1; padding: 8px 12px; background: var(--row); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: var(--text); font-size: 14px;" />
                  <button id="pasteApiKeyBtn" type="button" style="background:var(--accent);border:0;color:#fff;padding:8px 12px;border-radius:6px;font-size:12px;cursor:pointer;min-width:60px;">Paste</button>
                  <button id="testApiKeyBtn" type="button" style="background:var(--row);border:1px solid rgba(255,255,255,0.2);color:var(--text);padding:8px 12px;border-radius:6px;font-size:12px;cursor:pointer;min-width:60px;">Test</button>
                </div>
                <small style="color:var(--muted);font-size:11px;">
                  Get your API key at <a href="#" id="hypixelApiLink" style="color:var(--accent);">hypixel.net</a> • Only needed if backend is unavailable
                </small>
              </div>
            </div>

            <!-- Fallback Setting -->
            <div class="settings-row" style="margin-bottom:12px;">
              <span class="settings-icon" style="width:24px;text-align:center"><svg class="icon" aria-hidden="true"><use href="#i-settings"/></svg></span>
              <div style="flex: 1; display: flex; align-items: center; justify-content: space-between;">
                <div style="display: flex; flex-direction: column;">
                  <span>Use API Key Fallback</span>
                  <small style="color:var(--muted);font-size:11px;">Fall back to your API key when backend is unavailable</small>
                </div>
                <label class="toggle-switch">
                  <input type="checkbox" id="fallbackKeyToggle" checked />
                  <span class="slider"></span>
                </label>
              </div>
            </div>

            <!-- API Actions -->
            <div class="settings-row" style="gap:8px;">
              <span class="settings-icon" style="width:24px;text-align:center"><svg class="icon" aria-hidden="true"><use href="#i-refresh"/></svg></span>
              <div style="display:flex;gap:8px;flex:1;">
                <button id="clearCacheBtn" type="button" style="background:var(--row);border:1px solid rgba(255,255,255,0.2);color:var(--text);padding:8px 12px;border-radius:6px;font-size:12px;cursor:pointer;flex:1;">Clear Cache</button>
                <button id="refreshApiStatusBtn" type="button" style="background:var(--row);border:1px solid rgba(255,255,255,0.2);color:var(--text);padding:8px 12px;border-radius:6px;font-size:12px;cursor:pointer;flex:1;">Refresh Status</button>
              </div>
            </div>
          </div>
    </div>
  </div>

  <!-- Sources Settings Panel -->
  </div>

  <div class="panel" id="panel-sources">
        <div class="settings-section">
          <h2>
            <span class="settings-icon"><svg class="icon" aria-hidden="true"><use href="#i-sources"/></svg></span>
            Sources Settings
          </h2>

          <!-- Game Section -->
          <div class="settings-subsection">
            <div style="display: flex; align-items: center; justify-content: space-between; margin: 20px 0 12px;">
              <h3 style="margin: 0; font-size: 16px; font-weight: 600;">Game</h3>
              <label class="toggle-switch">
                <input type="checkbox" id="sourceGameToggle" checked />
                <span class="toggle-slider"></span>
              </label>
            </div>

            <div class="source-options" id="gameSourceOptions">
                <label class="settings-checkbox">
                  <input type="checkbox" id="gameAddFromWho" checked />
                  <span>Add from /who (ONLINE list)</span>
                </label>
              <label class="settings-checkbox">
                <input type="checkbox" id="gameAddFromChat" checked />
                <span>Add From Chat</span>
              </label>
              <label class="settings-checkbox">
                <input type="checkbox" id="gameRemoveOnDeath" checked />
                <span>Remove on Final Death</span>
              </label>
              <label class="settings-checkbox">
                <input type="checkbox" id="gameRemoveOnDisconnect" checked />
                <span>Remove/Add on Disconnect/Reconnect</span>
                <small style="display: block; color: var(--muted); margin-left: 24px; font-size: 12px;">Players who disconnect while respawning will not be removed.</small>
              </label>
              <label class="settings-checkbox">
                <input type="checkbox" id="gameRemoveOnServerChange" checked />
                <span>Remove All on Server Change</span>
              </label>
            </div>
          </div>

          <!-- Party Section -->
          <div class="settings-subsection">
            <div style="display: flex; align-items: center; justify-content: space-between; margin: 20px 0 12px;">
              <h3 style="margin: 0; font-size: 16px; font-weight: 600;">Party</h3>
              <label class="toggle-switch">
                <input type="checkbox" id="sourcePartyToggle" checked />
                <span class="toggle-slider"></span>
              </label>
            </div>

            <div class="source-options" id="partySourceOptions">
              <label class="settings-checkbox">
                <input type="checkbox" id="partyRemoveOnMemberLeave" checked />
                <span>Remove member on leave</span>
              </label>
              <label class="settings-checkbox">
                <input type="checkbox" id="partyRemoveAllOnLeaveOrDisband" checked />
                <span>Clear all on party leave/disband</span>
              </label>
              <label class="settings-checkbox">
                <input type="checkbox" id="partyShowInviteTemp" checked />
                <span>Show invited player (temp)</span>
              </label>
              <label class="settings-checkbox">
                <input type="checkbox" id="sourcePartyInvitesToggle" checked />
                <span>Enable party invites display</span>
              </label>
              <label class="settings-checkbox">
                <input type="checkbox" id="partyRefreshServerChange" />
                <span>Auto-refresh on server change</span>
              </label>
              <label class="settings-checkbox">
                <input type="checkbox" id="partyRefreshGameEnd" />
                <span>Auto-refresh after game end</span>
              </label>
              <small style="display:block;color:var(--muted);margin-top:8px;font-size:11px;">Party options control how players with the party source are retained or removed.</small>
            </div>
          </div>

          <!-- Manual Section -->
          <div class="settings-subsection">
            <div style="display: flex; align-items: center; justify-content: space-between; margin: 20px 0 12px;">
              <h3 style="margin: 0; font-size: 16px; font-weight: 600;">Manual</h3>
              <label class="toggle-switch">
                <input type="checkbox" id="sourceManualToggle" checked />
                <span class="toggle-slider"></span>
              </label>
            </div>
            <div class="source-options" id="manualSourceOptions">
              <label class="settings-checkbox">
                <input type="checkbox" id="manualClearOnGameStart" />
                <span>Remove all manually added players when a game starts</span>
              </label>
              <small style="display:block;color:var(--muted);margin-top:8px;font-size:11px;">Manual source refers to players added via the search bar.</small>
            </div>
          </div>

          <!-- Chat Section -->
          <div class="settings-subsection">
            <div class="settings-group">
              <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                <h3 style="margin: 0; font-size: 16px; font-weight: 600;">Chat</h3>
                <label class="toggle-switch">
                  <input type="checkbox" id="sourceChatToggle" checked />
                  <span class="toggle-slider"></span>
                </label>
              </div>

              <div class="source-options" id="chatSourceOptions">
                <label class="settings-checkbox">
                  <input type="checkbox" id="chatRemoveOnServerChange" checked />
                  <span>Remove All on Server Change</span>
                </label>
                <label class="settings-checkbox">
                  <input type="checkbox" id="chatAddOnMention" checked />
                  <span>Players who mention your name are auto-added</span>
                </label>
                <div style="margin-top:12px;">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
                    <span style="width:24px;text-align:center"><svg class="icon" aria-hidden="true"><use href="#i-file"/></svg></span>
                    <label class="settings-label" style="margin:0;">Trigger Strings</label>
                    <button id="addChatString" type="button" style="margin-left:auto;background:var(--row);border:0;color:var(--text);padding:4px 10px;border-radius:6px;cursor:pointer;font-size:12px;">+ Add</button>
                  </div>
                  <div id="chatStringList" style="display:flex;flex-direction:column;gap:6px;"></div>
                  <small style="display:block;color:var(--muted);margin-top:6px;font-size:11px;">Players are added when their message contains any trigger (case-insensitive).</small>
                </div>
              </div>
            </div>
          </div>

          <!-- Guild Section -->
          <div class="settings-subsection">
            <div class="settings-group">
              <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                <h3 style="margin: 0; font-size: 16px; font-weight: 600;">Guild</h3>
                <label class="toggle-switch">
                  <input type="checkbox" id="sourceGuildToggle" checked />
                  <span class="toggle-slider"></span>
                </label>
              </div>

              <div class="source-options" id="guildSourceOptions">
                <label class="settings-checkbox">
                  <input type="checkbox" id="guildRemoveOnServerChange" checked />
                  <span>Remove All on Server Change</span>
                </label>
                <label class="settings-checkbox">
                  <input type="checkbox" id="guildOnlineOnly" checked />
                  <span>Show only online guild members</span>
                </label>
                <small style="display:block;color:var(--muted);margin-top:8px;font-size:11px;">Guild members are added when you use /guild list. Use this to quickly check guildmates' stats.</small>
              </div>
            </div>
          </div>
      </div>

  <!-- Appearance Settings Panel -->
  </div>

  <div class="panel" id="panel-appearance">
        <div class="settings-section">
          <h2>
            <span class="settings-icon"><svg class="icon" aria-hidden="true"><use href="#i-appearance"/></svg></span>
            Appearance Settings
          </h2>

          <!-- Opacity -->
          <div class="settings-row">
            <label class="settings-label">Opacity</label>
            <input id="opacityRange" type="range" min="0.2" max="1" step="0.01" style="flex:1" />
            <span id="opacityValue" style="width:48px;text-align:right;margin-left:10px"></span>
          </div>

          <!-- Players Table Font Size -->
          <div class="settings-row">
            <label class="settings-label">Players Table Font Size</label>
            <input id="fontSizeRange" type="range" min="10" max="18" step="1" style="flex:1" />
            <span id="fontSizeValue" style="width:48px;text-align:right;margin-left:10px"></span>
          </div>

          <!-- Always on top -->
          <div class="settings-row">
            <label class="settings-label">Always On Top</label>
            <label style="display:flex;align-items:center;gap:8px">
              <input id="alwaysOnTopToggle" type="checkbox" class="accent-checkbox" />
            </label>
          </div>

          <!-- Auto-resize overlay -->
          <div class="settings-row">
            <label class="settings-label">Auto-Resize Overlay</label>
            <label style="display:flex;align-items:center;gap:8px">
              <input id="autoResizeToggle" type="checkbox" class="accent-checkbox" />
            </label>
          </div>

          <!-- Background Color -->
          <div class="settings-row">
            <label class="settings-label">Background Color</label>
            <input id="bgColorInput" type="color" style="width:44px;height:32px;border:0;background:transparent;padding:0" />
          </div>
        </div>
      </div>

  <!-- Columns Settings Panel -->
  </div>

  <div class="panel" id="panel-columns">
        <div class="settings-section">
          <h2>
            <span class="settings-icon"><svg class="icon" aria-hidden="true"><use href="#i-stats"/></svg></span>
            Columns Settings
          </h2>
        
        <div class="layout-editor" id="statLayoutEditor">
          <div class="layout-help">Drag stats from the palette into slots below. Empty slots are not shown in the overlay. Level and Name are always fixed at the beginning. Click on a filled slot to configure color rules.</div>
          <div class="layout-palette" id="layoutPalette"></div>
          <div class="layout-slots" id="layoutSlots"></div>
          <button id="addSlotBtn" style="margin-top:12px;padding:8px 16px;background:var(--accent);border:0;color:#fff;border-radius:8px;cursor:pointer;font-size:13px;">+ Add Slot (max 12)</button>
        </div>
        </div>
      </div>

  <!-- Keyboard Shortcuts Settings Panel -->
  </div>

  <div class="panel" id="panel-keyboard">
        <div class="settings-section">
          <h2>
            <span class="settings-icon"><svg class="icon" aria-hidden="true"><use href="#i-shortcuts"/></svg></span>
            Keyboard Shortcuts
          </h2>
          <div class="kb-help" style="color: var(--muted); margin-bottom: 12px;">
            Click a field and press the desired key (F-keys or key with modifiers). Press <b>Escape</b> to clear (no shortcut).
            Shortcuts are global while Nebula is running.
          </div>
          <div class="kb-grid" id="kbGrid"></div>
        </div>
      </div>

      <!-- Profile Panel -->
      <div class="panel" id="panel-profile">
        <h2 style="margin:0 0 20px;font-size:18px;font-weight:600;display:flex;align-items:center;gap:8px">
          <span class="settings-icon">
            <svg class="icon" aria-hidden="true"><use href="#i-profile"/></svg>
          </span>
          Profile & Account
        </h2>

        <div class="profile-container">
          <!-- Account Card -->
          <div class="profile-card">
            <div class="profile-header">
              <div class="profile-avatar empty" id="profileAvatar">
                <!-- Avatar image will be inserted here -->
              </div>
              <div class="profile-info">
                <h3 class="profile-username" id="profileUsername">
                  Not logged in
                </h3>
                <div class="profile-status offline" id="profileStatus">
                  <span class="status-dot"></span>
                  <span>Local account only</span>
                </div>
              </div>
            </div>
            <div class="profile-actions">
              <button class="discord-btn" id="discordLoginBtn" style="display:flex">
                <svg class="icon" aria-hidden="true"><use href="#i-discord"/></svg>
                <span>Login with Discord</span>
              </button>
              <button class="logout-btn" id="logoutBtn" style="display:none">
                Logout
              </button>
            </div>
          </div>

          <!-- Minecraft IGN Card -->
          <div class="profile-card">
            <div class="profile-section">
              <h3 style="margin: 0 0 12px; font-size: 16px; font-weight: 600; display:flex; align-items:center; gap:8px;">
                <svg class="icon" aria-hidden="true"><use href="#i-profile"/></svg>
                Minecraft Ingame Name (IGN)
              </h3>
              <div class="settings-row" style="margin: 0;">
                <div style="flex: 1; display: flex; flex-direction: column; gap: 8px;">
                  <div style="display:flex;gap:8px;align-items:center;width:100%">
                    <input id="usernameInput" type="text" placeholder="Enter your Minecraft IGN..." class="settings-input" style="flex:1;padding: 12px 16px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: var(--text); font-size: 14px; box-sizing: border-box;"/>
                    <!-- <button id="usernameLockBtn" type="button" style="padding:11px 14px;border:0;border-radius:8px;background:transparent;color:var(--accent);font-size:20px;cursor:pointer;display:inline-flex;align-items:center;gap:6px" title="IGN bearbeiten">
                      <svg id="lockIcon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="opacity:0.7;transition:opacity 0.2s;"><path id="lockBody" d="M5 11h14a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2z"/><path id="lockShackle" d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
                    </button> -->
                  </div>
                  <small style="color:var(--muted);font-size:12px;line-height:1.4;">Used for chat mentions and automatic adding to the list. Changes sync with your Discord account when logged in.</small>
                </div>
              </div>
            </div>
          </div>

          <!-- Plus Card -->
          <div class="profile-card plus-card">
            <div class="profile-section">
              <h3>
                <svg class="icon" aria-hidden="true"><use href="#i-plus"/></svg>
                Plus Status
              </h3>
              <div class="plus-icon">✨</div>
              <div class="plus-status" id="plusStatus">
                <div id="plusStatusText" style="display:flex;flex-direction:column;gap:4px">
                  <span style="font-weight:600;font-size:14px">Free Plan</span>
                  <span style="font-size:12px;color:var(--muted)">Try Plus (Demo Mode)</span>
                </div>
                <button class="btn primary" id="upgradePlusBtn" style="padding:8px 16px;font-size:13px">
                  <svg class="icon" aria-hidden="true"><use href="#i-plus"/></svg>
                  <span>Try Demo</span>
                </button>
              </div>
              <div style="margin-top:16px;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px">
                <div style="font-size:12px;color:var(--muted);line-height:1.6">
                  <b style="color:var(--text)">Plus features:</b><br>
                  • Unlimited nickname entries<br>
                  • Advanced statistics & session history<br>
                  • Priority support & early features<br>
                  • Supporting Nebula development <3<br>
                  <b style="color:var(--accent)">Only €1.99/month</b>
                </div>
              </div>
            </div>
          </div>

          <!-- Cloud Sync Card -->
          <div class="profile-card">
            <div class="profile-section">
              <h3>
                <svg class="icon" aria-hidden="true"><use href="#i-cloud"/></svg>
                Cloud Sync
              </h3>
              <div class="sync-info" id="syncInfo">
                <div style="display:flex;flex-direction:column;gap:4px">
                  <span style="font-weight:600;font-size:14px" id="syncStatus">Not available</span>
                  <span class="sync-time" id="syncTime">Login with Discord to enable cloud sync</span>
                </div>
                <button class="btn" id="syncNowBtn" style="padding:8px 16px;font-size:13px;background:rgba(102,234,255,0.1);border:1px solid var(--accent);color:var(--accent)" disabled>
                  Sync Now
                </button>
              </div>
              <div style="margin-top:12px;padding:10px 12px;background:rgba(255,255,255,0.03);border-radius:8px;font-size:12px;color:var(--muted);line-height:1.5">
                Cloud sync automatically backs up your settings, nicks, and color rules. Changes sync across all your devices when logged in.
              </div>
            </div>
          </div>

          <!-- Auth Code Input Card (shown during login) -->
          <div class="profile-card" id="authCodeCard" style="display:none;border:2px solid var(--accent);background:linear-gradient(145deg,rgba(102,234,255,0.05),rgba(102,234,255,0.02))">
            <div class="profile-section">
              <h3 style="color:var(--accent)">
                <svg class="icon" aria-hidden="true"><use href="#i-discord"/></svg>
                Complete Discord Login
              </h3>
              <div style="padding:16px;background:rgba(0,0,0,0.3);border-radius:10px;margin-top:12px">
                <div style="font-size:14px;line-height:1.8;margin-bottom:16px">
                  <b style="color:var(--accent)">Steps:</b><br>
                  <div style="display:flex;align-items:center;margin-bottom:8px">
                    <svg class="icon" style="width:20px;height:20px;margin-right:8px" aria-hidden="true"><use href="#i-step-1"/></svg>
                    <span>Authorize Nebula in the browser tab that opened</span>
                  </div>
                  <div style="display:flex;align-items:center;margin-bottom:8px">
                    <svg class="icon" style="width:20px;height:20px;margin-right:8px" aria-hidden="true"><use href="#i-step-2"/></svg>
                    <span>After authorizing, copy the <b>complete URL</b> from the address bar</span>
                  </div>
                  <div style="display:flex;align-items:center">
                    <svg class="icon" style="width:20px;height:20px;margin-right:8px" aria-hidden="true"><use href="#i-step-3"/></svg>
                    <span>Paste it in the field below and click "Login"</span>
                  </div>
                </div>
                <div style="font-size:12px;color:var(--muted);margin-bottom:12px">
                  The URL should start with: <code style="background:rgba(0,0,0,0.4);padding:2px 6px;border-radius:4px;font-size:11px">http://localhost:3000/auth/discord/callback?code=...</code>
                </div>
                <input 
                  type="text" 
                  id="authCodeInput" 
                  placeholder="Paste the complete redirect URL here..."
                  style="width:100%;padding:12px;background:rgba(0,0,0,0.4);border:2px solid rgba(102,234,255,0.3);border-radius:8px;color:var(--text);font-size:13px;margin-bottom:12px;font-family:monospace"
                />
                <div style="display:flex;gap:10px">
                  <button id="submitAuthCode" class="btn primary" style="flex:1;padding:12px;font-weight:600">
                    <svg class="icon" style="width:16px;height:16px" aria-hidden="true"><use href="#i-discord"/></svg>
                    Complete Login
                  </button>
                  <button id="cancelAuthCode" class="btn" style="padding:12px 20px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1)">
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Account Stats -->
          <div class="profile-card" id="accountStatsCard" style="display:none">
            <div class="profile-section">
              <h3>Account Statistics</h3>
              <div class="profile-stat-grid">
                <div class="profile-stat">
                  <span class="profile-stat-label">Member Since</span>
                  <span class="profile-stat-value" id="memberSince">—</span>
                </div>
                <div class="profile-stat">
                  <span class="profile-stat-label">Players Tracked</span>
                  <span class="profile-stat-value" id="playersTracked">0</span>
                </div>
                <div class="profile-stat">
                  <span class="profile-stat-label">Sessions</span>
                  <span class="profile-stat-value" id="sessionsCount">0</span>
                </div>
                <div class="profile-stat">
                  <span class="profile-stat-label">Total Lookups</span>
                  <span class="profile-stat-value" id="totalLookups">0</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Color Rules Modal -->
      <div class="modal" id="colorRulesModal">
        <div class="modal-content">
          <div class="modal-header">
            <h3>Color Rules: <span id="colorRuleTitle"></span></h3>
            <button class="modal-close">×</button>
          </div>
          <div class="modal-body">
            <div class="color-rules" id="colorRulesList">
              <!-- Regeln werden per JS eingefügt -->
            </div>
            <div style="display: flex; gap: 8px;">
              <button class="add-rule-btn" style="flex: 1;">+ Add Rule</button>
              <button class="reset-rules-btn" id="resetRulesBtn" style="background: rgba(255,255,255,0.04); border: 1px dashed rgba(255,255,255,0.15); color: var(--muted); padding: 12px 16px; border-radius: 12px; cursor: pointer; font-weight: 500; letter-spacing: 0.5px;">Reset to Default</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Notification Modal (for alerts) -->
      <div class="modal notification-modal" id="notificationModal">
        <div class="modal-content">
          <div class="modal-body">
            <p class="message" id="notificationMessage"></p>
            <button class="ok-btn" id="notificationOkBtn">OK</button>
          </div>
        </div>
      </div>
    </div>

  <!-- invisible grips -->
  <div class="grip g-top" data-edge="top"></div>
  <div class="grip g-bottom" data-edge="bottom"></div>
  <div class="grip g-left" data-edge="left"></div>
  <div class="grip g-right" data-edge="right"></div>
  <div class="grip g-tl" data-edge="top-left"></div>
  <div class="grip g-tr" data-edge="top-right"></div>
  <div class="grip g-bl" data-edge="bottom-left"></div>
  <div class="grip g-br" data-edge="bottom-right"></div>

  <script>
    console.log('NEBULA LOADED - Version:', new Date().toISOString());
    
  const { ipcRenderer } = require("electron");
  // Expose ipcRenderer globally for existing code paths that use window.ipcRenderer
  try { window.ipcRenderer = ipcRenderer; } catch (_) { /* noop */ }
    const rows = document.getElementById("rows");
    const input = document.getElementById("playerInput");
    let queue = [];

    // Session tracking variables
    let startStats = null;        // Stats when session started
    let startTime = new Date();   // Session start time
    let sessionUsername = null;   // Current session username
    let sessionUpdateInterval = null; // Interval for updating session
    let sessionUuid = null;       // UUID für Avatar

    // Account Metrics Tracking
    let accountMetrics = JSON.parse(localStorage.getItem('accountMetrics') || JSON.stringify({
      memberSince: Date.now(),
      players: [],  // stored as array, converted to Set in memory
      sessionsCount: 0,
      totalLookups: 0
    }));
    
    // Convert stored array to Set for players
    accountMetrics.players = new Set(accountMetrics.players || []);

    function saveAccountMetrics() {
      const toStore = {
        ...accountMetrics,
        players: Array.from(accountMetrics.players) // Set -> Array for JSON
      };
      localStorage.setItem('accountMetrics', JSON.stringify(toStore));
      console.log('[Metrics] Local data saved:', toStore);
    }

    function trackStatsLookup(playerName) {
      if (!playerName) return;
      
      const normalizedName = playerName.toLowerCase().trim();
      const wasNew = !accountMetrics.players.has(normalizedName);
      
      accountMetrics.players.add(normalizedName);
      accountMetrics.totalLookups++;
      
      saveAccountMetrics();
      
      if (wasNew) {
        console.log('[Metrics] New player tracked:', playerName, '- Total:', accountMetrics.players.size);
      }
    }

    function trackSessionStart() {
      accountMetrics.sessionsCount++;
      saveAccountMetrics();
      console.log('[Metrics] Session started - Total:', accountMetrics.sessionsCount);
    }

    // Auto-resize overlay logic (defined early so it can be called anywhere)
  const TOPBAR_HEIGHT = 50; // fallback topbar height (will be measured dynamically)
    const MIN_HEIGHT = 120; // minimum window height for empty overlay
    const DEFAULT_HEIGHT = 560; // default full height
    let resizeTimeout = null;

    function updateOverlaySize() {
      if (resizeTimeout) clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const activePanel = document.querySelector('.panel.active');
        const panelOverlay = document.getElementById('panel-overlay');
        const sidebar = document.getElementById('sidebar');

        // Get appearance settings safely
        const appearanceSettings = JSON.parse(localStorage.getItem('appearanceSettings') || '{}');

        // Only auto-resize if:
        // 1. Feature is enabled
        // 2. Overlay panel is active
        // 3. Sidebar is closed
        const allowAuto = appearanceSettings.autoResize !== false; // default true
        if (sidebar?.classList.contains('open')) {
          // Sidebar offen: auf Default-Höhe gehen (volle Ansicht)
            ipcRenderer.invoke('window:setBounds', { height: DEFAULT_HEIGHT });
            return;
        }
        if (!allowAuto || !activePanel || activePanel !== panelOverlay) {
          const table = document.getElementById('table');
          const rc = table?.querySelectorAll('tbody tr').length || 0;
          if (rc === 0) ipcRenderer.invoke('window:setBounds', { height: MIN_HEIGHT });
          return;
        }

        // Calculate table content height
        const table = document.getElementById('table');
        const rowCount = table?.querySelectorAll('tbody tr').length || 0;
        
        if (rowCount === 0) {
          // No players: minimal overlay
          ipcRenderer.invoke('window:setBounds', { height: MIN_HEIGHT });
          return;
        }

        // Calculate needed height: topbar + thead + rows + padding
        const theadHeight = table?.querySelector('thead')?.offsetHeight || 40;
        
        // Get actual row height from first row, or estimate based on font size
        let rowHeight = 24; // base minimum
        const firstRow = table?.querySelector('tbody tr');
        if (firstRow) {
          rowHeight = firstRow.offsetHeight;
        } else {
          // Estimate: font size + padding (4px top + 4px bottom) + line-height
          const fontSize = appearanceSettings.fontSize || 14;
          rowHeight = Math.ceil(fontSize * 1.4) + 8; // line-height 1.4 + 8px padding
        }
        
  const padding = 8; // minimal breathing room

  // Dynamic measurements
  const topbarEl = document.querySelector('.topbar');
  const topbarHeight = topbarEl?.offsetHeight || TOPBAR_HEIGHT;
  const contentEl = document.querySelector('.content');
  const wrapEl = document.querySelector('.table-wrap');
  const contentPadTop = contentEl ? parseInt(getComputedStyle(contentEl).paddingTop) || 0 : 0;
  const wrapPadTop = wrapEl ? parseInt(getComputedStyle(wrapEl).paddingTop) || 0 : 0;

  // Total needed height: topbar + content top padding + table-wrap top padding + header + rows + padding
  const extra = 12; // small extra slack below table
  const neededHeight = topbarHeight + contentPadTop + wrapPadTop + theadHeight + (rowCount * rowHeight) + padding + extra;
  
  // Set a reasonable maximum based on screen height (80% of screen height or at least 800px)
  const screenHeight = window.screen.availHeight;
  const maxHeight = Math.max(800, Math.floor(screenHeight * 0.8));
  const finalHeight = Math.min(neededHeight, maxHeight);

        ipcRenderer.invoke('window:setBounds', { height: finalHeight });

        // Auto-adjust width based on number of columns
        const dynamicStats = statSettings.layout.filter(k => k && statSettings.visible.includes(k));
        const totalCols = 2 + dynamicStats.length + 1; // lvl + name + stats + actions
        const baseWidth = 280; // minimum for lvl+name+actions
        const colWidth = 80; // average width per stat column
        const calculatedWidth = baseWidth + (dynamicStats.length * colWidth);
        const finalWidth = Math.max(calculatedWidth, 400); // minimum 400px
        ipcRenderer.invoke('window:setBounds', { width: finalWidth });
      }, 100); // debounce
    }

  // Track currently displayed players and their sources
  // displayedPlayers: set of normalized names (lowercase of displayed name)

  const displayedPlayers = new Set();
  const nickedPlayers = new Set(); // tracks players originally added via nick
  // playerSources: map normalized name -> set of sources ('username'|'manual'|'party'|'who'|'chat'|'invite'|'guild')
  const playerSources = new Map();
  // Track invite timeouts: map normalized name -> timeout ID
  const inviteTimeouts = new Map();
  // Cache for all loaded player objects (keyed by normalized name)
  let playerCache = {};
  // Tracks whether a registered nick is CURRENTLY active (i.e. we saw the nick-form in /who or chat)
  // key: realName(lower) -> boolean
  const activeNickState = {};
  console.log('displayedPlayers initialized:', displayedPlayers);
  const originalNicks = {}; // realName(lower) -> originally eingegebener Nick
  let nickDisplayMode = localStorage.getItem('nickDisplayMode') || 'nick';
  // Pinned players cannot be removed by any automatic source removal
  let pinnedPlayers = new Set(JSON.parse(localStorage.getItem('pinnedPlayers') || '[]').map(s => String(s).toLowerCase()));
  function savePinned() { localStorage.setItem('pinnedPlayers', JSON.stringify(Array.from(pinnedPlayers))); }
  // Track whether we are in the pre-game lobby phase (after "Sending you to..." and before game start)
  let preGameLobby = false;
  // Track whether we are currently in an active game (after gameStart until next server change / lobby join)
  let gameInProgress = false;
  let guildListMode = false; // Tracks if we're currently parsing guild list output
  let guildBatchAccepted = false; // Only add members if guild was enabled when the list started

  // Nick management (moved earlier to ensure availability before initial renders)
  let nicks = JSON.parse(localStorage.getItem('nicks') || '[]');
  function saveNicks() { localStorage.setItem('nicks', JSON.stringify(nicks)); }
  function getRealName(name) {
    const nick = nicks.find(n => n.nick.toLowerCase() === String(name).toLowerCase());
    return nick ? nick.real : name;
  }
  function getNickFromReal(realName) {
    const entry = nicks.find(n => n.real.toLowerCase() === String(realName).toLowerCase());
    return entry ? entry.nick : undefined;
  }
  function isNick(name) { return nicks.some(n => n.nick.toLowerCase() === String(name).toLowerCase()); }

  // Session Stats Functions
  function normalizeBedwarsStats(player) {
    if (!player || typeof player !== 'object') return {
      name: '', level: 0, ws: 0,
      fk: 0, fd: 0, fkdr: 0,
      wins: 0, losses: 0, wlr: 0,
      bb: 0, bl: 0, bblr: 0,
      uuid: null
    };

    // Level / Stars
    const level = (typeof player.level === 'number')
      ? player.level
      : (player.stats?.Bedwars?.Experience != null
          ? getBedWarsLevel(Number(player.stats.Bedwars.Experience))
          : 0);

    // Raw values with multiple fallbacks
    const fk = Number(
      player.fk ??
      player.finalKills ??
      player.stats?.Bedwars?.final_kills_bedwars ?? 0
    );
    const fd = Number(
      player.fd ??
      player.finalDeaths ??
      player.stats?.Bedwars?.final_deaths_bedwars ?? 0
    );
    const wins = Number(
      player.wins ??
      player.stats?.Bedwars?.wins_bedwars ?? 0
    );
    const losses = Number(
      player.losses ??
      player.stats?.Bedwars?.losses_bedwars ?? 0
    );
    const bb = Number(
      player.bb ??
      player.bedsBroken ??
      player.stats?.Bedwars?.beds_broken_bedwars ?? 0
    );
    const bl = Number(
      player.bl ??
      player.bedsLost ??
      player.stats?.Bedwars?.beds_lost_bedwars ?? 0
    );
    const ws = Number(
      player.ws ??
      player.winstreak ??
      player.stats?.Bedwars?.winstreak ?? 0
    );

    // Derived ratios (avoid division by zero)
    const fkdr = fd > 0 ? fk / fd : fk > 0 ? fk : 0;
    const wlr = losses > 0 ? wins / losses : wins > 0 ? wins : 0;
    const bblr = bl > 0 ? bb / bl : bb > 0 ? bb : 0;

    const uuid = (player.uuid || player.id || null);
    return { name: player.name || player.username || player.displayName || '', level, ws, fk, fd, fkdr, wins, losses, wlr, bb, bl, bblr, uuid };
  }

  async function fetchMojangUuid(name) {
    if (!name) return null;
    try {
      const res = await fetch(`https://api.mojang.com/users/profiles/minecraft/${encodeURIComponent(name)}`);
      if (!res.ok) return null;
      const data = await res.json();
      return (data && data.id) ? data.id : null; // already ohne Bindestriche
    } catch { return null; }
  }

  async function startSession(username) {
    if (!username || username.trim() === '') {
      console.log('Cannot start session: no username provided');
      return;
    }
    
    // Wait for IPC to be available
    if (!window.ipcRenderer) {
      console.log('IPC not ready yet, waiting...');
      setTimeout(() => startSession(username), 500);
      return;
    }
    
    console.log('Starting session for:', username);
    sessionUsername = username;
    startTime = new Date();
    
    // Show loading state
    const sessionStats = document.getElementById('sessionStats');
    if (sessionStats) {
      sessionStats.innerHTML = `
        <div style="text-align:center;color:var(--muted);padding:40px 20px;">
          <svg class="icon" aria-hidden="true" style="width:48px;height:48px;margin-bottom:12px;opacity:0.5;animation:spin 2s linear infinite;"><use href="#i-session"/></svg>
          <div style="font-size:16px;margin-bottom:8px;color:var(--text);">Loading Session Stats</div>
          <div style="font-size:13px;">Fetching current stats for ${username}...</div>
        </div>
        <style>
          @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        </style>
      `;
    }
    
    try {
      // First check API status
      const apiStatus = await window.ipcRenderer.invoke('api:getStatus');
      console.log('API Status:', apiStatus);
      
  const rawResult = await window.ipcRenderer.invoke('bedwars:stats', username);
      console.log('Session API raw result:', rawResult);
      const normalized = normalizeBedwarsStats(rawResult);
      console.log('Session API normalized result:', normalized);
      
      if (rawResult && !rawResult.error && (rawResult.name || normalized.name)) {
        startStats = normalized; // store normalized for diff calculations
        sessionUuid = normalized.uuid || rawResult.uuid || null;
        if (usernameInput) {
          // Initial value from settings (or from normalized stats if you prefer)
          usernameInput.value = (basicSettings.username || '').trim();

          const applyUsernameChange = () => {
            const prev = (basicSettings.username || '').trim();
            const next = (usernameInput.value || '').trim();

            if (prev === next) return;

            // Remove old player source if needed
            if (prev) {
              removePlayerSource(prev, 'username');
            }

            basicSettings.username = next;
            localStorage.setItem('username', next);
            updateSidebarUsername();

            // Use the preload bridge instead of require('electron')
            try {
              if (window.ipcRenderer) {
                window.ipcRenderer.send('set:username', basicSettings.username || '');
              } else if (window.electronAPI && window.electronAPI.setUsername) {
                window.electronAPI.setUsername(basicSettings.username || '');
              }
            } catch (e) {
              console.error('Failed to send username IPC update:', e);
            }

            // Restart session if IGN changed
            if (next && next !== sessionUsername) {
              startSession(next);
            }
          };

          // Trigger on blur (user leaves the field)
          usernameInput.addEventListener('blur', applyUsernameChange);

          // Optional: also trigger on Enter key
          usernameInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
              applyUsernameChange();
              usernameInput.blur();
            }
          });

          // Start session on app load if username exists (delayed)
          const savedUsername = basicSettings.username || '';
          if (savedUsername) {
            console.log('Found saved username on app load:', savedUsername);
            localStorage.setItem('username', savedUsername);
            setTimeout(() => {
              if (!sessionUsername) {
                console.log('Starting session on app load for:', savedUsername);
                startSession(savedUsername);
              }
            }, 400);
          }
        }
        // Create detailed error message with API status
        let detailedError = `
          <div style="text-align:center;color:#ef4444;padding:40px 20px;">
            <svg class="icon" aria-hidden="true" style="width:48px;height:48px;margin-bottom:12px;opacity:0.5;"><use href="#i-session"/></svg>
            <div style="font-size:16px;margin-bottom:8px;">Session Start Failed</div>
            <div style="font-size:13px;line-height:1.5;margin-bottom:12px;">
              ${errorMsg}
            </div>
        `;
        
        // Add API status information if available
        if (apiStatus) {
          detailedError += `
            <div style="font-size:11px;color:var(--muted);text-align:left;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;margin:16px 0;">
              <strong>API Status:</strong><br>
              Backend: ${apiStatus.backendAvailable ? '🟢 Available' : '🔴 Down'}<br>
              User Key: ${apiStatus.config.hasUserKey ? '🟢 Set' : '🔴 Not Set'}<br>
              Enhanced System: ${apiStatus.config.useEnhanced ? 'Enabled' : 'Disabled'}
            </div>
          `;
        }
        
        detailedError += `
            <div style="font-size:13px;line-height:1.5;">
              <strong>What Session Stats Do:</strong><br>
              • Track your progress since app start<br>
              • Show stat changes (wins, kills, etc.)<br>
              • Update automatically while playing
            </div>
          </div>
        `;
        
        // Show specific error message
        if (sessionStats) {
          sessionStats.innerHTML = detailedError;
        }
      }
    } catch (error) {
  console.error('Failed to start session (exception):', error);
      
      // Show network error with API diagnostics
      if (sessionStats) {
        sessionStats.innerHTML = `
          <div style="text-align:center;color:#ef4444;padding:40px 20px;">
            <svg class="icon" aria-hidden="true" style="width:48px;height:48px;margin-bottom:12px;opacity:0.5;"><use href="#i-session"/></svg>
            <div style="font-size:16px;margin-bottom:8px;">Connection Error</div>
            <div style="font-size:13px;line-height:1.5;margin-bottom:12px;">
              Could not connect to Hypixel API.
            </div>
            <div style="font-size:11px;color:var(--muted);text-align:left;padding:12px;background:rgba(0,0,0,0.2);border-radius:8px;margin:16px 0;">
              <strong>Error Details:</strong><br>
              ${error.message || error}<br><br>
              <strong>Current API Setup:</strong><br>
              Enhanced API System: Active<br>
              .env HYPIXEL_KEY: ${process?.env?.HYPIXEL_KEY ? 'Set' : 'Missing'}<br>
              User API Key: Check Client Settings
            </div>
            <div style="font-size:13px;line-height:1.5;">
              You can configure API keys in <strong>Client Settings</strong>.<br>
              Try using your own API key if the backend is down.
            </div>
          </div>
        `;
      }
    }
  }

  async function updateSession() {
    if (!startStats || !sessionUsername) return;
    
    // Wait for IPC to be available
    if (!window.ipcRenderer) {
      console.log('IPC not ready for session update, skipping...');
      return;
    }
    
    console.log('Updating session for:', sessionUsername);
    
    try {
      const rawCurrent = await window.ipcRenderer.invoke('bedwars:stats', sessionUsername);
      console.log('Session update raw result:', rawCurrent);
      const currentNormalized = normalizeBedwarsStats(rawCurrent);
      console.log('Session update normalized:', currentNormalized);
      
      if (rawCurrent && !rawCurrent.error) {
        generateSessionHTML(startStats, currentNormalized);
      } else {
        console.error('Session update error:', rawCurrent?.error);
      }
    } catch (error) {
      console.error('Failed to update session:', error);
    }
  }

  function updateSessionDisplay() {
    const sessionIgn = document.getElementById('sessionIgn');
    const sessionTime = document.getElementById('sessionTime');
    const sessionAvatar = document.getElementById('sessionAvatar');
    
    if (sessionUsername) {
      sessionIgn.textContent = sessionUsername;
      console.log(sessionUuid);
      if (sessionUuid) {
        sessionAvatar.src = `https://crafatar.com/avatars/${sessionUuid}?size=48&default=MHF_Steve&overlay`;
      } else {
  // Username fallback: load Mojang UUID asynchronously; until then use Steve placeholder skin
  sessionAvatar.src = `https://crafatar.com/avatars/8667ba71b85a4004af54457a9734eed7?size=48&default=MHF_Steve&overlay`; // Steve placeholder
      }
      updateSessionTime();
    }
  }

  function updateSessionTime() {
    const sessionTime = document.getElementById('sessionTime');
    if (!sessionTime || !startTime) return;
    
    const secsElapsed = Math.floor((new Date() - startTime) / 1000);
    const minsElapsed = Math.floor(secsElapsed / 60);
    const hoursElapsed = Math.floor(minsElapsed / 60);
    
    let timeText = 'Session: ';
    if (hoursElapsed > 0) {
      timeText += `${hoursElapsed}h ${minsElapsed % 60}m`;
    } else {
      timeText += `${minsElapsed}m`;
    }
    
    sessionTime.textContent = timeText;
  }

  function sessionStatHTML(startVal, currentVal, isNegativeStat = false) {
    if (startVal === undefined || currentVal === undefined) {
      return '<span style="color: #ef4444;">?</span>';
    }
    
    const diff = currentVal - startVal;
    const diffDisplay = Math.abs(diff) < 0.001 ? diff.toFixed(3) : diff.toLocaleString();
    
    let diffClass = 'neutral';
    if (diff > 0) {
      diffClass = isNegativeStat ? 'negative' : 'positive';
    } else if (diff < 0) {
      diffClass = isNegativeStat ? 'positive' : 'negative';
    }
    
    return `
      <div class="session-stat-value">
        <span class="session-stat-start">${startVal.toLocaleString()}</span>
        <span class="session-stat-arrow">→</span>
        <span class="session-stat-current">${currentVal.toLocaleString()}</span>
        <span class="session-stat-diff ${diffClass}">[${diff > 0 ? '+' : ''}${diffDisplay}]</span>
      </div>
    `;
  }

  function generateSessionHTML(startPlayer, currentPlayer) {
    const sessionStats = document.getElementById('sessionStats');
    const sessionTitle = document.getElementById('sessionTitle');
    
    sessionTitle.textContent = 'Bedwars Session Stats';
    
    console.log('Generating session HTML:', { startPlayer, currentPlayer });
    
    let html = '';
    
    // Helper function to safely get stat value
    function getStat(player, statName) {
      if (!player) return 0;
      if (typeof player[statName] === 'number') return player[statName];
      return 0;
    }
    
    // Level/Stars - Use the same logic as main table
    const startLevel = startPlayer?.level ?? (startPlayer?.stats?.Bedwars?.Experience != null ? getBedWarsLevel(Number(startPlayer.stats.Bedwars.Experience)) : 0);
    const currentLevel = currentPlayer?.level ?? (currentPlayer?.stats?.Bedwars?.Experience != null ? getBedWarsLevel(Number(currentPlayer.stats.Bedwars.Experience)) : 0);
    
    html += `
      <div class="session-category">
        <div class="session-category-title">
          <svg class="icon" aria-hidden="true"><use href="#i-stats"/></svg>
          General
        </div>
        <div class="session-stat-row">
          <span class="session-stat-label">Stars</span>
          ${sessionStatHTML(startLevel, currentLevel)}
        </div>
        <div class="session-stat-row">
          <span class="session-stat-label">Win Streak</span>
          ${sessionStatHTML(getStat(startPlayer, 'ws'), getStat(currentPlayer, 'ws'))}
        </div>
      </div>
    `;
    
    // Combat Stats
    html += `
      <div class="session-category">
        <div class="session-category-title">
          <svg class="icon" aria-hidden="true"><use href="#i-target"/></svg>
          Combat
        </div>
        <div class="session-stat-row">
          <span class="session-stat-label">Final Kills</span>
          ${sessionStatHTML(getStat(startPlayer, 'fk'), getStat(currentPlayer, 'fk'))}
        </div>
        <div class="session-stat-row">
          <span class="session-stat-label">Final Deaths</span>
          ${sessionStatHTML(getStat(startPlayer, 'fd'), getStat(currentPlayer, 'fd'), true)}
        </div>
        <div class="session-stat-row">
          <span class="session-stat-label">FKDR</span>
          ${sessionStatHTML(getStat(startPlayer, 'fkdr'), getStat(currentPlayer, 'fkdr'))}
        </div>
      </div>
    `;
    
    // Game Stats  
    html += `
      <div class="session-category">
        <div class="session-category-title">
          <svg class="icon" aria-hidden="true"><use href="#i-check"/></svg>
          Games
        </div>
        <div class="session-stat-row">
          <span class="session-stat-label">Wins</span>
          ${sessionStatHTML(getStat(startPlayer, 'wins'), getStat(currentPlayer, 'wins'))}
        </div>
        <div class="session-stat-row">
          <span class="session-stat-label">Losses</span>
          ${sessionStatHTML(getStat(startPlayer, 'losses'), getStat(currentPlayer, 'losses'), true)}
        </div>
        <div class="session-stat-row">
          <span class="session-stat-label">WLR</span>
          ${sessionStatHTML(getStat(startPlayer, 'wlr'), getStat(currentPlayer, 'wlr'))}
        </div>
      </div>
    `;
    
    // Bed Stats
    html += `
      <div class="session-category">
        <div class="session-category-title">
          <svg class="icon" aria-hidden="true"><use href="#i-overlay"/></svg>
          Beds
        </div>
        <div class="session-stat-row">
          <span class="session-stat-label">Beds Broken</span>
          ${sessionStatHTML(getStat(startPlayer, 'bb'), getStat(currentPlayer, 'bb'))}
        </div>
        <div class="session-stat-row">
          <span class="session-stat-label">Beds Lost</span>
          ${sessionStatHTML(getStat(startPlayer, 'bl'), getStat(currentPlayer, 'bl'), true)}
        </div>
        <div class="session-stat-row">
          <span class="session-stat-label">BBLR</span>
          ${sessionStatHTML(getStat(startPlayer, 'bblr'), getStat(currentPlayer, 'bblr'))}
        </div>
      </div>
    `;
    
    sessionStats.innerHTML = html;
    updateSessionTime();
  }

  // Column definitions (labeling + optional derived calculators)
  const STATS = {
    // Core
    level: { name: 'Level', short: 'Lvl', type: 'number' }, // No colorRules - uses prestige coloring
    ws: { name: 'Win Streak', short: 'WS', type: 'number', colorRules: true },
    mode: { name: 'Most Played Mode', short: 'Mode', type: 'text' },
    fkdr: { name: 'Final K/D Ratio', short: 'FKDR', type: 'number', colorRules: true },
    wlr: { name: 'Win/Loss Ratio', short: 'WLR', type: 'number', colorRules: true },
    bblr: { name: 'Bed Break/Loss Ratio', short: 'BBLR', type: 'number', colorRules: true },
    fk: { name: 'Final Kills', short: 'F. Kills', type: 'number', colorRules: true },
    fd: { name: 'Final Deaths', short: 'F. Deaths', type: 'number', colorRules: true },
    wins: { name: 'Wins', short: 'Wins', type: 'number', colorRules: true },
    losses: { name: 'Losses', short: 'Losses', type: 'number', colorRules: true },
    bedsBroken: { name: 'Beds Broken', short: 'Beds', type: 'number', colorRules: true },
    bedsLost: { name: 'Beds Lost', short: 'Beds L.', type: 'number', colorRules: true },
    kills: { name: 'Kills', short: 'Kills', type: 'number', colorRules: true },
    deaths: { name: 'Deaths', short: 'Deaths', type: 'number', colorRules: true },

    // Derived
    winsPerLevel: { name: 'Wins per Level', short: 'Wins/Level', type: 'number', colorRules: true, calc: (p) => {
      const lvl = (p && (typeof p.level === 'number' ? p.level : (p.stats?.Bedwars?.Experience != null ? Math.floor(getBedWarsLevel(Number(p.stats.Bedwars.Experience))) : 0))) || 0;
      const wins = Number(p?.wins ?? 0);
      return lvl > 0 ? wins / lvl : 0;
    }},
    fkPerLevel: { name: 'Final Kills per Level', short: 'FK/Level', type: 'number', colorRules: true, calc: (p) => {
      const lvl = (p && (typeof p.level === 'number' ? p.level : (p.stats?.Bedwars?.Experience != null ? Math.floor(getBedWarsLevel(Number(p.stats.Bedwars.Experience))) : 0))) || 0;
      const fk = Number(p?.fk ?? 0);
      return lvl > 0 ? fk / lvl : 0;
    }},
    bedwarsScore: { name: 'Bedwars Score', short: 'Score', type: 'number', colorRules: true, calc: (p) => {
      // Konsistente Formel mit Backend (multiplikativ): fkdr * wlr * (level / 100)
      // Fallback: wenn level fehlt -> aus Experience berechnen
      let level = Number(p?.level ?? 0);
      if ((!level || !Number.isFinite(level)) && p?.experience != null) {
        try { level = Math.floor(getBedWarsLevel(Number(p.experience))); } catch {}
      }
      const fkdr = Number(p?.fkdr ?? 0);
      const wlr = Number(p?.wlr ?? 0);
      if (!Number.isFinite(fkdr) || !Number.isFinite(wlr) || !Number.isFinite(level)) return 0;
      const score = fkdr * wlr * (level / 100);
      return Number.isFinite(score) ? +score.toFixed(2) : 0;
    }},

    // Monthly (if provided by backend)
  mfkdr: { name: 'Monthly Final K/D Ratio', short: 'Monthly FKDR', type: 'number', colorRules: true, disabled: true },
  mwlr: { name: 'Monthly Win/Loss Ratio', short: 'Monthly WLR', type: 'number', colorRules: true, disabled: true },
  mbblr: { name: 'Monthly Bed Break/Loss Ratio', short: 'Monthly BBLR', type: 'number', colorRules: true, disabled: true },

    // Meta
    guildName: { name: 'Guild Name', short: 'Guild', type: 'text' },
    guildTag: { name: 'Guild Tag', short: 'Tag', type: 'text' },
  };

  // Sorting state
  let sortKey = null; // keys from STATS, e.g. 'level' | 'ws' | 'fkdr' | 'wlr' | 'bblr' | 'fk' | 'wins' | 'bedwarsScore' | ...
  let sortDir = 'asc'; // 'asc' | 'desc'
  // Restore persisted sort if exists
  try {
    const sk = localStorage.getItem('sortKey');
    const sd = localStorage.getItem('sortDir');
    if (sk) sortKey = (sk === 'score' ? 'bedwarsScore' : sk);
    if (sd === 'asc' || sd === 'desc') sortDir = sd;
  } catch {}

  function getNumeric(value) {
    const n = Number(value);
    return Number.isFinite(n) ? n : NaN;
  }

  // Apply color rules to stat values
  function getColorForValue(column, value) {
    const rules = statSettings.colorRules[column];
    if (!rules || !Array.isArray(rules)) return '';
    
    // Ensure value is numeric
    const numValue = typeof value === 'number' ? value : Number(value);
    if (!Number.isFinite(numValue)) return '';

    for (const rule of rules) {
      if (rule.op === '>=' && numValue >= rule.value) {
        return `style="color:${rule.color}"`;
      }
      if (rule.op === '<' && numValue < rule.value) {
        return `style="color:${rule.color}"`;
      }
    }
    return '';
  }

  function getSortValue(player, key) {
    switch (key) {
      case 'level': {
        if (player?.level != null) return getNumeric(player.level);
        const exp = player?.stats?.Bedwars?.Experience ?? player?.experience;
        return exp != null ? Math.floor(getBedWarsLevel(Number(exp))) : 0;
      }
      case 'networkLevel': return getNumeric(player?.networkLevel ?? 0);
      case 'ws': return getNumeric(player?.ws ?? 0);
      case 'fkdr': return getNumeric(player?.fkdr ?? 0);
      case 'wlr': return getNumeric(player?.wlr ?? 0);
      case 'bblr': return getNumeric(player?.bblr ?? 0);
      case 'fk': return getNumeric(player?.fk ?? 0);
      case 'fd': return getNumeric(player?.fd ?? 0);
      case 'wins': return getNumeric(player?.wins ?? 0);
      case 'losses': return getNumeric(player?.losses ?? 0);
      case 'bedsBroken': return getNumeric(player?.bedsBroken ?? 0);
      case 'bedsLost': return getNumeric(player?.bedsLost ?? 0);
      case 'kills': return getNumeric(player?.kills ?? 0);
      case 'deaths': return getNumeric(player?.deaths ?? 0);
      case 'winsPerLevel': return getNumeric(STATS.winsPerLevel.calc(player));
      case 'fkPerLevel': return getNumeric(STATS.fkPerLevel.calc(player));
  case 'score': // legacy alias
  case 'bedwarsScore': {
        const v = (player && typeof player.bedwarsScore === 'number') ? player.bedwarsScore : STATS.bedwarsScore.calc(player);
        return getNumeric(v);
      }
      case 'mfkdr': return getNumeric(player?.mfkdr ?? NaN);
      case 'mwlr': return getNumeric(player?.mwlr ?? NaN);
      case 'mbblr': return getNumeric(player?.mbblr ?? NaN);
      default: return 0;
    }
  }

  // Insert row for this player (used by both fetchPlayerStats and renderTable)
  function renderPlayerRow(player, wasNick, dynamicStats) {
    console.log('[DEBUG] renderPlayerRow', player?.name, player);
    const levelHTML = updatePlayerLevel(player);
  const realName = player.name;
  // Player might not have loaded (error placeholder) -> mark as nick
  const isUnresolved = player.error || player.unresolved;
  const key = realName.toLowerCase();
  const sources = playerSources.get(key);
  const isPartyMember = sources && sources.has('party');
  const lowerReal = realName.toLowerCase();
  const originalNick = originalNicks[lowerReal] || getNickFromReal(realName);
  const hasNick = !!originalNick;
  // Only show nickname if (a) mode is nick AND (b) we determined the player is actually nicked right now
  const isActiveNick = !!activeNickState[lowerReal];
  const showNick = hasNick && nickDisplayMode === 'nick' && isActiveNick;
    const displayName = showNick ? originalNick : realName;
    const tooltipOther = hasNick ? (showNick ? realName : originalNick) : '';
    const selectedStats = dynamicStats || statSettings.layout.filter(k => k && statSettings.visible.includes(k));
    const dynamicCells = selectedStats.map(key => {
      if (key === 'level' || key === 'name') return '';
      let val = player[key];
      // Support calc functions for derived stats if backend didn't send field
      const statDef = STATS[key];
      if ((val == null || (typeof val === 'number' && isNaN(val))) && statDef && typeof statDef.calc === 'function') {
        try { val = statDef.calc(player); } catch { val = null; }
      }
      const colorStyle = getColorForValue(key, typeof val === 'number' ? val : Number(val));
      return `<td class="metric" ${colorStyle}>${fmt(val)}</td>`;
    }).join('');
    const orderedCells = [
      `<td class="lvl">${levelHTML}</td>`,
      `<td class="name">
        ${(() => {
          if (showNick || isUnresolved) return `<span class="rank-tag" style="color:#ffffff">[NICK]</span>`;
          return player.rankTag ? `<span class="rank-tag" style="color:${player.rankColor || '#ffffff'}">${player.rankTag}</span>` : '';
        })()}
        ${(() => {
          if (showNick || isUnresolved) return `<span class="player-name" style="color:#ffffff">${esc(displayName)}</span>`;
          if (player.rankTag) return `<span class="player-name" style="color:${player.rankColor || '#ffffff'}">${esc(displayName)}</span>`;
          // Unranked -> grau wie Stone Prestige
          return `<span class="player-name" style="color:#AAAAAA">${esc(displayName)}</span>`;
        })()}
        ${hasNick ? `<span class="nick-indicator" title="${esc(tooltipOther)}"><svg class="icon icon-inline" aria-hidden="true"><use href="#i-ghost"/></svg></span>` : ''}
  ${isPartyMember ? `<span class="party-indicator" title="Party Member"><svg class="icon icon-inline" aria-hidden="true"><use href="#i-party"/></svg></span>` : ''}
  ${pinnedPlayers.has(key) ? `<span class="pin-indicator" title="Gepinnt"><svg class="icon icon-inline" aria-hidden="true"><use href="#i-pin"/></svg></span>` : ''}
        ${sessionUsername && String(player.name).trim().toLowerCase() === String(sessionUsername).trim().toLowerCase() ? `<span class="self-indicator" title="You"><svg class="icon icon-inline" aria-hidden="true" style="color: var(--accent);"><use href="#i-self"/></svg></span>` : ''}
      </td>`,
      dynamicCells
    ].join('');
    const pinned = pinnedPlayers.has(key);
    rows.insertAdjacentHTML("beforeend", `
      <tr data-name="${escAttr(player.name)}" ${pinned ? 'class="pinned"' : ''}>
        ${orderedCells}
        <td class="actions">
          <button class="icon-btn row-menu-btn">⋮</button>
          <div class="menu">
            <button class="pin-btn">${pinned ? 'Unpin' : 'Pin'}</button>
            <button class="remove-btn">Remove</button>
          </div>
        </td>
      </tr>
    `);
  }

    // Hypixel color constants (used for level/star coloring)
    const HypixelColors = {
        "AQUA": "#55FFFF",
        "BLACK": "#000000",
        "BLUE": "#5555FF",
        "DARK_AQUA": "#00AAAA",
        "DARK_BLUE": "#0000AA",
        "DARK_GRAY": "#555555",
        "DARK_GREEN": "#00AA00",
        "DARK_PURPLE": "#AA00AA",
        "DARK_RED": "#AA0000",
        "GOLD": "#FFAA00",
        "GRAY": "#AAAAAA",
        "GREEN": "#55FF55",
        "LIGHT_PURPLE": "#FF55FF",
        "RED": "#FF5555",
        "WHITE": "#FFFFFF",
        "YELLOW": "#FFFF55"
    };

    function formatStars(level, star, ...colors) {
      const span = (color, string) => `<span style="color: ${color}">${string}</span>`;
      let template = ``;
      const levelString = level.toString();

      if (colors.length === levelString.length + 3) {
        const digits = levelString.split('');
        template += span(colors[0], "[");
        for (let i = 0; i < digits.length; i++) {
          template += span(colors[i + 1], digits[i]);
        }
        template += span(colors[colors.length - 2], star);
        template += span(colors[colors.length - 1], "]");
      } else {
        template += span(colors.length == 1 ? colors[0] : '#AAAAAA', `[${level}${star}]`);
      }

      return template;
    }

    function starColor(stars) {
      const { AQUA, BLACK, BLUE, DARK_AQUA, DARK_BLUE, DARK_GRAY, DARK_GREEN, DARK_PURPLE, DARK_RED, GOLD, GRAY, GREEN, LIGHT_PURPLE, RED, WHITE, YELLOW } = HypixelColors;

      if (stars < 100) return formatStars(stars, '✫', GRAY);
      else if (stars < 200) return formatStars(stars, '✫', WHITE);
      else if (stars < 300) return formatStars(stars, '✫', GOLD);
      else if (stars < 400) return formatStars(stars, '✫', AQUA);
      else if (stars < 500) return formatStars(stars, '✫', DARK_GREEN);
      else if (stars < 600) return formatStars(stars, '✫', DARK_AQUA);
      else if (stars < 700) return formatStars(stars, '✫', DARK_RED);
      else if (stars < 800) return formatStars(stars, '✫', LIGHT_PURPLE);
      else if (stars < 900) return formatStars(stars, '✫', BLUE);
      else if (stars < 1000) return formatStars(stars, '✫', DARK_PURPLE);
      else if (stars < 1100) return formatStars(stars, '✫', RED, GOLD, YELLOW, GREEN, AQUA, LIGHT_PURPLE, DARK_PURPLE);
      else if (stars < 1200) return formatStars(stars, '✪', GRAY, WHITE, WHITE, WHITE, WHITE, GRAY, GRAY);
      else if (stars < 1300) return formatStars(stars, '✪', GRAY, YELLOW, YELLOW, YELLOW, YELLOW, GOLD, GRAY);
      else if (stars < 1400) return formatStars(stars, '✪', GRAY, AQUA, AQUA, AQUA, AQUA, DARK_AQUA, GRAY);
      else if (stars < 1500) return formatStars(stars, '✪', GRAY, GREEN, GREEN, GREEN, GREEN, DARK_GREEN, GRAY);
      else if (stars < 1600) return formatStars(stars, '✪', GRAY, DARK_AQUA, DARK_AQUA, DARK_AQUA, DARK_AQUA, BLUE, GRAY);
      else if (stars < 1700) return formatStars(stars, '✪', GRAY, RED, RED, RED, RED, DARK_RED, GRAY);
      else if (stars < 1800) return formatStars(stars, '✪', GRAY, LIGHT_PURPLE, LIGHT_PURPLE, LIGHT_PURPLE, LIGHT_PURPLE, DARK_PURPLE, GRAY);
      else if (stars < 1900) return formatStars(stars, '✪', GRAY, BLUE, BLUE, BLUE, BLUE, DARK_BLUE, GRAY);
      else if (stars < 2000) return formatStars(stars, '✪', GRAY, DARK_PURPLE, DARK_PURPLE, DARK_PURPLE, DARK_PURPLE, DARK_GRAY, GRAY);
      else if (stars < 2100) return formatStars(stars, '✪', DARK_GRAY, GRAY, WHITE, WHITE, GRAY, GRAY, DARK_GRAY);
      else if (stars < 2200) return formatStars(stars, '⚝', WHITE, WHITE, YELLOW, YELLOW, GOLD, GOLD, GOLD);
      else if (stars < 2300) return formatStars(stars, '⚝', GOLD, GOLD, WHITE, WHITE, AQUA, DARK_AQUA, DARK_AQUA);
      else if (stars < 2400) return formatStars(stars, '⚝', DARK_PURPLE, DARK_PURPLE, LIGHT_PURPLE, LIGHT_PURPLE, GOLD, YELLOW, YELLOW);
      else if (stars < 2500) return formatStars(stars, '⚝', AQUA, AQUA, WHITE, WHITE, GRAY, GRAY, DARK_GRAY);
      else if (stars < 2600) return formatStars(stars, '⚝', WHITE, WHITE, GREEN, GREEN, DARK_GRAY, DARK_GRAY, DARK_GRAY);
      else if (stars < 2700) return formatStars(stars, '⚝', DARK_RED, DARK_RED, RED, RED, LIGHT_PURPLE, LIGHT_PURPLE, DARK_PURPLE);
      else if (stars < 2800) return formatStars(stars, '⚝', YELLOW, YELLOW, WHITE, WHITE, DARK_GRAY, DARK_GRAY, DARK_GRAY);
      else if (stars < 2900) return formatStars(stars, '⚝', GREEN, GREEN, DARK_GREEN, DARK_GREEN, GOLD, GOLD, YELLOW);
      else if (stars < 3000) return formatStars(stars, '⚝', AQUA, AQUA, DARK_AQUA, DARK_AQUA, BLUE, BLUE, DARK_BLUE);
      else if (stars < 3100) return formatStars(stars, '⚝', YELLOW, YELLOW, GOLD, GOLD, RED, RED, DARK_RED);
      else if (stars < 3200) return formatStars(stars, '✥', BLUE, BLUE, AQUA, AQUA, GOLD, GOLD, YELLOW);
      else if (stars < 3300) return formatStars(stars, '✥', RED, DARK_RED, GRAY, GRAY, DARK_RED, RED, RED);
      else if (stars < 3400) return formatStars(stars, '✥', BLUE, BLUE, BLUE, LIGHT_PURPLE, RED, RED, DARK_RED);
      else if (stars < 3500) return formatStars(stars, '✥', DARK_GREEN, GREEN, LIGHT_PURPLE, LIGHT_PURPLE, DARK_PURPLE, DARK_PURPLE, DARK_GREEN);
      else if (stars < 3600) return formatStars(stars, '✥', RED, RED, DARK_RED, DARK_RED, DARK_GREEN, GREEN, GREEN);
      else if (stars < 3700) return formatStars(stars, '✥', GREEN, GREEN, GREEN, AQUA, BLUE, BLUE, DARK_BLUE);
      else if (stars < 3800) return formatStars(stars, '✥', DARK_RED, DARK_RED, RED, RED, AQUA, DARK_AQUA, DARK_AQUA);
      else if (stars < 3900) return formatStars(stars, '✥', DARK_BLUE, DARK_BLUE, BLUE, DARK_PURPLE, DARK_PURPLE, LIGHT_PURPLE, DARK_BLUE);
      else if (stars < 4000) return formatStars(stars, '✥', RED, RED, GREEN, GREEN, AQUA, BLUE, BLUE);
      else if (stars < 4100) return formatStars(stars, '✥', DARK_PURPLE, DARK_PURPLE, RED, RED, GOLD, GOLD, YELLOW);
      else if (stars < 4200) return formatStars(stars, '✥', YELLOW, YELLOW, GOLD, RED, LIGHT_PURPLE, LIGHT_PURPLE, DARK_PURPLE);
      else if (stars < 4300) return formatStars(stars, '✥', DARK_BLUE, BLUE, DARK_AQUA, AQUA, WHITE, GRAY, GRAY);
      else if (stars < 4400) return formatStars(stars, '✥', BLACK, DARK_PURPLE, DARK_GRAY, DARK_GRAY, DARK_PURPLE, DARK_PURPLE, BLACK);
      else if (stars < 4500) return formatStars(stars, '✥', DARK_GREEN, DARK_GREEN, GREEN, YELLOW, GOLD, DARK_PURPLE, LIGHT_PURPLE);
      else if (stars < 4600) return formatStars(stars, '✥', WHITE, WHITE, AQUA, AQUA, DARK_AQUA, DARK_AQUA, DARK_AQUA);
      else if (stars < 4700) return formatStars(stars, '✥', DARK_AQUA, AQUA, YELLOW, YELLOW, GOLD, LIGHT_PURPLE, DARK_PURPLE);
      else if (stars < 4800) return formatStars(stars, '✥', WHITE, DARK_RED, RED, RED, BLUE, DARK_BLUE, BLUE);
      else if (stars < 4900) return formatStars(stars, '✥', DARK_PURPLE, DARK_PURPLE, RED, GOLD, YELLOW, AQUA, DARK_AQUA);
      else if (stars < 5000) return formatStars(stars, '✥', DARK_GREEN, GREEN, WHITE, WHITE, GREEN, GREEN, DARK_GREEN);
      else return formatStars(stars, '✥', DARK_RED, DARK_RED, DARK_PURPLE, BLUE, BLUE, DARK_BLUE, BLACK);
    }

    function getBedWarsLevel(exp) {
      let level = 100 * (Math.floor(exp / 487000));
      exp = exp % 487000;
      if (exp < 500) return level + exp / 500;
      level++;
      if (exp < 1500) return level + (exp - 500) / 1000;
      level++;
      if (exp < 3500) return level + (exp - 1500) / 2000;
      level++;
      if (exp < 7000) return level + (exp - 3500) / 3500;
      level++;
      exp -= 7000;
      return level + exp / 5000;
    }

    // Update player level display. Accepts either a player object with stats or a stats-like object
    function updatePlayerLevel(player) {
      const exp = player?.stats?.Bedwars?.Experience ?? player?.experience;
      if (exp != null && !isNaN(Number(exp))) {
        const level = Math.floor(getBedWarsLevel(Number(exp)));
        return starColor(level);
      }
      const levelNum = player?.level ?? 0;
      return `[${fmt(levelNum)}✫]`;
    }

    // Fetch stats for a single player and update UI
    async function fetchPlayerStats(name) {
      console.log('[DEBUG] fetchPlayerStats called for', name);
      // Normalize by real name to reduce duplicates
      const realName = getRealName(name);
      const key = realName.toLowerCase();
      if (displayedPlayers.has(key)) return; // Skip if already displayed
      const wasNick = isNick(name);
      
      const res = await ipcRenderer.invoke("bedwars:stats", realName);

      if (res.error) {
        console.error('[DEBUG] Stats error for', realName, ':', res.error);
        return;
      }

  console.log('Received stats for', realName, ':', res);

  // Track successful stats lookup for metrics
  trackStatsLookup(res.name || realName);

  const normName = String(res.name || realName).toLowerCase();
  displayedPlayers.add(normName);
  playerCache[normName] = res;
  if (wasNick) { nickedPlayers.add(normName); originalNicks[res.name.toLowerCase()] = name; } else nickedPlayers.delete(normName);
      
      // After caching stats simply re-render table (row rendering centralised there)
      renderTable();

      // Rebind menu events for the new row
      bindMenus();
    }

    // Remove a player row and all state completely
    function removePlayer(name) {
      const key = String(getRealName(name) || name).trim().toLowerCase();
      
      // NEVER remove the session username (own user)
      if (sessionUsername && key === String(sessionUsername).trim().toLowerCase()) {
        console.log('Preventing removal of session username:', name);
        return;
      }
      // Prevent removal if pinned
      if (pinnedPlayers.has(key)) {
        console.log('Preventing removal of pinned player:', name);
        return;
      }
      
      const row = rows.querySelector(`tr[data-name="${escAttr(name)}"]`);
      if (row) row.remove();
      displayedPlayers.delete(key);
      playerSources.delete(key);
  nickedPlayers.delete(key);
      delete originalNicks[key];
      try { delete activeNickState[key]; } catch {}
      updateOverlaySize();
    }

    // Add/track a source for a player
    function addPlayerSource(name, source) {
      // Guard: check if source is disabled
      if (source === 'manual' && !sourcesSettings?.manual?.enabled) return;
      if (source === 'chat' && !sourcesSettings?.chat?.enabled) return;
      if (source === 'party' && !sourcesSettings?.party?.enabled) return;
      if (source === 'who' && !sourcesSettings?.game?.addFromWho) return;
  if (source === 'guild' && (!sourcesSettings?.guild?.enabled)) return;
      if (source === 'invite' && (!sourcesSettings?.party?.enabled || !sourcesSettings?.party?.showInviteTemp || !sourcesSettings?.partyInvites?.enabled)) return;
      
      const key = String(getRealName(name) || name).toLowerCase();
      const set = playerSources.get(key) || new Set();
      set.add(source);
      playerSources.set(key, set);
    }

    function removePlayerSource(name, source) {
      const key = String(getRealName(name) || name).toLowerCase();
      
      // NEVER remove sources for session username (own user)
      if (sessionUsername && key === String(sessionUsername).trim().toLowerCase()) {
        console.log('Preventing source removal for session username:', name, 'source:', source);
        return;
      }
      // Do not alter sources for pinned players (they are immutable except manual unpin)
      if (pinnedPlayers.has(key)) {
        console.log('Preventing source removal for pinned player:', name, 'source:', source);
        return;
      }
      
      const set = playerSources.get(key);
      if (!set) return;
      set.delete(source);
      if (set.size === 0) {
        removePlayer(name);
      } else {
        playerSources.set(key, set);
        updateOverlaySize();
      }
    }

    // Manage invite timeouts
    function addInviteTimeout(name) {
      const key = String(getRealName(name) || name).toLowerCase();
      
      // Clear any existing timeout
      if (inviteTimeouts.has(key)) {
        clearTimeout(inviteTimeouts.get(key));
      }
      
      // Set 60 second timeout to remove invite source
      const timeoutId = setTimeout(() => {
        console.log('Invite timeout expired for:', name);
        removePlayerSource(name, 'invite');
        inviteTimeouts.delete(key);
        renderTable();
        updateOverlaySize();
      }, 60000); // 60 seconds
      
      inviteTimeouts.set(key, timeoutId);
      console.log('Set invite timeout for:', name, 'expires in 60s');
    }

    function clearInviteTimeout(name) {
      const key = String(getRealName(name) || name).toLowerCase();
      if (inviteTimeouts.has(key)) {
        clearTimeout(inviteTimeouts.get(key));
        inviteTimeouts.delete(key);
      }
    }

    function clearAllButUsername() {
      // Remove all non-username-backed players; keep username-only
      const selfKey = sessionUsername ? String(sessionUsername).trim().toLowerCase() : null;
      for (const [key, set] of Array.from(playerSources.entries())) {
        // Always preserve the session user even if it (temporarily) lacks an explicit 'username' source
        if (selfKey && key === selfKey) {
          playerSources.set(key, new Set(['username']));
          continue;
        }
        // Preserve pinned players entirely
        if (pinnedPlayers.has(key)) {
          continue;
        }
        if (set.has('username')) {
          // Keep only username source
          playerSources.set(key, new Set(['username']));
          continue;
        }
        // remove entirely
        const tr = rows.querySelector(`tr[data-name="${escAttr(key)}"]`);
        if (tr) tr.remove();
        displayedPlayers.delete(key);
        playerSources.delete(key);
	  nickedPlayers.delete(key);
        delete originalNicks[key];
      }
      // Clean any stray rows
      rows.querySelectorAll('tr[data-name]').forEach(tr => {
        const dn = tr.getAttribute('data-name')?.toLowerCase();
        if (dn && !playerSources.has(dn)) tr.remove();
      });
      updateOverlaySize(); // Update window size after clearing
    }

    function addPlayer(name, source) {
      name = String(name || '').trim();
      if (!name) return;
      addPlayerSource(name, source);
      const key = String(getRealName(name) || name).trim().toLowerCase();
      // Update activeNickState heuristic: if user supplied the nick (not real) and it's registered, mark active.
      try {
        const registered = nicks.find(n => n.nick.toLowerCase() === name.toLowerCase());
        if (registered) {
          activeNickState[registered.real.toLowerCase()] = true;
        } else {
          // If they added the real name explicitly, mark inactive when previously unknown.
          const reverse = nicks.find(n => n.real.toLowerCase() === name.toLowerCase());
          if (reverse && activeNickState[reverse.real.toLowerCase()] == null) {
            activeNickState[reverse.real.toLowerCase()] = false;
          }
        }
      } catch {}
      if (!displayedPlayers.has(key)) {
        fetchPlayerStats(name).then(() => {
          updateOverlaySize();
          renderTable();
        });
      }
    }

    // Handle incoming player lists (from chat logger)
    ipcRenderer.on('chat:players', (_e, newPlayers) => {
      try {
        if (!Array.isArray(newPlayers)) return;
        if (!sourcesSettings?.game?.addFromWho) return; // feature disabled
  // Remove diffed old /who entries (only if not held by other sources)
  const incomingSet = new Set(newPlayers.map(p => String(p).trim().toLowerCase()));
        for (const [key, sources] of Array.from(playerSources.entries())) {
          if (sources.has('who') && !incomingSet.has(key)) {
            // Don't remove the session username - keep it in the overlay
            if (sessionUsername && key === String(sessionUsername).trim().toLowerCase()) {
              // Keep session username but remove the 'who' source
              sources.delete('who');
              playerSources.set(key, sources);
              continue;
            }
            // Skip removal if pinned
            if (pinnedPlayers.has(key)) {
              continue;
            }
            
            // Remove only the 'who' source; other sources may still keep the player
            sources.delete('who');
            if (sources.size === 0) {
              if (!pinnedPlayers.has(key)) {
                removePlayer(key);
              } else {
                playerSources.set(key, sources);
              }
            } else {
              playerSources.set(key, sources);
            }
          }
        }
  // Now add new players / set 'who' source
        newPlayers.forEach(player => {
          if (!player || typeof player !== 'string') return;
          addPlayer(player, 'who');
          // Active-nick Erkennung: Wenn der /who Name selbst ein registrierter Nick ist -> aktiv
          const entry = nicks.find(n => n.nick.toLowerCase() === player.toLowerCase());
          if (entry) {
            activeNickState[entry.real.toLowerCase()] = true;
          } else {
            // Falls der Name ein Realname einer Registrierung ist -> markiere als nicht nicked
            const rev = nicks.find(n => n.real.toLowerCase() === player.toLowerCase());
            if (rev) activeNickState[rev.real.toLowerCase()] = false;
          }
        });
        renderTable();
        updateOverlaySize();
      } catch (err) {
        console.error('Error handling chat:players', err);
      }
    });

    // Remove on Final Death (if enabled in settings)
    ipcRenderer.on('chat:finalKill', (_e, name) => {
      try {
        if (!name || typeof name !== 'string') return;
        if (sourcesSettings?.game?.removeOnDeath) {
          // Only remove the 'who' source; keep other sources (manual, party, chat, username)
          removePlayerSource(name, 'who');
        }
      } catch (err) {
        console.error('Error handling chat:finalKill', err);
      }
    });

    // Guild members handling (source: guild)
    ipcRenderer.on('chat:guildMembers', (_e, guildMembers) => {
      try {
        if (!Array.isArray(guildMembers)) return;
        if (!sourcesSettings?.guild?.enabled) return; // feature disabled -> ignore this batch entirely
        if (!guildBatchAccepted) return; // only apply if guild was enabled when the list started
        console.log('Guild settings check:', sourcesSettings?.guild?.enabled, 'Adding', guildMembers.length, 'guild members');
        
        // Add all guild members with 'guild' source
        guildMembers.forEach(member => {
          if (!member || typeof member !== 'string') return;
          addPlayer(member, 'guild');
        });
        
        renderTable();
        updateOverlaySize();
      } catch (err) {
        console.error('Error handling chat:guildMembers', err);
      }
    });

    // Guild member left: remove guild source if onlineOnly is enabled
    ipcRenderer.on('chat:guildMemberLeft', (_e, name) => {
      try {
        if (!name || typeof name !== 'string') return;
        if (!sourcesSettings?.guild?.enabled) return;
        // Only enforce removal when onlineOnly is active AND we're in pre-game lobby or in-game.
        // In normal lobbies, keep showing guild members even if a live "Guild > name left." arrives.
        if (sourcesSettings?.guild?.onlineOnly && (preGameLobby || gameInProgress)) {
          console.log('Guild member left (onlineOnly active):', name);
          removePlayerSource(name, 'guild');
          renderTable();
          updateOverlaySize();
        }
      } catch (err) {
        console.error('Error handling chat:guildMemberLeft', err);
      }
    });

    // Party members handling (source: party)
    ipcRenderer.on('chat:party', (_e, members) => {
      try {
        if (!Array.isArray(members)) return;
        const incoming = new Set(members.filter(m => typeof m === 'string').map(m => m.toLowerCase()));
        // Add new members
        members.forEach(member => {
          if (!member || typeof member !== 'string') return;
          addPlayer(member, 'party');
          // Clear invite timeout since they're now in party
          clearInviteTimeout(member);
          // Remove any lingering 'invite' source so player is fully promoted to party
          removePlayerSource(member, 'invite');
        });
        // Remove party source for players no longer in party
        if (sourcesSettings?.party?.removeOnMemberLeave) {
          for (const [key, sources] of Array.from(playerSources.entries())) {
            if (sources.has('party') && !incoming.has(key)) {
              sources.delete('party');
              if (sources.size === 0) {
                if (!pinnedPlayers.has(key)) {
                  removePlayer(key);
                } else {
                  playerSources.set(key, sources);
                }
              } else {
                playerSources.set(key, sources);
              }
            }
          }
        }
        renderTable();
        updateOverlaySize();
      } catch (err) {
        console.error('Error handling chat:party', err);
      }
    });

    // Party invite (only fetch stats, don't add to party source)
    ipcRenderer.on('chat:partyInvite', (_e, inviter) => {
      try {
        if (!inviter || typeof inviter !== 'string') return;
        if (!sourcesSettings?.party?.enabled || !sourcesSettings?.party?.showInviteTemp || !sourcesSettings?.partyInvites?.enabled) return;
        
        console.log('Party invite received from:', inviter);
        addPlayer(inviter, 'invite');
        addInviteTimeout(inviter);
        renderTable();
        updateOverlaySize();
      } catch (err) {
        console.error('Error handling chat:partyInvite', err);
      }
    });

    // Party invite expired - remove invite source immediately
    ipcRenderer.on('chat:partyInviteExpired', (_e, player) => {
      try {
        if (!player || typeof player !== 'string') return;
        console.log('Party invite expired for:', player);
        
        // Clear timeout and remove invite source
        clearInviteTimeout(player);
        removePlayerSource(player, 'invite');
        renderTable();
        updateOverlaySize();
      } catch (err) {
        console.error('Error handling chat:partyInviteExpired', err);
      }
    });

    // Party cleared (You left the party)
    ipcRenderer.on('chat:partyCleared', () => {
      try {
        if (sourcesSettings?.party?.removeAllOnLeaveOrDisband) {
          for (const [key, sources] of Array.from(playerSources.entries())) {
            if (sources.has('party')) {
              sources.delete('party');
              if (sources.size === 0) {
                if (!pinnedPlayers.has(key)) {
                  removePlayer(key);
                } else {
                  playerSources.set(key, sources);
                }
              } else {
                playerSources.set(key, sources);
              }
            }
          }
        }
        renderTable();
        updateOverlaySize();
      } catch (err) {
        console.error('Error handling chat:partyCleared', err);
      }
    });

    function esc(s) { return s.replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c])); }
    function escAttr(s) { return esc(s).replace(/"/g, "&quot;"); }
    function fmt(n) {
      if (n == null) return "—";
      if (typeof n === 'string') return n || "—";
      if (typeof n === 'number') return isNaN(n) ? "—" : n;
      return String(n);
    }
    
    // Nick management (definition moved earlier)

    // Nicks Panel UI
    function renderNicks() {
      const list = document.getElementById('nicksList');
      if (!list) return;

      list.innerHTML = nicks.map(({nick, real}) => `
        <div class="nick-row" data-nick="${escAttr(nick)}">
          <span class="nick-name">${esc(nick)}</span>
          <span class="nick-real">${esc(real)}</span>
          <button class="delete-btn" title="Remove nick">✕</button>
        </div>
      `).join('');

      list.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', e => {
          const row = e.target.closest('.nick-row');
          const nick = row.getAttribute('data-nick');
          nicks = nicks.filter(n => n.nick !== nick);
          saveNicks();
          renderNicks();
          renderTable();
        });
      });
    }

    // Nick form handling
    const addNickBtn = document.getElementById('addNickBtn');
    const addNickForm = document.getElementById('addNickForm');
    const nickInput = document.getElementById('nickInput');
    const realNameInput = document.getElementById('realNameInput');
    const saveNickBtn = document.getElementById('saveNickBtn');
    const nickDisplayModeSelect = document.getElementById('nickDisplayMode');
    if (nickDisplayModeSelect) {
      nickDisplayModeSelect.value = nickDisplayMode;
      nickDisplayModeSelect.addEventListener('change', () => {
        nickDisplayMode = nickDisplayModeSelect.value;
        localStorage.setItem('nickDisplayMode', nickDisplayMode);
        renderTable();
      });
    }

    // Show/hide form when + button is clicked
    addNickBtn?.addEventListener('click', () => {
      addNickForm.style.display = 'block';
      nickInput.focus();
    });

    // Save nick when form is submitted
    saveNickBtn?.addEventListener('click', () => {
      const nick = nickInput.value.trim();
      const real = realNameInput.value.trim();
      
      if (nick && real) {
        if (!nicks.some(n => n.nick.toLowerCase() === nick.toLowerCase())) {
          nicks.push({nick, real});
          saveNicks();
          renderNicks();
          renderTable();
          
          // Reset form
          nickInput.value = '';
          realNameInput.value = '';
          addNickForm.style.display = 'none';
        }
      }
    });

    // Enter in second input also submits
    realNameInput?.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        saveNickBtn.click();
      }
    });

    // Escape closes form
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape' && addNickForm.style.display === 'block') {
        addNickForm.style.display = 'none';
        nickInput.value = '';
        realNameInput.value = '';
      }
    });

    // Chat strings → add player who matches any configured string (case-insensitive)
    // Also handles guild list parsing
    ipcRenderer.on('chat:message', (_e, payload) => {
      try {
        if (!payload || typeof payload.text !== 'string') return;
        const { name, text } = payload;
        const msg = text;

        // 1. Guild list parsing (always check, independent of chat settings)
        // Detect guild list start: "Guild Name: ..."
        if (msg.indexOf('Guild Name: ') === 0) {
          guildListMode = true;
          guildBatchAccepted = !!sourcesSettings?.guild?.enabled; // snapshot enabled state
          console.log('[Guild] Guild list mode activated (accepted=', guildBatchAccepted, ')');
          return;
        }

        // Parse guild member lines (online: " ●  ", offline: " ?  ")
  if (guildListMode && guildBatchAccepted && (msg.indexOf(' ●  ') !== -1 || msg.indexOf(' ?  ') !== -1)) {
          const isOnline = msg.indexOf(' ●  ') !== -1;
          
          // Skip offline members if onlineOnly is enabled
          if (!isOnline && sourcesSettings?.guild?.onlineOnly) {
            return;
          }

          const separator = isOnline ? ' ●  ' : ' ?  ';
          const members = msg.split(separator);

          for (let member of members) {
            member = member.trim();
            if (!member) continue;

            // Remove rank prefix if present (e.g., "[MVP+] PlayerName" → "PlayerName")
            if (member[0] === '[') {
              const spaceIdx = member.indexOf(' ');
              if (spaceIdx !== -1) {
                member = member.substring(spaceIdx + 1).trim();
              }
            }

            if (member) {
              addPlayer(member, 'guild');
            }
          }
          return;
        }

        // Detect guild list end: "Total Members: ..."
        if (guildListMode && msg.indexOf('Total Members:') === 0) {
          guildListMode = false;
          guildBatchAccepted = false;
          console.log('[Guild] Guild list mode deactivated');
          return;
        }

        // 2. Chat trigger strings
        if (!sourcesSettings?.chat?.enabled || !name) return;
        const patterns = (sourcesSettings.chat.strings || []).filter(Boolean).map(String);
        if (patterns.length) {
          const t = String(text).toLowerCase();
          if (patterns.some(p => t.includes(String(p).toLowerCase()))) {
            addPlayer(name, 'chat');
          }
        }

        // 3. Game setting: addFromChat (players speaking pre-game in lobby)
        if (sourcesSettings?.game?.addFromChat && preGameLobby && name) {
          addPlayer(name, 'chat');
        }
      } catch (err) {
        console.error('Error handling chat:message', err);
      }
    });

    // Username mention → add player if enabled under chat settings
    ipcRenderer.on('chat:usernameMention', (_e, name) => {
      try {
        if (!name || typeof name !== 'string') return;
        if (!sourcesSettings?.chat?.enabled) return;
        if (sourcesSettings?.chat?.addOnMention) {
          addPlayer(name, 'chat');
        }
      } catch (err) {
        console.error('Error handling chat:usernameMention', err);
      }
    });

    // Server change → remove who/chat/username/guild sources if enabled
    ipcRenderer.on('chat:serverChange', () => {
      try {
        // Enter pre-game lobby phase on server change; game not yet started
        preGameLobby = true;
        gameInProgress = false;
        if (!sourcesSettings?.game?.removeOnServerChange && !sourcesSettings?.chat?.removeOnServerChange && !sourcesSettings?.guild?.removeOnServerChange) return;
        const allKeys = Array.from(playerSources.keys());
        allKeys.forEach(key => {
          const sources = playerSources.get(key);
          if (!sources) return;
          let changed = false;
          if (sourcesSettings?.game?.removeOnServerChange && sources.has('who')) {
            sources.delete('who');
            changed = true;
          }
          if (sourcesSettings?.chat?.removeOnServerChange) {
            if (sources.has('chat')) {
              sources.delete('chat');
              changed = true;
            }
            if (sources.has('username')) {
              sources.delete('username');
              changed = true;
            }
          }
          if (sourcesSettings?.guild?.removeOnServerChange && sources.has('guild')) {
            sources.delete('guild');
            changed = true;
          }
          if (changed) {
            if (sources.size === 0) {
              if (!pinnedPlayers.has(key)) {
                removePlayer(key);
              } else {
                playerSources.set(key, sources); // keep empty set for pinned
              }
            } else {
              playerSources.set(key, sources);
            }
          }
        });
        renderTable();
        updateOverlaySize();
      } catch (err) {
        console.error('Error handling chat:serverChange', err);
      }
    });

    // Lobby join → remove who/chat/username sources if enabled
    ipcRenderer.on('chat:lobbyJoined', () => {
      try {
        // Leaving game back to lobby: disable pre-game chat auto-add
        preGameLobby = false;
        gameInProgress = false;
        if (!sourcesSettings?.game?.removeOnServerChange && !sourcesSettings?.chat?.removeOnServerChange) return;
        const allKeys = Array.from(playerSources.keys());
        allKeys.forEach(key => {
          const sources = playerSources.get(key);
          if (!sources) return;
          let changed = false;
          if (sourcesSettings?.game?.removeOnServerChange && sources.has('who')) {
            sources.delete('who');
            changed = true;
          }
          if (sourcesSettings?.chat?.removeOnServerChange) {
            if (sources.has('chat')) {
              sources.delete('chat');
              changed = true;
            }
            if (sources.has('username')) {
              sources.delete('username');
              changed = true;
            }
          }
          if (changed) {
            if (sources.size === 0) {
              if (!pinnedPlayers.has(key)) {
                removePlayer(key);
              } else {
                playerSources.set(key, sources);
              }
            } else {
              playerSources.set(key, sources);
            }
          }
        });
        renderTable();
        updateOverlaySize();
      } catch (err) {
        console.error('Error handling chat:lobbyJoined', err);
      }
    });

    // Game start → optionally clear manually added players and guild members
    ipcRenderer.on('chat:gameStart', () => {
      try {
        // Game started: disable pre-game chat auto-add
        preGameLobby = false;
        gameInProgress = true;
        
        // Clear manually added players if setting is enabled
        if (sourcesSettings?.manual?.clearOnGameStart) {
          for (const [key, sources] of Array.from(playerSources.entries())) {
            if (sources.has('manual')) {
              sources.delete('manual');
              if (sources.size === 0) {
                removePlayer(key);
              } else {
                playerSources.set(key, sources);
              }
            }
          }
        }
        
        // Always clear guild members when game starts (they should not persist in actual games)
        for (const [key, sources] of Array.from(playerSources.entries())) {
          if (sources.has('guild')) {
            sources.delete('guild');
            if (sources.size === 0) {
              if (!pinnedPlayers.has(key)) {
                removePlayer(key);
              } else {
                playerSources.set(key, sources);
              }
            } else {
              playerSources.set(key, sources);
            }
          }
        }
        
        renderTable();
        updateOverlaySize();
      } catch (err) {
        console.error('Error handling chat:gameStart', err);
      }
    });

    async function fetchAll() {
      // Add all queued players as manual entries (does not clear current list)
      for (const inputName of queue) {
        addPlayer(inputName, 'manual');
      }
      queue = [];
    }

    function bindMenus() {
      const btns = Array.from(document.querySelectorAll(".row-menu-btn"));
      const removes = Array.from(document.querySelectorAll(".remove-btn"));
      const pins = Array.from(document.querySelectorAll('.pin-btn'));

      btns.forEach(btn => {
        btn.addEventListener("click", e => {
          e.stopPropagation();
          closeAllMenus();
          const menu = btn.nextElementSibling;
          menu.classList.add("open");
        });
      });

      removes.forEach(b => {
        b.addEventListener("click", e => {
          e.stopPropagation();
          const tr = b.closest("tr");
          const name = tr.getAttribute("data-name");
          queue = queue.filter(n => n.toLowerCase() !== name.toLowerCase());
          // Do not remove if pinned
          if (!pinnedPlayers.has(String(name).toLowerCase())) {
            removePlayer(name);
          }
          closeAllMenus();
        });
      });

      pins.forEach(b => {
        b.addEventListener('click', e => {
          e.stopPropagation();
          const tr = b.closest('tr');
          const name = tr.getAttribute('data-name');
          const key = String(name || '').toLowerCase();
          if (pinnedPlayers.has(key)) {
            pinnedPlayers.delete(key);
            b.textContent = 'Pin';
            tr.classList.remove('pinned');
          } else {
            pinnedPlayers.add(key);
            b.textContent = 'Unpin';
            tr.classList.add('pinned');
          }
          savePinned();
          closeAllMenus();
          renderTable();
        });
      });

      document.addEventListener("click", closeAllMenus);
    }

    function closeAllMenus() {
      document.querySelectorAll(".menu.open").forEach(m => m.classList.remove("open"));
    }

    input.addEventListener("keydown", e => {
      if (e.key === "Enter") {
        const names = input.value.split(",").map(s => s.trim()).filter(Boolean);
        queue.push(...names);
        input.value = "";
        fetchAll();
      }
    });

    document.getElementById("clearAll").addEventListener("click", () => {
      queue = [];
      clearAllButUsername();
      updateOverlaySize();
    });

    document.getElementById("refresh").addEventListener("click", fetchAll);
    document.getElementById("minBtn").addEventListener("click", () => ipcRenderer.send("window:minimize"));
    document.getElementById("closeBtn").addEventListener("click", () => ipcRenderer.send("window:close"));

    // Shortcut-triggered actions from main
    ipcRenderer.on('shortcut:refresh', () => fetchAll());
    ipcRenderer.on('shortcut:clear', () => {
      queue = [];
      clearAllButUsername();
    });

    // --- resize grips
    let resizing = null;
    function onDown(e) {
      const edge = e.target.getAttribute("data-edge");
      if (!edge) return;
      resizing = { edge, startX: e.screenX, startY: e.screenY };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp, { once: true });
    }
    function onMove(e) {
      if (!resizing) return;
      const dx = e.screenX - resizing.startX;
      const dy = e.screenY - resizing.startY;
      ipcRenderer.invoke("window:resize", { edge: resizing.edge, dx, dy });
      resizing.startX = e.screenX;
      resizing.startY = e.screenY;
    }
    function onUp() {
      resizing = null;
      window.removeEventListener("mousemove", onMove);
    }

    // Sidebar toggle + interactions
    const menuBtn = document.getElementById('menuBtn');
    const sidebar = document.getElementById('sidebar');

    if (menuBtn && sidebar) {
      menuBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const opened = sidebar.classList.toggle('open');
        sidebar.setAttribute('aria-hidden', String(!opened));
        updateOverlaySize(); // recalculate when sidebar opens/closes
      });

      // Close sidebar when clicking outside
      document.addEventListener('click', (e) => {
        if (!sidebar.classList.contains('open')) return;
        if (e.target.closest && (e.target.closest('#sidebar') || e.target.closest('#menuBtn'))) return;
        sidebar.classList.remove('open');
        sidebar.setAttribute('aria-hidden', 'true');
        updateOverlaySize(); // recalculate
      });

      // Close with Escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && sidebar.classList.contains('open')) {
          sidebar.classList.remove('open');
          sidebar.setAttribute('aria-hidden', 'true');
          updateOverlaySize(); // recalculate
        }
      });

  // Removed: generic activation of all nav items (caused conflicts with sub-items)
    }

    document.querySelectorAll(".grip").forEach(g => g.addEventListener("mousedown", onDown));
    
    // --- Panel switching (flat list)
    function showPanel(id) {
      // Get current panel before switching
      const currentPanel = document.querySelector('.panel.active')?.id?.replace('panel-', '');
      
      // If leaving columns panel, remove empty slots
      if (currentPanel === 'columns' && id !== 'columns') {
        const beforeLength = statSettings.layout.length;
        statSettings.layout = statSettings.layout.filter(slot => slot !== null);
        
        // Ensure we always have at least 6 slots
        while (statSettings.layout.length < 6) {
          statSettings.layout.push(null);
        }
        
        // Only save if something changed
        if (beforeLength !== statSettings.layout.length) {
          saveStatSettings();
        }
      }
      
      // Session panel specific logic
      if (id === 'session') {
        console.log('=== Session Panel Debug ===');
        console.log('typeof basicSettings:', typeof basicSettings);
        console.log('basicSettings exists:', !!basicSettings);
        console.log('basicSettings object:', basicSettings);
        
        // Ensure basicSettings is available
        if (typeof basicSettings === 'undefined' || !basicSettings) {
          console.log('basicSettings not available, loading from localStorage');
          basicSettings = JSON.parse(localStorage.getItem('basicSettings') || JSON.stringify(defaultBasic));
          console.log('Loaded basicSettings:', basicSettings);
        }
        
        // Get username from basicSettings (not localStorage)
        const username = basicSettings.username?.trim();
        console.log('Session panel opened, username from basicSettings:', username);
        console.log('sessionUsername:', sessionUsername);
        console.log('startStats:', startStats);
        
        if (!username) {
          // No username set - show instructions
          const sessionStats = document.getElementById('sessionStats');
          const sessionIgn = document.getElementById('sessionIgn');
          const sessionTime = document.getElementById('sessionTime');
          
          if (sessionStats) {
            sessionStats.innerHTML = `
              <div style="text-align:center;color:var(--muted);padding:40px 20px;">
                <svg class="icon" aria-hidden="true" style="width:48px;height:48px;margin-bottom:12px;opacity:0.5;"><use href="#i-profile"/></svg>
                <div style="font-size:16px;margin-bottom:8px;color:var(--text);">No Username Set</div>
                <div style="font-size:13px;line-height:1.5;">
                  Go to <strong>Profile</strong> and enter your Minecraft IGN to start tracking session stats.<br><br>
                  Session stats show your progress since opening the app!
                </div>
              </div>
            `;
          }
          if (sessionIgn) sessionIgn.textContent = 'No player selected';
          if (sessionTime) sessionTime.textContent = 'Session not started';
        } else if (username !== sessionUsername) {
          console.log('Starting session because username changed:', username, '!==', sessionUsername);
          startSession(username);
        } else if (sessionUsername && startStats) {
          console.log('Updating existing session');
          updateSession();
        } else {
          console.log('Session state unclear - startStats:', !!startStats, 'sessionUsername:', sessionUsername);
        }
        console.log('=== End Session Panel Debug ===');
      }
      
      document.querySelectorAll('.panel').forEach(p => {
        p.classList.toggle('active', p.id === `panel-${id}`);
      });
      localStorage.setItem('activePanel', id);
      document.querySelectorAll('.nav > .nav-item').forEach(b => {
        b.classList.toggle('active', b.getAttribute('data-panel') === id);
      });
      
      // Update account stats when switching to profile panel
      if (id === 'profile') {
        setTimeout(() => updateAccountStats(), 100);
      }
      
      updateOverlaySize();
    }

    // Sidebar navigation (all direct panels now, no submenu)
    document.querySelectorAll('.nav > .nav-item').forEach(btn => {
      btn.addEventListener('click', () => {
        const panel = btn.getAttribute('data-panel');
        if (panel) showPanel(panel);
      });
    });

  // Remove old settings submenu persistence (no longer needed)
  localStorage.removeItem('settingsExpanded');
  localStorage.removeItem('activeSettingsSection');
  // Always start in Overlay panel on launch
  showPanel('overlay');

    // Default color rules for each stat
    const DEFAULT_COLOR_RULES = {
      fkdr: [
        { op: '>=', value: 100, color: '#ff00ff' },
        { op: '>=', value: 50, color: '#ff69b4' },
        { op: '>=', value: 30, color: '#dc143c' },
        { op: '>=', value: 20, color: '#ff7f50' },
        { op: '>=', value: 10, color: '#ffa500' },
        { op: '>=', value: 7, color: '#ffff00' },
        { op: '>=', value: 5, color: '#00ff00' },
        { op: '>=', value: 3, color: '#00ff00' },
        { op: '>=', value: 1, color: '#ffffff' },
        { op: '>=', value: 0, color: '#808080' }
      ],
      wlr: [
        { op: '>=', value: 100, color: '#ff00ff' },
        { op: '>=', value: 50, color: '#ff69b4' },
        { op: '>=', value: 30, color: '#dc143c' },
        { op: '>=', value: 20, color: '#ff7f50' },
        { op: '>=', value: 10, color: '#ffa500' },
        { op: '>=', value: 7, color: '#ffff00' },
        { op: '>=', value: 5, color: '#00ff00' },
        { op: '>=', value: 3, color: '#00ff00' },
        { op: '>=', value: 1, color: '#ffffff' },
        { op: '>=', value: 0, color: '#808080' }
      ],
      ws: [
        { op: '>=', value: 100, color: '#ff0000' },
        { op: '>=', value: 50, color: '#ffff00' }
      ],
      bedwarsScore: [
        { op: '>=', value: 1000, color: '#ff00ff' },
        { op: '>=', value: 500, color: '#ff69b4' },
        { op: '>=', value: 300, color: '#dc143c' },
        { op: '>=', value: 200, color: '#ff7f50' },
        { op: '>=', value: 100, color: '#ffa500' },
        { op: '>=', value: 70, color: '#ffff00' },
        { op: '>=', value: 50, color: '#00ff00' },
        { op: '>=', value: 30, color: '#00ff00' },
        { op: '>=', value: 10, color: '#ffffff' },
        { op: '>=', value: 0, color: '#808080' }
      ],
      bblr: [
        { op: '>=', value: 50, color: '#ff00ff' },
        { op: '>=', value: 30, color: '#ff69b4' },
        { op: '>=', value: 20, color: '#dc143c' },
        { op: '>=', value: 10, color: '#ff7f50' },
        { op: '>=', value: 5, color: '#ffa500' },
        { op: '>=', value: 3, color: '#ffff00' },
        { op: '>=', value: 2, color: '#00ff00' },
        { op: '>=', value: 1, color: '#00ff00' },
        { op: '>=', value: 0.5, color: '#ffffff' },
        { op: '>=', value: 0, color: '#808080' }
      ],
      fk: [
        { op: '>=', value: 50000, color: '#ff00ff' },
        { op: '>=', value: 25000, color: '#ff0000' },
        { op: '>=', value: 10000, color: '#ffa500' },
        { op: '>=', value: 5000, color: '#ffff00' },
        { op: '>=', value: 1000, color: '#00ff00' },
        { op: '>=', value: 0, color: '#ffffff' }
      ],
      wins: [
        { op: '>=', value: 10000, color: '#ff00ff' },
        { op: '>=', value: 5000, color: '#ff0000' },
        { op: '>=', value: 2500, color: '#ffa500' },
        { op: '>=', value: 1000, color: '#ffff00' },
        { op: '>=', value: 500, color: '#00ff00' },
        { op: '>=', value: 0, color: '#ffffff' }
      ]
    };

    // Load/save stat settings
    let statSettings = JSON.parse(localStorage.getItem('statSettings') || JSON.stringify({
      visible: Object.keys(STATS),
      order: Object.keys(STATS),
      layout: ['ws','fkdr','wlr','bblr','fk','wins','mode'], 
      colorRules: DEFAULT_COLOR_RULES
    }));
    
    // Migration: Ensure all STATS are in visible array (for users with old localStorage)
    if (!statSettings.visible || !Array.isArray(statSettings.visible)) {
      statSettings.visible = Object.keys(STATS).filter(k => !STATS[k]?.disabled);
    } else {
      // Add any missing stats to visible
      const allStats = Object.keys(STATS).filter(k => !STATS[k]?.disabled);
      for (const stat of allStats) {
        if (!statSettings.visible.includes(stat)) {
          statSettings.visible.push(stat);
        }
      }
    }
    
    // Migration: Ensure order contains all stats
    if (!statSettings.order || !Array.isArray(statSettings.order)) {
      statSettings.order = Object.keys(STATS).filter(k => !STATS[k]?.disabled);
    } else {
      const allStats = Object.keys(STATS).filter(k => !STATS[k]?.disabled);
      for (const stat of allStats) {
        if (!statSettings.order.includes(stat)) {
          statSettings.order.push(stat);
        }
      }
    }
    
    if (!Array.isArray(statSettings.layout)) {
      statSettings.layout = ['ws','fkdr','wlr','bblr','fk','wins','mode'];
    }
    // Ensure layout has between 6 and 12 slots
    while (statSettings.layout.length < 6) {
      statSettings.layout.push(null);
    }
    if (statSettings.layout.length > 12) {
      statSettings.layout = statSettings.layout.slice(0, 12);
    }

    // Migration: convert legacy color names to hex once on load
    (function migrateColorRules() {
      const map = { good: '#00ff00', warn: '#ffff00', bad: '#ff0000' };
      try {
        if (statSettings && statSettings.colorRules) {
          let changed = false;
          for (const key of Object.keys(statSettings.colorRules)) {
            const arr = statSettings.colorRules[key];
            if (!Array.isArray(arr)) continue;
            for (const rule of arr) {
              if (rule && typeof rule.color === 'string' && map[rule.color]) {
                rule.color = map[rule.color];
                changed = true;
              }
            }
          }
          if (changed) {
            localStorage.setItem('statSettings', JSON.stringify(statSettings));
          }
        }
      } catch {}
    })();

    function saveStatSettings() {
      // Purge disabled stats from layout and visible/order if present (migration)
      try {
        const disabledKeys = Object.keys(STATS).filter(k => STATS[k]?.disabled);
        if (disabledKeys.length) {
          statSettings.layout = statSettings.layout.map(x => (disabledKeys.includes(x) ? null : x));
          statSettings.visible = (statSettings.visible || []).filter(k => !disabledKeys.includes(k));
          statSettings.order = (statSettings.order || []).filter(k => !disabledKeys.includes(k));
          if (disabledKeys.includes(sortKey)) { sortKey = null; }
        }
      } catch {}
      localStorage.setItem('statSettings', JSON.stringify(statSettings));
      renderTable();
      renderStatLayoutSlots();
      renderStatLayoutPalette();
    }

    // Rebuild the entire table from cache (used when stat settings change)
    function renderTable() {
      const table = document.getElementById('table');
      if (!table) return;
      console.log('[DEBUG] renderTable called. displayedPlayers:', Array.from(displayedPlayers));
      const dynamicStats = statSettings.layout.filter(k => k && statSettings.visible.includes(k));
      const colgroup = table.querySelector('colgroup');
      const thead = table.querySelector('thead');
      if (colgroup) {
        colgroup.innerHTML = ['c-lvl','c-name', ...dynamicStats.map(s => 'c-'+s), 'c-actions']
          .map(cls => `<col class="${cls}">`).join('');
      }
      if (thead) {
        // Include bedwarsScore header explicitly if part of dynamicStats; dynamicStats already filtered from layout.
        thead.innerHTML = `<tr>
          <th data-sort-key="level">${`Lvl${sortKey === 'level' ? (sortDir === 'asc' ? ' ▲' : ' ▼') : ''}`}</th>
          <th>Name</th>
          ${dynamicStats.map(s => {
            const stat = STATS[s];
            const sortable = stat.type === 'number';
            let label = stat.short || stat.name;
            if (sortable && sortKey === s) {
              label += sortDir === 'asc' ? ' ▲' : ' ▼';
            }
            return `<th class="metric-h${sortKey === s ? ' sorted' : ''}" ${sortable ? `data-sort-key="${s}"` : ''}>${label}</th>`;
          }).join('')}
          <th></th>
        </tr>`;
      }
      const tbody = document.getElementById('rows');
      if (!tbody) return;
      tbody.innerHTML = '';
        // Ensure uniqueness & latest player object wins
        const seen = new Set();
        const entriesRaw = Array.from(displayedPlayers).map(n => [n, playerCache[n]]).filter(([,p]) => Boolean(p));
        const entries = [];
        for (const [n,p] of entriesRaw) { if (!seen.has(n)) { seen.add(n); entries.push([n,p]); } }
      if (sortKey) {
        const dir = sortDir === 'asc' ? 1 : -1;
        entries.sort(([, a], [, b]) => {
          const va = getSortValue(a, sortKey);
          const vb = getSortValue(b, sortKey);
          const na = Number.isFinite(va) ? va : -Infinity;
          const nb = Number.isFinite(vb) ? vb : -Infinity;
          return dir * (na - nb);
        });
      }
      for (const [normName, player] of entries) {
        const wasNick = typeof nickedPlayers !== 'undefined' && nickedPlayers.has(normName);
        renderPlayerRow(player, wasNick, dynamicStats);
      }
      bindMenus();
      bindSortHeaders(); // Bind click handlers for sorting
      updateOverlaySize();
    }

    // Bind sort handlers to table headers
    function bindSortHeaders() {
      const headers = document.querySelectorAll('thead th[data-sort-key]');
      headers.forEach(th => {
        th.addEventListener('click', () => {
          const key = th.getAttribute('data-sort-key');
          if (!key) return;
          
          // Toggle sort direction if clicking same column, else default to descending
          // Neue Logik:
          // - Erster Klick auf eine Spalte -> aufsteigend (klein -> groß)
          // - Erneuter Klick toggelt wie bisher
          // - Shift+Klick erzwingt sofort Gegenrichtung beim Initialisieren
          const shift = window.event instanceof MouseEvent ? window.event.shiftKey : false;
          if (sortKey === key) {
            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
          } else {
            sortKey = key;
            sortDir = shift ? 'desc' : 'asc'; // Default jetzt auf ASC; mit Shift direkt DESC
          }
          // Hinweis für zukünftige Devs: Falls Nutzer lieber High->Low zuerst hätten,
          // kann hier wieder auf 'desc' gewechselt oder ein Setting eingeführt werden.
          
          // Update visual indicators
            try { localStorage.setItem('sortKey', sortKey); localStorage.setItem('sortDir', sortDir); } catch {}
          
          // Re-render table with new sort
          renderTable();
        });
      });
    }

    // Color rules modal
    function showColorRules(column) {
      const modal = document.getElementById('colorRulesModal');
      const title = document.getElementById('colorRuleTitle');
      const rulesList = document.getElementById('colorRulesList');
      
      title.textContent = STATS[column].name;
      modal.classList.add('open');

      function renderRules() {
        const rules = statSettings.colorRules[column] || [];
        rulesList.innerHTML = rules.map((rule, i) => {
          // Migration: convert old CSS variable names to hex colors
          let color = rule.color;
          if (color === 'good') color = '#00ff00';
          if (color === 'warn') color = '#ffff00';
          if (color === 'bad') color = '#ff0000';
          return `
          <div class="color-rule" data-index="${i}">
            <select class="rule-operator">
              <option value=">=" ${rule.op === '>=' ? 'selected' : ''}>≥</option>
              <option value="<" ${rule.op === '<' ? 'selected' : ''}>＜</option>
            </select>
            <input type="number" class="rule-value" value="${rule.value}" step="0.1">
            <div class="color-picker">
              <div class="color-preview" style="background: ${color}"></div>
              <input type="color" class="color-input" value="${color}">
            </div>
            <button class="rule-delete">×</button>
          </div>
        `;
        }).join('');

        // Bind rule events
        rulesList.querySelectorAll('.color-rule').forEach(rule => {
          const i = parseInt(rule.dataset.index);
          
          rule.querySelector('.rule-operator').addEventListener('change', e => {
            statSettings.colorRules[column][i].op = e.target.value;
            saveStatSettings();
          });

          rule.querySelector('.rule-value').addEventListener('change', e => {
            statSettings.colorRules[column][i].value = parseFloat(e.target.value);
            saveStatSettings();
          });

          rule.querySelector('.color-input').addEventListener('change', e => {
            statSettings.colorRules[column][i].color = e.target.value;
            rule.querySelector('.color-preview').style.background = e.target.value;
            saveStatSettings();
          });

          rule.querySelector('.rule-delete').addEventListener('click', () => {
            statSettings.colorRules[column].splice(i, 1);
            saveStatSettings();
            renderRules();
          });
        });
      }

      renderRules();

      // Add rule button
      document.querySelector('.add-rule-btn').onclick = () => {
        if (!statSettings.colorRules[column]) {
          statSettings.colorRules[column] = [];
        }
        statSettings.colorRules[column].push({
          op: '>=',
          value: 0,
          color: '#00ff00'
        });
        saveStatSettings();
        renderRules();
      };

      // Reset to default button
      document.getElementById('resetRulesBtn').onclick = () => {
        if (DEFAULT_COLOR_RULES[column]) {
          // Deep copy default rules
          statSettings.colorRules[column] = JSON.parse(JSON.stringify(DEFAULT_COLOR_RULES[column]));
        } else {
          // No defaults for this stat, clear all rules
          statSettings.colorRules[column] = [];
        }
        saveStatSettings();
        renderRules();
      };

      // Close modal
      modal.querySelector('.modal-close').onclick = () => {
        modal.classList.remove('open');
      };
    }

    // Initialize settings
    renderStatLayoutPalette();
    renderStatLayoutSlots();
    renderNicks(); // Initialize Nicks panel list on load

    // Notification modal helper
    function showNotification(message) {
      const modal = document.getElementById('notificationModal');
      const messageEl = document.getElementById('notificationMessage');
      const okBtn = document.getElementById('notificationOkBtn');
      
      messageEl.textContent = message;
      modal.classList.add('open');
      
      const closeModal = () => {
        modal.classList.remove('open');
        okBtn.removeEventListener('click', closeModal);
      };
      
      okBtn.addEventListener('click', closeModal);
    }

    // Add slot button
    const addSlotBtn = document.getElementById('addSlotBtn');
    if (addSlotBtn) {
      addSlotBtn.addEventListener('click', () => {
        if (statSettings.layout.length < 12) {
          statSettings.layout.push(null);
          saveStatSettings();
        } else {
          showNotification('Maximum 12 slots reached');
        }
      });
    }

    // --- Layout Editor Functions ---
    function renderStatLayoutPalette() {
      const palette = document.getElementById('layoutPalette');
      if (!palette) return;
      const used = new Set(statSettings.layout.filter(Boolean));
      // Palette zeigt auch deaktivierte Stats (disabled:true) ausgegraut & nicht draggable
      const stats = Object.keys(STATS)
        .filter(k => !['level','name'].includes(k));
      
      console.log('[DEBUG] renderStatLayoutPalette - Total STATS:', Object.keys(STATS).length);
      console.log('[DEBUG] renderStatLayoutPalette - Filtered stats (no level/name):', stats.length, stats);
      console.log('[DEBUG] renderStatLayoutPalette - Currently used in layout:', Array.from(used));
      
  // In settings palette show human-readable names
  palette.innerHTML = stats.map(k => {
        const def = STATS[k];
        const isUsed = used.has(k);
        const isDisabled = !!def.disabled;
        const draggable = (!isUsed && !isDisabled) ? 'true' : 'false';
        const cls = `stat-pill${isDisabled ? ' disabled' : ''}`;
        const usedAttr = isUsed ? 'data-used="1"' : '';
        const disabledAttr = isDisabled ? 'data-disabled="1" title="Currently unavailable"' : '';
        return `<div class="${cls}" draggable="${draggable}" data-stat="${k}" ${usedAttr} ${disabledAttr}>${def.name}</div>`;
      }).join('');
      
      palette.querySelectorAll('.stat-pill[draggable="true"]').forEach(pill => {
        pill.addEventListener('dragstart', e => {
          e.dataTransfer.setData('text/stat', pill.dataset.stat);
        });
      });
      
      // Allow dropping stats back to palette (removes them from layout)
      palette.addEventListener('dragover', e => {
        e.preventDefault();
        palette.style.backgroundColor = 'rgba(102,234,255,0.08)';
      });
      
      palette.addEventListener('dragleave', () => {
        palette.style.backgroundColor = '';
      });
      
      palette.addEventListener('drop', e => {
        e.preventDefault();
        palette.style.backgroundColor = '';
        
        const sourceSlotIdx = e.dataTransfer.getData('text/sourceSlot');
        if (sourceSlotIdx) {
          // Dragging from a slot to palette - remove it
          const idx = parseInt(sourceSlotIdx);
          statSettings.layout[idx] = null;
          saveStatSettings();
        }
      });
    }
    function renderStatLayoutSlots() {
      const slotsEl = document.getElementById('layoutSlots');
      if (!slotsEl) return;
      const layout = statSettings.layout;
      slotsEl.innerHTML = layout.map((stat, i) => {
        if (!stat) return `<div class="slot" data-slot="${i}" data-empty="1">Empty</div>`;
  // In settings slots show explicit names
  const label = STATS[stat]?.name || stat;
  return `<div class="slot filled" data-slot="${i}" data-stat="${stat}" draggable="true">${label}<button class="slot-remove" title="Remove">×</button></div>`;
      }).join('');
      
      slotsEl.querySelectorAll('.slot').forEach(slot => {
        let dragStartX = 0;
        let dragStartY = 0;
        let isDragging = false;
        
        // Dragstart for filled slots (allows dragging out or swapping)
        if (!slot.dataset.empty) {
          slot.addEventListener('dragstart', e => {
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            isDragging = true;
            const stat = slot.dataset.stat;
            e.dataTransfer.setData('text/stat', stat);
            e.dataTransfer.setData('text/sourceSlot', slot.dataset.slot);
            slot.style.opacity = '0.4';
          });
          
          slot.addEventListener('dragend', e => {
            slot.style.opacity = '1';
            isDragging = false;
          });
        }
        
        slot.addEventListener('dragover', e => {
          e.preventDefault();
          slot.classList.add('drag-over');
        });
        
        slot.addEventListener('dragleave', () => {
          slot.classList.remove('drag-over');
        });
        
        slot.addEventListener('drop', e => {
          e.preventDefault();
          slot.classList.remove('drag-over');
          
          const stat = e.dataTransfer.getData('text/stat');
          const sourceSlotIdx = e.dataTransfer.getData('text/sourceSlot');
          if (!stat) return;
          
          const targetIdx = parseInt(slot.dataset.slot);
          
          // Case 1: Dragging from palette to slot
          if (!sourceSlotIdx) {
            // Remove existing occurrence
            const idxExisting = statSettings.layout.indexOf(stat);
            if (idxExisting !== -1) statSettings.layout[idxExisting] = null;
            // Put into this slot
            statSettings.layout[targetIdx] = stat;
            saveStatSettings();
            return;
          }
          
          // Case 2: Dragging from slot to slot (swap)
          const sourceIdx = parseInt(sourceSlotIdx);
          if (sourceIdx === targetIdx) return; // Same slot, do nothing
          
          // Swap the two slots
          const temp = statSettings.layout[targetIdx];
          statSettings.layout[targetIdx] = statSettings.layout[sourceIdx];
          statSettings.layout[sourceIdx] = temp;
          saveStatSettings();
        });
        
        // Click on filled slot: open color rules (if stat supports it)
        // Only trigger if NOT dragging (detect by minimal movement)
        if (!slot.dataset.empty && slot.dataset.stat) {
          const statKey = slot.dataset.stat;
          let mouseDownX = 0;
          let mouseDownY = 0;
          
          slot.addEventListener('mousedown', e => {
            // Ignore if clicking remove button
            if (e.target.closest('.slot-remove')) return;
            mouseDownX = e.clientX;
            mouseDownY = e.clientY;
          });
          
          if (STATS[statKey]?.colorRules) {
            slot.style.cursor = 'pointer';
            slot.addEventListener('click', e => {
              // Ignore click if user clicked remove button
              if (e.target.closest('.slot-remove')) return;
              
              // Calculate movement since mousedown
              const deltaX = Math.abs(e.clientX - mouseDownX);
              const deltaY = Math.abs(e.clientY - mouseDownY);
              
              // Only treat as click if movement was minimal (< 5px)
              if (deltaX < 5 && deltaY < 5) {
                showColorRules(statKey);
              }
            });
          }
        }
        
        const removeBtn = slot.querySelector('.slot-remove');
        if (removeBtn) {
          removeBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // prevent triggering slot click
            const idx = parseInt(slot.dataset.slot);
            statSettings.layout[idx] = null;
            saveStatSettings();
          });
        }
      });
    }

    // --- Keyboard Shortcuts
    const ACTIONS = [
      { id: 'toggleOverlay', label: 'Hide or show' },
      { id: 'refreshAll', label: 'Refresh all players' },
      { id: 'clearAll', label: 'Remove all players' },
      { id: 'toggleClickThrough', label: 'Toggle click-through' }
    ];

    const DEFAULT_SHORTCUTS = {
      toggleOverlay: 'F9',
      refreshAll: '',
      clearAll: 'F8',
      toggleClickThrough: ''
    };

    let shortcuts = JSON.parse(localStorage.getItem('shortcuts') || JSON.stringify(DEFAULT_SHORTCUTS));

    function saveShortcuts() {
      localStorage.setItem('shortcuts', JSON.stringify(shortcuts));
      // Inform main to (re)register
      ipcRenderer.invoke('shortcuts:register', shortcuts);
    }

    function renderShortcuts() {
      const grid = document.getElementById('kbGrid');
      if (!grid) return;
      grid.innerHTML = ACTIONS.map(a => `
        <div class="kb-row" data-action="${a.id}">
          <div class="kb-action">${a.label}</div>
          <div class="kb-input" tabindex="0">${shortcuts[a.id] || '—'}</div>
        </div>
      `).join('');

      grid.querySelectorAll('.kb-input').forEach(inputEl => {
        inputEl.addEventListener('click', () => startListen(inputEl));
        inputEl.addEventListener('keydown', (e) => startListen(inputEl, e));
      });
    }

    function startListen(inputEl, evt) {
      const row = inputEl.closest('.kb-row');
      const action = row.getAttribute('data-action');
      inputEl.classList.add('listening');
      inputEl.textContent = 'Press key…';

      const onKey = (e) => {
        e.preventDefault(); e.stopPropagation();
        // ESC clears the shortcut (unassigned)
        if (e.key === 'Escape') {
          shortcuts[action] = '';
          inputEl.textContent = '—';
          inputEl.classList.remove('listening');
          window.removeEventListener('keydown', onKey, true);
          saveShortcuts();
          return;
        }
        const acc = toAccelerator(e);
        shortcuts[action] = acc;
        inputEl.textContent = acc || '—';
        inputEl.classList.remove('listening');
        window.removeEventListener('keydown', onKey, true);
        saveShortcuts();
      };
      window.addEventListener('keydown', onKey, true);
    }

    function toAccelerator(e) {
      // Allow only F-keys or simple combos
      const parts = [];
      if (e.ctrlKey) parts.push('Ctrl');
      if (e.shiftKey) parts.push('Shift');
      if (e.altKey) parts.push('Alt');
      const k = e.key;
      let key = '';
      if (/^F\d{1,2}$/i.test(k)) key = k.toUpperCase();
      else if (k.length === 1) key = k.toUpperCase();
      else if (k === 'Escape') key = 'Esc';
      else if (k === ' ') key = 'Space';
      else return '';
      return [...parts, key].join('+');
    }

    // initial render and register
    renderShortcuts();
    ipcRenderer.invoke('shortcuts:register', shortcuts);

    // --- Appearance Settings
    const defaultAppearance = {
      opacity: 0.78,
      fontSize: 14,
      alwaysOnTop: true,
      autoResize: false,
      bgColor: '#14141c' // matches rgba(20,20,28,alpha)
    };

    let appearance = JSON.parse(localStorage.getItem('appearanceSettings') || JSON.stringify(defaultAppearance));

    function saveAppearance() {
      localStorage.setItem('appearanceSettings', JSON.stringify(appearance));
    }

    function hexToRgb(hex) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (!m) return { r: 20, g: 20, b: 28 };
      return { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) };
    }

    function applyAppearance() {
      const { r,g,b } = hexToRgb(appearance.bgColor);
      const rgba = `rgba(${r},${g},${b},${appearance.opacity})`;
      document.documentElement.style.setProperty('--bg', rgba);
      document.documentElement.style.setProperty('--table-font-size', appearance.fontSize + 'px');
      // also set body background directly to ensure immediate effect
      document.body && (document.body.style.background = rgba);
      // sync always-on-top with main
      ipcRenderer.invoke('window:setAlwaysOnTop', !!appearance.alwaysOnTop);
      // Update UI labels
      const ov = document.getElementById('opacityValue'); if (ov) ov.textContent = Math.round(appearance.opacity*100)+'%';
      const fv = document.getElementById('fontSizeValue'); if (fv) fv.textContent = appearance.fontSize+'px';
    }

    // Bind inputs
    const opacityRange = document.getElementById('opacityRange');
    const fontSizeRange = document.getElementById('fontSizeRange');
    const alwaysOnTopToggle = document.getElementById('alwaysOnTopToggle');
    const autoResizeToggle = document.getElementById('autoResizeToggle');
    const bgColorInput = document.getElementById('bgColorInput');

    if (opacityRange) {
      opacityRange.value = String(appearance.opacity);
      opacityRange.addEventListener('input', () => {
        appearance.opacity = Number(opacityRange.value);
        saveAppearance();
        applyAppearance();
      });
    }

    if (fontSizeRange) {
      fontSizeRange.value = String(appearance.fontSize);
      fontSizeRange.addEventListener('input', () => {
        appearance.fontSize = parseInt(fontSizeRange.value,10);
        saveAppearance();
        applyAppearance();
      });
    }

    if (alwaysOnTopToggle) {
      alwaysOnTopToggle.checked = !!appearance.alwaysOnTop;
      alwaysOnTopToggle.addEventListener('change', () => {
        appearance.alwaysOnTop = !!alwaysOnTopToggle.checked;
        saveAppearance();
        applyAppearance();
      });
    }

    if (autoResizeToggle) {
      autoResizeToggle.checked = !!appearance.autoResize;
      autoResizeToggle.addEventListener('change', () => {
        appearance.autoResize = !!autoResizeToggle.checked;
        saveAppearance();
        updateOverlaySize();
      });
    }

    if (bgColorInput) {
      bgColorInput.value = appearance.bgColor;
      bgColorInput.addEventListener('input', () => {
        appearance.bgColor = bgColorInput.value;
        saveAppearance();
        applyAppearance();
      });
    }

    // Apply on load
    applyAppearance();

    // --- Basic Settings
    const defaultBasic = {
      logFile: 'badlion', // selected client key OR 'custom'
      customLogPath: '', // manual path if logFile === 'custom'
      username: '',
      lastDetected: { client: '', path: '' }
    };

    let basicSettings = JSON.parse(localStorage.getItem('basicSettings') || JSON.stringify(defaultBasic));

    function saveBasicSettings(opts) {
      const options = Object.assign({ propagateUsername: true }, opts);
      localStorage.setItem('basicSettings', JSON.stringify(basicSettings));
      console.log('Basic settings saved:', basicSettings);
      updateSidebarUsername();
      // Ensure username entry exists when set
      if (basicSettings.username && basicSettings.username.trim()) {
        addPlayer(basicSettings.username.trim(), 'username');
      }
    }

      function updateSidebarUsername() {
        const sidebarUsernameEl = document.getElementById('sidebarUsername');
        if (sidebarUsernameEl) {
          sidebarUsernameEl.textContent = basicSettings.username || 'username';
        }
      }

    // Bind Basic inputs
    // Client selection elements
    const clientGrid = document.getElementById('clientSelectGrid');
    const clientStatusEl = document.getElementById('clientStatus');
    const autoDetectBtn = document.getElementById('autoDetectBtn');
    const customRow = document.getElementById('customPathRow');
    const customPathInput = document.getElementById('customLogPathInput');
    const applyCustomBtn = document.getElementById('applyCustomPathBtn');
    const usernameInput = document.getElementById('usernameInput');

    function updateClientButtons() {
      if (!clientGrid) return;
      const selected = basicSettings.logFile || 'badlion';
      clientGrid.querySelectorAll('button.client-btn').forEach(btn => {
        const key = btn.getAttribute('data-client');
        if (key === selected) btn.classList.add('active'); else btn.classList.remove('active');
        // mark detected (if different from selected and not custom)
        if (basicSettings.lastDetected?.client === key && key !== selected) {
          btn.setAttribute('data-detected','1');
        } else {
          btn.removeAttribute('data-detected');
        }
      });
      if (selected === 'custom') {
        if (customRow) customRow.style.display = 'flex';
      } else {
        if (customRow) customRow.style.display = 'none';
      }
    }

    function updateClientStatus(extra) {
      if (!clientStatusEl) return;
      clientStatusEl.classList.remove('warn','ok');
      let line = '';
      const sel = basicSettings.logFile;
      if (sel === 'custom') {
  line = `Custom path active: ${basicSettings.customLogPath || '(empty)'}`;
      } else {
  line = `Active client: ${sel}`;
      }
      if (basicSettings.lastDetected?.client && basicSettings.lastDetected.client !== sel) {
  line += ` • Last detected: ${basicSettings.lastDetected.client}`;
        clientStatusEl.classList.add('warn');
      } else if (basicSettings.lastDetected?.client === sel) {
        clientStatusEl.classList.add('ok');
      }
      if (extra) line += ` • ${extra}`;
      clientStatusEl.textContent = line;
    }

    if (clientGrid) {
      clientGrid.addEventListener('click', (e) => {
        const target = e.target;
        if (!(target instanceof HTMLElement) || !target.classList.contains('client-btn')) return;
        const key = target.getAttribute('data-client');
        if (!key) return;
        basicSettings.logFile = key;
        saveBasicSettings();
        updateClientButtons();
        updateClientStatus();
        try {
          if (key === 'custom') {
            // do nothing yet; wait for Apply
          } else {
            require('electron').ipcRenderer.send('set:client', key);
          }
        } catch {}
      });
      updateClientButtons();
      updateClientStatus();
    }

    if (applyCustomBtn && customPathInput) {
      applyCustomBtn.addEventListener('click', () => {
        const p = (customPathInput.value || '').trim();
        basicSettings.customLogPath = p;
        saveBasicSettings();
        updateClientStatus();
        if (basicSettings.logFile === 'custom' && p) {
          try { require('electron').ipcRenderer.send('set:logPath', p); } catch {}
        }
      });
    }

    if (autoDetectBtn) {
      autoDetectBtn.addEventListener('click', async () => {
        try {
          const res = await require('electron').ipcRenderer.invoke('chat:autoDetect');
          if (Array.isArray(res) && res.length === 2) {
            basicSettings.lastDetected = { client: res[0], path: res[1] };
            // If user hasn't manually chosen custom, adopt detected client
            if (basicSettings.logFile !== 'custom') {
              basicSettings.logFile = res[0];
              try { require('electron').ipcRenderer.send('set:client', res[0]); } catch {}
            }
            saveBasicSettings();
            updateClientButtons();
            updateClientStatus('Auto-detect succeeded');
          } else {
            updateClientStatus('No logs found');
          }
        } catch (err) {
          updateClientStatus('Auto-detect error');
        }
      });
    }

    // Listen for backend log path changes to reflect status
    try {
      require('electron').ipcRenderer.on('chat:logPathChanged', (_e, payload) => {
        if (payload?.client && basicSettings.logFile !== 'custom') {
          // Sync chosen client if backend auto switched due to detection
          if (!basicSettings.logFile) basicSettings.logFile = payload.client;
        }
  updateClientStatus('Path switched');
      });
    } catch {}

    if (usernameInput) {
      usernameInput.value = basicSettings.username || '';
      usernameInput.addEventListener('input', () => {
        const prev = (basicSettings.username || '').trim();
        const next = (usernameInput.value || '').trim();
        if (prev && prev.toLowerCase() !== next.toLowerCase()) {
          // Remove old username source (but keep row if other sources exist)
          removePlayerSource(prev, 'username');
        }
        basicSettings.username = next;
        localStorage.setItem('username', next); // For session tracking (keep for compatibility)
        saveBasicSettings();
        
        // Start new session if username changed and we have a valid username
        if (next && next !== sessionUsername) {
          setTimeout(() => startSession(next), 100); // Small delay to ensure save completes
        }
      });
      
      // Start session on app load if username exists (delayed)
      const savedUsername = basicSettings.username || '';
      if (savedUsername) {
        console.log('Found saved username on app load:', savedUsername);
        localStorage.setItem('username', savedUsername);
        // Wait a bit for IPC to be ready
        setTimeout(() => {
          if (window.ipcRenderer) {
            console.log('Starting session on app load for:', savedUsername);
            startSession(savedUsername);
          } else {
            console.log('IPC not ready, session start skipped');
          }
        }, 1000);
      }
    }

    // API Management
    const apiKeyInput = document.getElementById('apiKeyInput');
    const pasteApiKeyBtn = document.getElementById('pasteApiKeyBtn');
    const testApiKeyBtn = document.getElementById('testApiKeyBtn');
    const fallbackKeyToggle = document.getElementById('fallbackKeyToggle');
    const clearCacheBtn = document.getElementById('clearCacheBtn');
    const refreshApiStatusBtn = document.getElementById('refreshApiStatusBtn');
    const hypixelApiLink = document.getElementById('hypixelApiLink');
    const backendStatus = document.getElementById('backendStatus');
    const userKeyStatus = document.getElementById('userKeyStatus');

    // Load API settings
    const apiSettings = {
      userApiKey: localStorage.getItem('nebula-api-key') || '',
      useFallback: localStorage.getItem('nebula-use-fallback') !== 'false'
    };

    if (apiKeyInput) {
      apiKeyInput.value = apiSettings.userApiKey;
      apiKeyInput.addEventListener('change', () => {
        apiSettings.userApiKey = apiKeyInput.value.trim();
        localStorage.setItem('nebula-api-key', apiSettings.userApiKey);
        updateApiStatus();
      });
    }

    if (fallbackKeyToggle) {
      fallbackKeyToggle.checked = apiSettings.useFallback;
      fallbackKeyToggle.addEventListener('change', () => {
        apiSettings.useFallback = fallbackKeyToggle.checked;
        localStorage.setItem('nebula-use-fallback', apiSettings.useFallback.toString());
        window.ipcRenderer.invoke('api:toggleFallback', apiSettings.useFallback);
      });
    }

    if (pasteApiKeyBtn) {
      pasteApiKeyBtn.addEventListener('click', async () => {
        try {
          const text = await navigator.clipboard.readText();
          if (text && text.length === 36) {
            apiKeyInput.value = text.trim();
            apiSettings.userApiKey = text.trim();
            localStorage.setItem('nebula-api-key', apiSettings.userApiKey);
            showNotification('API key pasted from clipboard', 'success');
            updateApiStatus();
          } else {
            showNotification('Invalid API key format in clipboard', 'error');
          }
        } catch (err) {
          showNotification('Could not access clipboard', 'error');
        }
      });
    }

    if (testApiKeyBtn) {
      testApiKeyBtn.addEventListener('click', async () => {
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
          showNotification('Please enter an API key first', 'warning');
          return;
        }

        testApiKeyBtn.textContent = 'Testing...';
        testApiKeyBtn.disabled = true;

        try {
          const result = await window.ipcRenderer.invoke('api:setUserKey', apiKey);
          if (result.success) {
            showNotification('API key is valid!', 'success');
            apiSettings.userApiKey = apiKey;
            localStorage.setItem('nebula-api-key', apiKey);
            updateApiStatus();
          } else {
            showNotification(result.error || 'API key validation failed', 'error');
          }
        } catch (err) {
          showNotification('Failed to test API key', 'error');
        } finally {
          testApiKeyBtn.textContent = 'Test';
          testApiKeyBtn.disabled = false;
        }
      });
    }

    if (clearCacheBtn) {
      clearCacheBtn.addEventListener('click', async () => {
        clearCacheBtn.textContent = 'Clearing...';
        clearCacheBtn.disabled = true;

        try {
          await window.ipcRenderer.invoke('api:clearCache');
          showNotification('API cache cleared', 'success');
        } catch (err) {
          showNotification('Failed to clear cache', 'error');
        } finally {
          clearCacheBtn.textContent = 'Clear Cache';
          clearCacheBtn.disabled = false;
        }
      });
    }

    if (refreshApiStatusBtn) {
      refreshApiStatusBtn.addEventListener('click', () => {
        updateApiStatus();
      });
    }

    if (hypixelApiLink) {
      hypixelApiLink.addEventListener('click', (e) => {
        e.preventDefault();
        window.ipcRenderer.invoke('external:open', 'https://developer.hypixel.net/');
      });
    }

    // Update API status display
    async function updateApiStatus() {
      try {
        const status = await window.ipcRenderer.invoke('api:getStatus');
        
        if (backendStatus) {
          if (status.backendAvailable) {
            if (status.backendThrottled) {
              backendStatus.innerHTML = '<span style="color:#fbbf24;">●</span> Backend available (rate limited)';
            } else {
              backendStatus.innerHTML = '<span style="color:#10b981;">●</span> Backend available';
            }
          } else {
            backendStatus.innerHTML = '<span style="color:#ef4444;">●</span> Backend unavailable - using fallback';
          }
        }

        if (userKeyStatus) {
          if (status.config.hasUserKey) {
            if (status.userKeyValid) {
              userKeyStatus.innerHTML = '<span style="color:#10b981;">●</span> User API key valid';
            } else {
              userKeyStatus.innerHTML = '<span style="color:#ef4444;">●</span> User API key invalid or expired';
            }
          } else {
            userKeyStatus.innerHTML = '<span style="color:#9ca3af;">●</span> No user API key configured';
          }
        }

        // Show overall system status
        const hasWorkingApi = (status.backendAvailable && !status.backendThrottled) || 
                             (status.config.useFallback && status.userKeyValid);
        
        if (!hasWorkingApi && status.hypixelApiDown) {
          showNotification('Hypixel API appears to be down', 'warning');
        }

      } catch (err) {
        console.error('Failed to update API status:', err);
      }
    }

    // Initialize API status
    updateApiStatus();
    
    // Auto-refresh status every 30 seconds
    setInterval(updateApiStatus, 30000);

    // Initialize sidebar username on load and ensure presence in list
    updateSidebarUsername();
      if (basicSettings.username && basicSettings.username.trim()) {
        addPlayer(basicSettings.username.trim(), 'username');
        renderTable();
      }
      // Send initial username to main on load
      try { require('electron').ipcRenderer.send('set:username', basicSettings.username || ''); } catch (e) {}

    // --- Sources Settings
    const defaultSources = {
      game: {
        enabled: true,
        addFromWho: true,
        addFromChat: true,
        removeOnDeath: true,
        removeOnReconnect: true,
        removeOnServerChange: true
      },
      party: {
        enabled: true,
        removeOnMemberLeave: true,
        removeAllOnLeaveOrDisband: true,
        showInviteTemp: true,
        autoRefreshServerChange: false, // plus placeholder
        autoRefreshGameEnd: false // plus placeholder
      },
      partyInvites: {
        enabled: true
      },
      chat: {
        enabled: true,
        removeOnServerChange: true,
        addOnMention: true,
        strings: []
      },
      guild: {
        enabled: true,
        removeOnServerChange: true,
        onlineOnly: true
      },
      manual: {
        enabled: true,
        clearOnGameStart: false
      }
    };

    // Load saved settings and merge with defaults to ensure all keys exist
    let sourcesSettings = JSON.parse(localStorage.getItem('sourcesSettings') || JSON.stringify(defaultSources));
    // Merge defaults (ensures new settings fields exist even if saved data is old)
    sourcesSettings = {
      game: { ...defaultSources.game, ...(sourcesSettings.game || {}) },
      party: { ...defaultSources.party, ...(sourcesSettings.party || {}) },
      partyInvites: { ...defaultSources.partyInvites, ...(sourcesSettings.partyInvites || {}) },
      chat: { ...defaultSources.chat, ...(sourcesSettings.chat || {}) },
      guild: { ...defaultSources.guild, ...(sourcesSettings.guild || {}) },
      manual: { ...defaultSources.manual, ...(sourcesSettings.manual || {}) }
    };

    function saveSourcesSettings() {
      localStorage.setItem('sourcesSettings', JSON.stringify(sourcesSettings));
      console.log('Sources settings saved:', sourcesSettings);
    }

    // Helper function to toggle subsection disabled state
    function toggleSubsectionEnabled(containerId, enabled) {
      const container = document.getElementById(containerId);
      if (container) {
        const inputs = container.querySelectorAll('input, button');
        inputs.forEach(input => {
          input.disabled = !enabled;
        });
        container.style.opacity = enabled ? '1' : '0.5';
        container.style.pointerEvents = enabled ? 'auto' : 'none';
      }
    }

    // Bind Sources inputs
    const sourceGameToggle = document.getElementById('sourceGameToggle');
  const gameAddFromWho = document.getElementById('gameAddFromWho');
    const gameAddFromChat = document.getElementById('gameAddFromChat');
    const gameRemoveOnDeath = document.getElementById('gameRemoveOnDeath');
    const gameRemoveOnDisconnect = document.getElementById('gameRemoveOnDisconnect');
    const gameRemoveOnServerChange = document.getElementById('gameRemoveOnServerChange');
    
    const sourcePartyToggle = document.getElementById('sourcePartyToggle');
  const partyRemoveOnMemberLeave = document.getElementById('partyRemoveOnMemberLeave');
  const partyRemoveAllOnLeaveOrDisband = document.getElementById('partyRemoveAllOnLeaveOrDisband');
  const partyShowInviteTemp = document.getElementById('partyShowInviteTemp');
  const partyRefreshServerChange = document.getElementById('partyRefreshServerChange');
  const partyRefreshGameEnd = document.getElementById('partyRefreshGameEnd');
    
    const sourcePartyInvitesToggle = document.getElementById('sourcePartyInvitesToggle');
    
    const sourceChatToggle = document.getElementById('sourceChatToggle');
    const chatRemoveOnServerChange = document.getElementById('chatRemoveOnServerChange');
  const chatAddOnMention = document.getElementById('chatAddOnMention');
  const chatStringList = document.getElementById('chatStringList');
  const addChatStringBtn = document.getElementById('addChatString');
  // Manual source elements
  const sourceManualToggle = document.getElementById('sourceManualToggle');
  const manualClearOnGameStart = document.getElementById('manualClearOnGameStart');

    if (sourceGameToggle) {
      sourceGameToggle.checked = sourcesSettings.game.enabled;
      toggleSubsectionEnabled('gameSourceOptions', sourcesSettings.game.enabled);
      sourceGameToggle.addEventListener('change', () => {
        sourcesSettings.game.enabled = sourceGameToggle.checked;
        toggleSubsectionEnabled('gameSourceOptions', sourcesSettings.game.enabled);
        saveSourcesSettings();
      });
    }

    if (gameAddFromChat) {
      gameAddFromChat.checked = sourcesSettings.game.addFromChat;
      gameAddFromChat.addEventListener('change', () => {
        sourcesSettings.game.addFromChat = gameAddFromChat.checked;
        saveSourcesSettings();
      });
    }
    if (gameAddFromWho) {
      gameAddFromWho.checked = sourcesSettings.game.addFromWho;
      gameAddFromWho.addEventListener('change', () => {
        sourcesSettings.game.addFromWho = gameAddFromWho.checked;
        saveSourcesSettings();
      });
    }

    if (gameRemoveOnDeath) {
      gameRemoveOnDeath.checked = sourcesSettings.game.removeOnDeath;
      gameRemoveOnDeath.addEventListener('change', () => {
        sourcesSettings.game.removeOnDeath = gameRemoveOnDeath.checked;
        saveSourcesSettings();
      });
    }

    if (gameRemoveOnDisconnect) {
      gameRemoveOnDisconnect.checked = sourcesSettings.game.removeOnReconnect;
      gameRemoveOnDisconnect.addEventListener('change', () => {
        sourcesSettings.game.removeOnReconnect = gameRemoveOnDisconnect.checked;
        saveSourcesSettings();
      });
    }

    if (gameRemoveOnServerChange) {
      gameRemoveOnServerChange.checked = sourcesSettings.game.removeOnServerChange;
      gameRemoveOnServerChange.addEventListener('change', () => {
        sourcesSettings.game.removeOnServerChange = gameRemoveOnServerChange.checked;
        saveSourcesSettings();
      });
    }

    if (sourcePartyToggle) {
      sourcePartyToggle.checked = sourcesSettings.party.enabled;
      toggleSubsectionEnabled('partySourceOptions', sourcesSettings.party.enabled);
      // Also control party invites toggle
      if (sourcePartyInvitesToggle) {
        sourcePartyInvitesToggle.disabled = !sourcesSettings.party.enabled;
      }
      sourcePartyToggle.addEventListener('change', () => {
        sourcesSettings.party.enabled = sourcePartyToggle.checked;
        toggleSubsectionEnabled('partySourceOptions', sourcesSettings.party.enabled);
        // Also control party invites toggle
        if (sourcePartyInvitesToggle) {
          sourcePartyInvitesToggle.disabled = !sourcesSettings.party.enabled;
        }
        saveSourcesSettings();
      });
    }

    if (partyRemoveOnMemberLeave) {
      partyRemoveOnMemberLeave.checked = !!sourcesSettings.party.removeOnMemberLeave;
      partyRemoveOnMemberLeave.addEventListener('change', () => {
        sourcesSettings.party.removeOnMemberLeave = partyRemoveOnMemberLeave.checked;
        saveSourcesSettings();
      });
    }

    if (partyRemoveAllOnLeaveOrDisband) {
      partyRemoveAllOnLeaveOrDisband.checked = !!sourcesSettings.party.removeAllOnLeaveOrDisband;
      partyRemoveAllOnLeaveOrDisband.addEventListener('change', () => {
        sourcesSettings.party.removeAllOnLeaveOrDisband = partyRemoveAllOnLeaveOrDisband.checked;
        saveSourcesSettings();
      });
    }

    if (partyShowInviteTemp) {
      partyShowInviteTemp.checked = !!sourcesSettings.party.showInviteTemp;
      partyShowInviteTemp.addEventListener('change', () => {
        sourcesSettings.party.showInviteTemp = partyShowInviteTemp.checked;
        saveSourcesSettings();
      });
    }

    // Party auto-refresh options
    if (partyRefreshServerChange) {
      partyRefreshServerChange.checked = !!sourcesSettings.party.autoRefreshServerChange;
      partyRefreshServerChange.addEventListener('change', () => {
        sourcesSettings.party.autoRefreshServerChange = partyRefreshServerChange.checked;
        saveSourcesSettings();
      });
    }
    if (partyRefreshGameEnd) {
      partyRefreshGameEnd.checked = !!sourcesSettings.party.autoRefreshGameEnd;
      partyRefreshGameEnd.addEventListener('change', () => {
        sourcesSettings.party.autoRefreshGameEnd = partyRefreshGameEnd.checked;
        saveSourcesSettings();
      });
    }

    if (sourcePartyInvitesToggle) {
      sourcePartyInvitesToggle.checked = sourcesSettings.partyInvites.enabled;
      sourcePartyInvitesToggle.addEventListener('change', () => {
        sourcesSettings.partyInvites.enabled = sourcePartyInvitesToggle.checked;
        saveSourcesSettings();
      });
    }

    if (sourceChatToggle) {
      sourceChatToggle.checked = sourcesSettings.chat.enabled;
      toggleSubsectionEnabled('chatSourceOptions', sourcesSettings.chat.enabled);
      sourceChatToggle.addEventListener('change', () => {
        sourcesSettings.chat.enabled = sourceChatToggle.checked;
        toggleSubsectionEnabled('chatSourceOptions', sourcesSettings.chat.enabled);
        saveSourcesSettings();
      });
    }

    if (chatRemoveOnServerChange) {
      chatRemoveOnServerChange.checked = sourcesSettings.chat.removeOnServerChange;
      chatRemoveOnServerChange.addEventListener('change', () => {
        sourcesSettings.chat.removeOnServerChange = chatRemoveOnServerChange.checked;
        saveSourcesSettings();
      });
    }

    if (chatAddOnMention) {
      chatAddOnMention.checked = sourcesSettings.chat.addOnMention;
      chatAddOnMention.addEventListener('change', () => {
        sourcesSettings.chat.addOnMention = chatAddOnMention.checked;
        saveSourcesSettings();
      });
    }

    // Guild bindings
  const sourceGuildToggle = document.getElementById('sourceGuildToggle');
    const guildRemoveOnServerChange = document.getElementById('guildRemoveOnServerChange');
    const guildOnlineOnly = document.getElementById('guildOnlineOnly');

    if (sourceGuildToggle) {
      sourceGuildToggle.checked = !!sourcesSettings.guild?.enabled;
      toggleSubsectionEnabled('guildSourceOptions', sourcesSettings.guild.enabled);
      sourceGuildToggle.addEventListener('change', () => {
        if (!sourcesSettings.guild) sourcesSettings.guild = {};
        sourcesSettings.guild.enabled = sourceGuildToggle.checked;
        toggleSubsectionEnabled('guildSourceOptions', sourcesSettings.guild.enabled);
        saveSourcesSettings();
      });
    }

    // Removed guildAddFromList toggle; guild additions are implicit when guild source is enabled.

    if (guildRemoveOnServerChange) {
      guildRemoveOnServerChange.checked = !!sourcesSettings.guild?.removeOnServerChange;
      guildRemoveOnServerChange.addEventListener('change', () => {
        if (!sourcesSettings.guild) sourcesSettings.guild = {};
        sourcesSettings.guild.removeOnServerChange = guildRemoveOnServerChange.checked;
        saveSourcesSettings();
      });
    }

    if (guildOnlineOnly) {
      guildOnlineOnly.checked = !!sourcesSettings.guild?.onlineOnly;
      guildOnlineOnly.addEventListener('change', () => {
        if (!sourcesSettings.guild) sourcesSettings.guild = {};
        sourcesSettings.guild.onlineOnly = guildOnlineOnly.checked;
        saveSourcesSettings();
      });
    }

    // Manual bindings
    if (sourceManualToggle) {
      sourceManualToggle.checked = !!sourcesSettings.manual.enabled;
      toggleSubsectionEnabled('manualSourceOptions', sourcesSettings.manual.enabled);
      sourceManualToggle.addEventListener('change', () => {
        sourcesSettings.manual.enabled = sourceManualToggle.checked;
        toggleSubsectionEnabled('manualSourceOptions', sourcesSettings.manual.enabled);
        saveSourcesSettings();
      });
    }
    if (manualClearOnGameStart) {
      manualClearOnGameStart.checked = !!sourcesSettings.manual.clearOnGameStart;
      manualClearOnGameStart.addEventListener('change', () => {
        sourcesSettings.manual.clearOnGameStart = manualClearOnGameStart.checked;
        saveSourcesSettings();
      });
    }

    function renderChatStrings() {
      if (!chatStringList) return;
      chatStringList.innerHTML = '';
      (sourcesSettings.chat.strings || []).forEach((str, idx) => {
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '6px';
        row.innerHTML = `
          <input type="text" value="${str.replace(/"/g,'&quot;')}" data-idx="${idx}" style="flex:1;padding:6px 8px;background:var(--row);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:var(--text);font-size:12px;" />
          <button type="button" data-remove="${idx}" style="background:rgba(255,255,255,0.08);border:0;color:var(--text);padding:6px 10px;border-radius:6px;cursor:pointer;font-size:11px;">Remove</button>`;
        chatStringList.appendChild(row);
      });
    }

    function syncChatStringsFromDOM() {
      if (!chatStringList) return;
      const inputs = Array.from(chatStringList.querySelectorAll('input[type="text"]'));
      const values = [];
      for (var j=0;j<inputs.length;j++) {
        var el = inputs[j];
        var val = el && el.value != null ? String(el.value).trim() : '';
        if (val.length>0) values.push(val);
      }
      sourcesSettings.chat.strings = values;
      saveSourcesSettings();
    }

    if (addChatStringBtn) {
      addChatStringBtn.addEventListener('click', () => {
        sourcesSettings.chat.strings.push('');
        renderChatStrings();
        saveSourcesSettings();
      });
    }

    if (chatStringList) {
      chatStringList.addEventListener('input', function(e) {
        var tgt = e && e.target ? e.target : null;
        if (tgt && tgt.tagName === 'INPUT') {
          syncChatStringsFromDOM();
        }
      });
      chatStringList.addEventListener('click', function(e) {
        var t = e && e.target ? e.target : null;
        if (t && t.dataset && t.dataset.remove) {
          var idx = parseInt(t.dataset.remove, 10);
          sourcesSettings.chat.strings.splice(idx,1);
          renderChatStrings();
          saveSourcesSettings();
        }
      });
    }

    // Initial render for chat strings
    renderChatStrings();

    // Settings submenu toggle logic (LEGACY CODE - NO LONGER USED)
    // This code is for the old collapsible submenu that was removed.
    // Keeping it to avoid breaking anything, but it should not run.
    const settingsBtn = document.querySelector('.nav-item[data-panel="settings"]');
    const settingsSubmenu = document.querySelector('.settings-submenu');

    function openSettingsSubmenu(initialSection) {
      // Legacy - no longer used
      return;
    }

    function closeSettingsSubmenu() {
      // Legacy - no longer used
      return;
    }

    function showSettingsSection(section) {
      // Legacy - no longer used
      return;
    }

    // Remove legacy settings persistence keys
    localStorage.removeItem('settingsExpanded');
    localStorage.removeItem('activeSettingsSection');

    // ==========================================
    // Profile & Discord Authentication
    // ==========================================

    // ==========================================
    // Firebase Cloud Sync (via Main Process)
    // ==========================================

    // Firebase is now handled in main process to avoid CSP issues
    let firebaseInitialized = false;
    
    // Check if Firebase is available
    async function checkFirebase() {
      try {
        const config = await ipcRenderer.invoke('firebase:getConfig');
        firebaseInitialized = !!config.apiKey;
        console.log('[Firebase] Available:', firebaseInitialized);
        return firebaseInitialized;
      } catch (error) {
        console.error('[Firebase] Check failed:', error);
        return false;
      }
    }

    // Cloud Sync Functions (now using IPC)
    async function uploadUserSettings(userId) {
      try {
        // Collect all local settings
        const settings = {
          nicks: JSON.parse(localStorage.getItem('nicks') || '[]'),
          appearanceSettings: JSON.parse(localStorage.getItem('appearanceSettings') || '{}'),
          shortcuts: JSON.parse(localStorage.getItem('shortcuts') || '[]'),
          basicSettings: JSON.parse(localStorage.getItem('basicSettings') || '{}'),
          statSettings: JSON.parse(localStorage.getItem('statSettings') || '{}'),
          sourcesSettings: JSON.parse(localStorage.getItem('sourcesSettings') || '{}'),
          nickDisplayMode: localStorage.getItem('nickDisplayMode') || 'nick',
        };
        
        // Upload via main process
        const result = await ipcRenderer.invoke('firebase:upload', userId, settings);
        
        if (result.error) {
          throw new Error(result.error);
        }
        
        // Update local sync timestamp
        localStorage.setItem('lastSyncTime', Date.now().toString());
        
        console.log('[Firebase] Settings uploaded successfully');
        return { success: true };
      } catch (error) {
        console.error('[Firebase] Upload failed:', error);
        throw error;
      }
    }

    async function downloadUserSettings(userId) {
      try {
        const result = await ipcRenderer.invoke('firebase:download', userId);
        
        if (result.error) {
          throw new Error(result.error);
        }
        
        if (!result.data) {
          console.log('[Firebase] No cloud settings found');
          return { success: true, data: null };
        }
        
        const settings = result.data;
        
        // Apply settings to localStorage
        if (settings.nicks) localStorage.setItem('nicks', JSON.stringify(settings.nicks));
        if (settings.appearanceSettings) localStorage.setItem('appearanceSettings', JSON.stringify(settings.appearanceSettings));
        if (settings.shortcuts) localStorage.setItem('shortcuts', JSON.stringify(settings.shortcuts));
        if (settings.basicSettings) localStorage.setItem('basicSettings', JSON.stringify(settings.basicSettings));
        if (settings.statSettings) localStorage.setItem('statSettings', JSON.stringify(settings.statSettings));
        if (settings.sourcesSettings) localStorage.setItem('sourcesSettings', JSON.stringify(settings.sourcesSettings));
        if (settings.nickDisplayMode) localStorage.setItem('nickDisplayMode', settings.nickDisplayMode);
        
        // Update local sync timestamp
        localStorage.setItem('lastSyncTime', Date.now().toString());
        
        console.log('[Firebase] Settings downloaded successfully');
        return { success: true, data: settings, timestamp: result.timestamp };
      } catch (error) {
        console.error('[Firebase] Download failed:', error);
        throw error;
      }
    }

    async function syncUserSettings(userId, direction = 'auto') {
      if (!userId) {
        throw new Error('User not logged in');
      }
      
      try {
        if (direction === 'upload') {
          return await uploadUserSettings(userId);
        } else if (direction === 'download') {
          const result = await downloadUserSettings(userId);
          if (result.data) {
            // Reload page to apply all settings
            location.reload();
          }
          return result;
        } else {
          // Auto: Check which is newer
          const downloadResult = await ipcRenderer.invoke('firebase:download', userId);
          
          if (downloadResult.error) {
            throw new Error(downloadResult.error);
          }
          
          const lastLocalSync = parseInt(localStorage.getItem('lastSyncTime') || '0');
          
          if (!downloadResult.data) {
            // No cloud data, upload local
            return await uploadUserSettings(userId);
          }
          
          const cloudTimestamp = downloadResult.timestamp || 0;
          
          if (cloudTimestamp > lastLocalSync) {
            // Cloud is newer, download
            console.log('[Firebase] Cloud settings are newer, downloading...');
            const result = await downloadUserSettings(userId);
            if (result.data) {
              location.reload();
            }
            return result;
          } else {
            // Local is newer or equal, upload
            console.log('[Firebase] Local settings are newer, uploading...');
            return await uploadUserSettings(userId);
          }
        }
      } catch (error) {
        console.error('[Firebase] Sync failed:', error);
        throw error;
      }
    }
    
    let userProfile = JSON.parse(localStorage.getItem('userProfile') || 'null');
    let authTokens = JSON.parse(localStorage.getItem('authTokens') || 'null');

    // Update profile UI
    function updateProfileUI() {
      const avatar = document.getElementById('profileAvatar');
      const username = document.getElementById('profileUsername');
      const status = document.getElementById('profileStatus');
      const loginBtn = document.getElementById('discordLoginBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      const syncStatus = document.getElementById('syncStatus');
      const syncTime = document.getElementById('syncTime');
      const syncNowBtn = document.getElementById('syncNowBtn');
      const accountStatsCard = document.getElementById('accountStatsCard');

      if (userProfile && authTokens) {
        // Logged in state
        if (avatar) {
          avatar.classList.remove('empty');
          if (userProfile.avatar) {
            avatar.innerHTML = `<img src="${userProfile.avatar}" alt="${userProfile.username}" />`;
          } else {
            // Show first letter of username if no avatar
            avatar.innerHTML = `<div style="font-size:36px;font-weight:700">${userProfile.username[0].toUpperCase()}</div>`;
          }
        }
        if (username) username.textContent = userProfile.tag || userProfile.username;
        if (status) {
          status.classList.remove('offline');
          status.innerHTML = '<span class="status-dot"></span><span>Connected via Discord</span>';
        }
        if (loginBtn) loginBtn.style.display = 'none';
        if (logoutBtn) logoutBtn.style.display = 'flex';
        if (syncStatus) syncStatus.textContent = 'Ready to sync';
        if (syncTime) {
          const lastSync = localStorage.getItem('lastSyncTime');
          syncTime.textContent = lastSync 
            ? `Last synced: ${new Date(lastSync).toLocaleString()}`
            : 'Never synced - click Sync Now to upload your settings';
        }
        if (syncNowBtn) syncNowBtn.disabled = false;
        if (accountStatsCard) {
          accountStatsCard.style.display = 'block';
          updateAccountStats(); // Update stats when shown
        }
      } else {
        // Logged out state
        if (avatar) {
          avatar.classList.add('empty');
          avatar.innerHTML = '';
        }
        if (username) username.textContent = 'Not logged in';
        if (status) {
          status.classList.add('offline');
          status.innerHTML = '<span class="status-dot"></span><span>Local account only</span>';
        }
        if (loginBtn) loginBtn.style.display = 'flex';
        if (logoutBtn) logoutBtn.style.display = 'none';
        if (syncStatus) syncStatus.textContent = 'Not available';
        if (syncTime) syncTime.textContent = 'Login with Discord to enable cloud sync';
        if (syncNowBtn) syncNowBtn.disabled = true;
        if (accountStatsCard) {
          accountStatsCard.style.display = 'block'; // Still show stats when logged out
          updateAccountStats(); // Show local metrics
        }
      }

      // Update Plus status (async for both logged in/out states)
      updatePlusStatus();
    }

    // Update Plus UI status
    async function updatePlusStatus() {
      const plusStatusText = document.getElementById('plusStatusText');
      const upgradePlusBtn = document.getElementById('upgradePlusBtn');
      
      if (!plusStatusText || !upgradePlusBtn) return;

      // Check for demo plus (local session only) with time limit
      const demoPlus = localStorage.getItem('demoPlus') === 'true';
      const demoStartTime = parseInt(localStorage.getItem('demoPlusStartTime') || '0');
      const now = Date.now();
      const demoTimeLeft = 10 * 60 * 1000 - (now - demoStartTime); // 10 minutes
      const isDemoExpired = demoPlus && demoTimeLeft <= 0;

      if (userProfile && authTokens) {
        try {
          const plusData = await ipcRenderer.invoke('plus:checkStatus', userProfile.id);
          
          if (plusData.isPlus) {
            const expiresDate = new Date(plusData.expiresAt).toLocaleDateString();
            const isPaidPlus = plusData.type === 'paid';
            const isTestPlus = plusData.type === 'test';
            
            if (isPaidPlus) {
              plusStatusText.innerHTML = `
                <span style="font-weight:600;font-size:14px;color:var(--accent)">✨ Plus Active</span>
                <span style="font-size:12px;color:var(--muted)">Expires: ${expiresDate}</span>
              `;
              upgradePlusBtn.textContent = 'Manage';
              upgradePlusBtn.disabled = false;
            } else if (isTestPlus) {
              const hoursLeft = Math.ceil((plusData.expiresAt - Date.now()) / (60 * 60 * 1000));
              plusStatusText.innerHTML = `
                <span style="font-weight:600;font-size:14px;color:var(--warning)">🧪 Test Plus Active</span>
                <span style="font-size:12px;color:var(--muted)">${hoursLeft} hours left of monthly test</span>
              `;
              upgradePlusBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-plus"/></svg><span>Upgrade to Full</span>';
              upgradePlusBtn.disabled = false;
            }
          } else {
            plusStatusText.innerHTML = `
              <span style="font-weight:600;font-size:14px">Free Plan</span>
              <span style="font-size:12px;color:var(--muted)">Unlock all features with Plus</span>
            `;
            upgradePlusBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-plus"/></svg><span>Upgrade</span>';
            upgradePlusBtn.disabled = false;
          }
        } catch (error) {
          console.error('[Plus] Status check failed:', error);
        }
      } else if (demoPlus && !isDemoExpired) {
        // Demo plus mode (with time limit)
        const minutesLeft = Math.ceil(demoTimeLeft / (60 * 1000));
        plusStatusText.innerHTML = `
          <span style="font-weight:600;font-size:14px;color:var(--accent)">✨ Demo Plus</span>
          <span style="font-size:12px;color:var(--muted)">${minutesLeft} minutes left - Get unlimited access</span>
        `;
        upgradePlusBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-plus"/></svg><span>Upgrade Now</span>';
        upgradePlusBtn.disabled = false;
      } else if (isDemoExpired) {
        // Demo expired - reset demo
        localStorage.removeItem('demoPlus');
        localStorage.removeItem('demoPlusStartTime');
        plusStatusText.innerHTML = `
          <span style="font-weight:600;font-size:14px">Demo Expired</span>
          <span style="font-size:12px;color:var(--muted)">Try again or upgrade to Plus</span>
        `;
        upgradePlusBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-plus"/></svg><span>Try Again</span>';
        upgradePlusBtn.disabled = false;
      } else {
        // Logged out state - but allow demo plus for testing
        plusStatusText.innerHTML = `
          <span style="font-weight:600;font-size:14px">Free Plan</span>
          <span style="font-size:12px;color:var(--muted)">Try Plus (Demo Mode)</span>
        `;
        upgradePlusBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-plus"/></svg><span>Try Demo</span>';
        upgradePlusBtn.disabled = false; // Enable demo even without login
      }
    }

    // Update Account Statistics Display
    async function updateAccountStats() {
      const memberSinceEl = document.getElementById('memberSince');
      const playersTrackedEl = document.getElementById('playersTracked');
      const sessionsCountEl = document.getElementById('sessionsCount');
      const totalLookupsEl = document.getElementById('totalLookups');

      if (!memberSinceEl || !playersTrackedEl || !sessionsCountEl || !totalLookupsEl) {
        console.warn('[Metrics] Account stats elements not found');
        return;
      }

      try {
        let finalMetrics = { ...accountMetrics };
        let isCloudData = false;

        // If logged in, try to sync with cloud
        if (userProfile?.id) {
          try {
            const cloudResult = await ipcRenderer.invoke('metrics:get', userProfile.id);
            if (cloudResult.success && cloudResult.data) {
              isCloudData = cloudResult.source === 'cloud';
              finalMetrics = {
                memberSince: cloudResult.data.memberSince || accountMetrics.memberSince,
                players: new Set([...accountMetrics.players, ...(cloudResult.data.players || [])]),
                sessionsCount: Math.max(cloudResult.data.sessionsCount || 0, accountMetrics.sessionsCount),
                totalLookups: Math.max(cloudResult.data.totalLookups || 0, accountMetrics.totalLookups)
              };

              // Push local data to cloud if we have more data
              if (accountMetrics.totalLookups > (cloudResult.data.totalLookups || 0) ||
                  accountMetrics.players.size > (cloudResult.data.playersTracked || 0)) {
                const updateData = {
                  memberSince: Math.min(accountMetrics.memberSince, cloudResult.data.memberSince || Date.now()),
                  playersTracked: Math.max(accountMetrics.players.size, cloudResult.data.playersTracked || 0),
                  sessionsCount: Math.max(accountMetrics.sessionsCount, cloudResult.data.sessionsCount || 0),
                  totalLookups: Math.max(accountMetrics.totalLookups, cloudResult.data.totalLookups || 0)
                };
                
                ipcRenderer.invoke('metrics:update', userProfile.id, updateData).then(result => {
                  if (result.success) {
                    console.log('[Metrics] Local data synced to cloud');
                  }
                });
              }
            }
          } catch (error) {
            console.warn('[Metrics] Cloud sync failed, using local data:', error);
          }
        }

        // Update UI
        const memberSinceDate = new Date(finalMetrics.memberSince);
        memberSinceEl.textContent = memberSinceDate.toLocaleDateString();
        playersTrackedEl.textContent = finalMetrics.players.size.toLocaleString();
        sessionsCountEl.textContent = finalMetrics.sessionsCount.toLocaleString();
        totalLookupsEl.textContent = finalMetrics.totalLookups.toLocaleString();

        // Add visual indicator for data source
        const indicator = isCloudData ? '☁️' : '💾';
        const title = isCloudData ? 'Data synced from cloud' : 'Local data only';
        [memberSinceEl, playersTrackedEl, sessionsCountEl, totalLookupsEl].forEach(el => {
          el.setAttribute('title', title);
          el.style.opacity = isCloudData ? '1' : '0.8';
        });

        console.log('[Metrics] Display updated:', {
          source: isCloudData ? 'cloud' : 'local',
          ...finalMetrics,
          players: finalMetrics.players.size
        });

      } catch (error) {
        console.error('[Metrics] Failed to update display:', error);
        // Fallback to local data
        memberSinceEl.textContent = new Date(accountMetrics.memberSince).toLocaleDateString();
        playersTrackedEl.textContent = accountMetrics.players.size.toString();
        sessionsCountEl.textContent = accountMetrics.sessionsCount.toString();
        totalLookupsEl.textContent = accountMetrics.totalLookups.toString();
      }
    }

    // Auto-update account stats when switching to profile panel
    function scheduleAccountStatsUpdate() {
      const activePanel = document.querySelector('.panel.active');
      if (activePanel && activePanel.id === 'panel-profile') {
        updateAccountStats();
      }
    }

    // Discord Login Handler
    const discordLoginBtn = document.getElementById('discordLoginBtn');
    if (discordLoginBtn) {
      discordLoginBtn.addEventListener('click', async () => {
        try {
          discordLoginBtn.disabled = true;
          discordLoginBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-discord"/></svg><span>Opening Discord...</span>';
          
          const result = await ipcRenderer.invoke('auth:discord:login');
          
          if (result.error) {
            showNotification(result.error);
            discordLoginBtn.disabled = false;
            discordLoginBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-discord"/></svg><span>Login with Discord</span>';
            return;
          }

          // Show auth code input card instead of prompt
          const authCodeCard = document.getElementById('authCodeCard');
          if (authCodeCard) {
            authCodeCard.style.display = 'block';
            authCodeCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // Focus the input field
            setTimeout(() => {
              const input = document.getElementById('authCodeInput');
              if (input) input.focus();
            }, 500);
          }
          
          // Reset button state
          discordLoginBtn.disabled = false;
          discordLoginBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-discord"/></svg><span>Waiting for authorization...</span>';
          
        } catch (err) {
          console.error('Discord login error:', err);
          showNotification('Failed to initiate Discord login');
          discordLoginBtn.disabled = false;
          discordLoginBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-discord"/></svg><span>Login with Discord</span>';
        }
      });
    }

    // Handle Discord auth code
    async function handleDiscordCallback(code) {
      const loginBtn = document.getElementById('discordLoginBtn');
      const submitBtn = document.getElementById('submitAuthCode');
      const authCard = document.getElementById('authCodeCard');
      
      try {
        if (loginBtn) {
          loginBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-discord"/></svg><span>Authenticating...</span>';
        }

        const result = await ipcRenderer.invoke('auth:discord:exchange', code);
        
        if (result.error) {
          showNotification('Authentication failed: ' + result.error);
          
          // Reset all buttons and show auth card again
          if (loginBtn) {
            loginBtn.disabled = false;
            loginBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-discord"/></svg><span>Login with Discord</span>';
          }
          if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.textContent = 'Complete Login';
          }
          if (authCard) authCard.style.display = 'block';
          
          return;
        }

        // Save user data and tokens
        userProfile = result.user;
        authTokens = result.tokens;
        localStorage.setItem('userProfile', JSON.stringify(userProfile));
        localStorage.setItem('authTokens', JSON.stringify(authTokens));
        localStorage.setItem('authTimestamp', Date.now().toString());
        
        // Update UI
        updateProfileUI();
        
        showNotification(`Successfully logged in as ${userProfile.tag}!`);
        
        // Reset buttons
        if (loginBtn) {
          loginBtn.disabled = false;
          loginBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-discord"/></svg><span>Login with Discord</span>';
        }
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.textContent = 'Complete Login';
        }
      } catch (err) {
        console.error('Discord callback handling error:', err);
        showNotification('Failed to complete Discord login');
        
        // Reset all buttons and show auth card again
        if (loginBtn) {
          loginBtn.disabled = false;
          loginBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-discord"/></svg><span>Login with Discord</span>';
        }
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.textContent = 'Complete Login';
        }
        if (authCard) authCard.style.display = 'block';
      }
    }

    // Logout Handler
    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) {
      logoutBtn.addEventListener('click', () => {
        if (confirm('Are you sure you want to logout? Your local settings will remain, but cloud sync will be disabled.')) {
          userProfile = null;
          authTokens = null;
          localStorage.removeItem('userProfile');
          localStorage.removeItem('authTokens');
          localStorage.removeItem('authTimestamp');
          localStorage.removeItem('lastSyncTime');
          updateProfileUI();
          showNotification('Logged out successfully');
        }
      });
    }

    // Auth Code Submit Handler
    const submitAuthCodeBtn = document.getElementById('submitAuthCode');
    const authCodeInput = document.getElementById('authCodeInput');
    const cancelAuthCodeBtn = document.getElementById('cancelAuthCode');
    const authCodeCard = document.getElementById('authCodeCard');

    if (submitAuthCodeBtn && authCodeInput) {
      submitAuthCodeBtn.addEventListener('click', () => {
        const input = authCodeInput.value.trim();
        if (!input) {
          showNotification('Please paste the redirect URL');
          return;
        }

        // Extract code from URL
        let code = input;
        
        if (code.includes('?code=')) {
          const urlParams = new URLSearchParams(code.split('?')[1]);
          code = urlParams.get('code') || code;
        } else if (code.includes('&code=')) {
          const urlParams = new URLSearchParams(code.split('?')[1] || code);
          code = urlParams.get('code') || code;
        }
        
        if (code && code.length > 10) {
          submitAuthCodeBtn.disabled = true;
          submitAuthCodeBtn.textContent = 'Authenticating...';
          handleDiscordCallback(code);
          
          // Hide auth card after submitting
          if (authCodeCard) authCodeCard.style.display = 'none';
          authCodeInput.value = '';
        } else {
          showNotification('Invalid code or URL. Please check and try again.');
        }
      });

      // Allow Enter key to submit
      authCodeInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          submitAuthCodeBtn.click();
        }
      });
    }

    if (cancelAuthCodeBtn && authCodeCard) {
      cancelAuthCodeBtn.addEventListener('click', () => {
        authCodeCard.style.display = 'none';
        if (authCodeInput) authCodeInput.value = '';
        const loginBtn = document.getElementById('discordLoginBtn');
        if (loginBtn) {
          loginBtn.disabled = false;
          loginBtn.innerHTML = '<svg class="icon" aria-hidden="true"><use href="#i-discord"/></svg><span>Login with Discord</span>';
        }
      });
    }

    // Sync Now Handler (Firebase Cloud Sync)
    const syncNowBtn = document.getElementById('syncNowBtn');
    if (syncNowBtn) {
      syncNowBtn.addEventListener('click', async () => {
        if (!userProfile) {
          showNotification('Please login with Discord first');
          return;
        }

        if (!firebaseInitialized) {
          showNotification('Firebase not configured. Please check your .env settings.');
          return;
        }

        try {
          syncNowBtn.disabled = true;
          syncNowBtn.textContent = 'Syncing...';
          
          // Sync user settings with Firebase
          await syncUserSettings(userProfile.id, 'auto');
          
          // Update UI timestamp
          updateProfileUI();
          
          showNotification('Settings synced successfully!');
          syncNowBtn.disabled = false;
          syncNowBtn.textContent = 'Sync Now';
        } catch (err) {
          console.error('Sync error:', err);
          showNotification('Sync failed: ' + (err.message || err));
          syncNowBtn.disabled = false;
          syncNowBtn.textContent = 'Sync Now';
        }
      });
    }

    // Plus Upgrade Handler
    const upgradePlusBtn = document.getElementById('upgradePlusBtn');
    if (upgradePlusBtn) {
      upgradePlusBtn.addEventListener('click', async () => {
        // Check if demo reset
        if (upgradePlusBtn.textContent === 'Reset Demo') {
          localStorage.removeItem('demoPlus');
          showNotification('Demo Plus reset');
          updatePlusStatus();
          return;
        }

        if (!userProfile) {
          // Demo mode without login
          showNotification('🎉 Demo Plus activated! Try all Plus features this session.');
          localStorage.setItem('demoPlus', 'true');
          updatePlusStatus();
          return;
        }

        // Open our new plan selection dialog instead of direct checkout
        showPlusVerificationDialog();
      });
    }

    // Plus verification dialog
    function showPlusVerificationDialog() {
      // Create different dialogs based on login status
      const modal = document.getElementById('notificationModal');
      const messageEl = document.getElementById('notificationMessage');
      const okBtn = document.getElementById('notificationOkBtn');
      
      if (userProfile && authTokens) {
        // LOGGED IN USER: Direct purchase options 
        messageEl.innerHTML = `
          <div style="text-align:left;padding:12px 0">
            <h3 style="margin:0 0 12px 0;color:var(--accent)">Upgrade to Nebula Plus</h3>
            <p style="margin:0 0 20px 0">Choose your plan and unlock all Plus features:</p>
            <div style="display:flex;gap:16px;justify-content:center;flex-wrap:wrap">
              <button id="monthlyPlanBtn" style="background:var(--surface2);color:var(--text);border:2px solid var(--border);padding:16px 24px;border-radius:12px;cursor:pointer;font-weight:500;font-size:14px;transition:all 0.2s ease;min-width:140px">
                � Monthly<br>
                <span style="font-size:18px;font-weight:700;color:var(--accent)">€1.99</span><br>
                <small style="opacity:0.7">per month</small>
              </button>
              <button id="yearlyPlanBtn" style="background:linear-gradient(135deg,#20B2AA,#17A2B8);color:white;border:2px solid #20B2AA;padding:16px 24px;border-radius:12px;cursor:pointer;font-weight:500;font-size:14px;transition:all 0.2s ease;min-width:140px;position:relative;box-shadow:0 4px 12px rgba(32,178,170,0.3)">
                <div style="position:absolute;top:-8px;right:-8px;background:#FF6B35;color:white;padding:2px 8px;border-radius:12px;font-size:10px;font-weight:700">-16%</div>
                � Yearly<br>
                <span style="font-size:18px;font-weight:700">€19.99</span><br>
                <small style="opacity:0.9">save €4/year</small>
              </button>
            </div>
            <div style="text-align:center;margin-top:16px">
              <button id="cancelBtn" style="background:transparent;color:var(--muted);border:1px solid var(--border);padding:8px 16px;border-radius:6px;cursor:pointer">Cancel</button>
            </div>
            <p style="margin:16px 0 0 0;font-size:12px;color:var(--muted);text-align:center">
              � Secure payment via Stripe • Cancel anytime
            </p>
          </div>
        `;
      } else {
        // NOT LOGGED IN: Only demo available
        messageEl.innerHTML = `
          <div style="text-align:left;padding:12px 0">
            <h3 style="margin:0 0 12px 0;color:var(--accent)">Try Nebula Plus</h3>
            <p style="margin:0 0 16px 0">Login with Discord for more options, or try a quick demo:</p>
            <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap">
              <button id="loginForTrialBtn" style="background:var(--accent);color:white;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-weight:500">� Login for 7-Day Trial</button>
              <button id="quickDemoBtn" style="background:var(--surface2);color:var(--text);border:none;padding:8px 16px;border-radius:6px;cursor:pointer">⚡ 10-Min Demo</button>
              <button id="cancelBtn" style="background:transparent;color:var(--muted);border:1px solid var(--border);padding:8px 16px;border-radius:6px;cursor:pointer">Cancel</button>
            </div>
          </div>
        `;
      }
      
      modal.classList.add('open');
      
      const closeModal = () => {
        modal.classList.remove('open');
        messageEl.innerHTML = ''; // Clear custom content
      };

      // Handle monthly plan (€1.99/month)
      const monthlyPlanBtn = document.getElementById('monthlyPlanBtn');
      if (monthlyPlanBtn) {
        monthlyPlanBtn.onclick = async () => {
          closeModal();
          
          try {
            const result = await ipcRenderer.invoke('plus:createCheckout', userProfile.id, { plan: 'monthly' });
            
            if (result.error) {
              showNotification('❌ ' + result.error);
              return;
            }
            
            showNotification('💳 Opening monthly payment (€1.99/month)...');
            
            // After a delay, show payment verification dialog
            setTimeout(() => {
              showPaymentVerificationDialog();
            }, 3000);
          } catch (err) {
            showNotification('❌ Error: ' + (err.message || err));
          }
        };
      }

      // Handle yearly plan (€19.99/year - save 16%!)
      const yearlyPlanBtn = document.getElementById('yearlyPlanBtn');
      if (yearlyPlanBtn) {
        yearlyPlanBtn.onclick = async () => {
          closeModal();
          
          try {
            const result = await ipcRenderer.invoke('plus:createCheckout', userProfile.id, { plan: 'yearly' });
            
            if (result.error) {
              showNotification('❌ ' + result.error);
              return;
            }
            
            showNotification('💎 Opening yearly payment (€19.99/year - save 16%)...');
            
            // After a delay, show payment verification dialog
            setTimeout(() => {
              showPaymentVerificationDialog();
            }, 3000);
          } catch (err) {
            showNotification('❌ Error: ' + (err.message || err));
          }
        };
      }

      // Handle login prompt for trial
      const loginForTrialBtn = document.getElementById('loginForTrialBtn');
      if (loginForTrialBtn) {
        loginForTrialBtn.onclick = () => {
          closeModal();
          showNotification('Please login with Discord first to start your 7-day trial!');
          // Scroll to login section
          document.getElementById('discordSection').scrollIntoView({ behavior: 'smooth' });
        };
      }

      // Handle quick demo (non-logged in users)
      const quickDemoBtn = document.getElementById('quickDemoBtn');
      if (quickDemoBtn) {
        quickDemoBtn.onclick = () => {
          closeModal();
          const existingDemo = localStorage.getItem('demoPlus') === 'true';
          const demoStartTime = parseInt(localStorage.getItem('demoPlusStartTime') || '0');
          const now = Date.now();
          const timeSinceDemo = now - demoStartTime;
          
          // Allow new demo if more than 24 hours passed or no demo yet
          if (!existingDemo || timeSinceDemo > 24 * 60 * 60 * 1000) {
            localStorage.setItem('demoPlus', 'true');
            localStorage.setItem('demoPlusStartTime', String(now));
            showNotification('⚡ 10-minute Quick Demo activated! Try Nebula Plus features now.');
            updatePlusStatus();
          } else {
            showNotification('⏰ Demo already used today. Login for 7-day trial or wait 24h!');
          }
        };
      }

      // Handle cancel
      const cancelBtn = document.getElementById('cancelBtn');
      if (cancelBtn) {
        cancelBtn.onclick = closeModal;
      }
    }

    // Payment verification dialog (after Stripe checkout)
    function showPaymentVerificationDialog() {
      const modal = document.getElementById('notificationModal');
      const messageEl = document.getElementById('notificationMessage');
      
      messageEl.innerHTML = `
        <div style="text-align:left;padding:12px 0">
          <h3 style="margin:0 0 12px 0;color:var(--accent)">Payment Completed?</h3>
          <p style="margin:0 0 16px 0">Did you successfully complete your payment on Stripe?</p>
          <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
            <button id="verifyPaymentBtn" style="background:var(--accent);color:white;border:none;padding:12px 20px;border-radius:8px;cursor:pointer;font-weight:500;display:flex;align-items:center;gap:8px"><svg class="icon" aria-hidden="true" style="opacity:0.9"><use href="#i-check"/></svg>Yes, I Paid</button>
            <button id="paymentCancelBtn" style="background:transparent;color:var(--muted);border:1px solid var(--border);padding:8px 16px;border-radius:6px;cursor:pointer">Not Yet</button>
          </div>
          <p style="margin:16px 0 0 0;font-size:12px;color:var(--muted);text-align:center">
            We'll verify your payment and activate Plus automatically
          </p>
        </div>
      `;
      
      modal.classList.add('open');
      
      const closeModal = () => {
        modal.classList.remove('open');
        messageEl.innerHTML = '';
      };

      // Handle payment verification
      document.getElementById('verifyPaymentBtn').onclick = async () => {
        closeModal();
        
        if (!userProfile) {
          showNotification('⚠️ Please login with Discord first');
          return;
        }
        
        try {
          // Extract session_id from URL if available (after Stripe redirect)
          const urlParams = new URLSearchParams(window.location.search);
          const sessionId = urlParams.get('session_id');
          
          if (sessionId) {
            // Verify with actual session ID
            const result = await ipcRenderer.invoke('plus:verify', userProfile.id, sessionId);
            
            if (result.error) {
              showNotification('❌ Payment verification failed: ' + result.error);
              return;
            }
            
            showNotification('🎉 Plus activated successfully! Welcome to Nebula Plus!');
            updatePlusStatus();
          } else {
            // Fallback: Manual check or demo activation
            showNotification('Checking payment status... This may take a moment.');
            
            // For demo purposes, you could activate demo plus here
            // Or implement a webhook-based verification system
            setTimeout(() => {
              showNotification('⚠️ Payment verification in progress. Plus will activate automatically once confirmed.');
            }, 2000);
          }
        } catch (err) {
          showNotification('❌ Verification error: ' + (err.message || err));
        }
      };

      // Handle cancellation
      document.getElementById('paymentCancelBtn').onclick = closeModal;
    }

    // Verify plus purchase
    async function verifyPlusPurchase(purchaseToken) {
      try {
        const result = await ipcRenderer.invoke('plus:verify', userProfile.id, purchaseToken);
        
        if (result.error) {
          throw new Error(result.error);
        }
        
        showNotification('🎉 Plus activated successfully! Welcome to Nebula Plus!');
        updateProfileUI(); // Refresh plus status
        
      } catch (err) {
        console.error('Plus verification error:', err);
        showNotification('Plus verification failed: ' + (err.message || err));
      }
    }

    // Token refresh logic (check if token needs refresh on app start)
    async function checkAndRefreshToken() {
      if (!authTokens || !authTokens.refreshToken) return;

      const authTimestamp = parseInt(localStorage.getItem('authTimestamp') || '0');
      const now = Date.now();
      const tokenAge = now - authTimestamp;
      const expiresIn = (authTokens.expiresIn || 604800) * 1000; // Default 7 days

      // Refresh if token is older than 80% of expiry time
      if (tokenAge > expiresIn * 0.8) {
        console.log('Refreshing Discord token...');
        const result = await ipcRenderer.invoke('auth:discord:refresh', authTokens.refreshToken);
        
        if (result.success) {
          authTokens = result.tokens;
          localStorage.setItem('authTokens', JSON.stringify(authTokens));
          localStorage.setItem('authTimestamp', Date.now().toString());
          console.log('Token refreshed successfully');
        } else {
          console.error('Token refresh failed:', result.error);
          // Optionally logout user if refresh fails
        }
      }
    }

    // Initialize Firebase and profile UI on load
    async function initialize() {
      const firebaseReady = await checkFirebase();
      updateProfileUI();
      checkAndRefreshToken();
      
      // Only start auto-sync if Firebase is ready
      if (firebaseReady) {
        setInterval(async () => {
          if (userProfile && firebaseInitialized) {
            try {
              console.log('[Firebase] Auto-sync check...');
              await syncUserSettings(userProfile.id, 'auto');
            } catch (error) {
              console.warn('[Firebase] Auto-sync failed:', error);
              // Don't show notification for background sync failures
            }
          }
        }, 5 * 60 * 1000); // 5 minutes
      }
    }
    
    // Start initialization
    initialize();
  </script>
</body>
</html>
