<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nebula</title>

  <style>
  :root{
    --bg: rgba(20,20,28,0.78);
    --panel: rgba(255,255,255,0.06);
    --text: #e9e9f1;
    --muted: #9aa0aa;
    --accent: #66eaff; /* aktualisiert gemäß neuem Style-Snippet */
    --accent-soft: rgba(102,234,255,0.25);
    --good: #43d17f;
    --warn: #e0c14d;
    --bad: #e05a5a;
    --row: rgba(255,255,255,0.03);
    --row-hover: rgba(255,255,255,0.06);
    --menu: #1f2230;
    --shadow: 0 12px 30px rgba(0,0,0,0.35);
    --grip: 8px;
  }

  /* Reset / Base */
  html,body{margin:0;height:100%}
  body{
    background:var(--bg);
    color:var(--text);
    font:14px/1.4 system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Arial, sans-serif;
    -webkit-font-smoothing:antialiased;
    user-select:none;
  }
  /* Hide scrollbars */
  *::-webkit-scrollbar{width:0;height:0;background:transparent}
  *{scrollbar-width:none;-ms-overflow-style:none}

  /* Topbar */
  .topbar{
    display:flex;align-items:center;gap:10px;padding:10px 12px;background:var(--panel);
    -webkit-app-region:drag;
  }
  .brand{display:flex;align-items:center}
  .brand img{height:32px;opacity:.95;display:block} /* reduziert für präzisere Topbar-Abstände */
  .spacer{flex:1}
  .icon-btn,.search{ -webkit-app-region:no-drag }
  .icon-btn{
    width:30px;height:30px;display:grid;place-items:center;border-radius:8px;border:0;
    background:transparent;color:#cfd6e3;cursor:pointer; /* Farbe laut neuem Snippet */
  }
  .icon-btn:hover{background:var(--row-hover);color:var(--accent)}
  /* Unified icon styling (SVG sprite via <use>) */
  .icon{width:16px;height:16px;display:block;opacity:.9}
  /* Inline icon utility: keep SVG inline within text without breaking lines */
  .icon-inline{display:inline-block;vertical-align:text-bottom;line-height:0}
  .nav-icon .icon{width:18px;height:18px;opacity:.85}
  .icon-btn--danger:hover{background:rgba(224,90,90,0.20);color:#ff6b6b;filter:drop-shadow(0 0 6px rgba(255,107,107,0.25))}

  /* Search */
  .search{display:flex;align-items:center;gap:6px;padding:6px 10px;background:var(--row);border-radius:12px}
  .search .svg{width:14px;height:14px;opacity:.6}
  .search input{background:transparent;border:0;outline:0;color:var(--text);width:280px;font-size:13px}

  /* Content / Table */
  /* Reduced vertical padding to tighten space above table */
  .content{padding:4px 10px 4px}
  .table-wrap{padding:0 6px 4px;overflow-x:auto}
  table{width:100%;border-collapse:collapse;table-layout:auto;box-sizing:border-box}
  #table{font-size:var(--table-font-size,14px)}
  colgroup col.c-lvl{min-width:64px;width:auto}
  colgroup col.c-name{min-width:140px;width:auto}
  colgroup col.c-ws{min-width:50px;width:auto}
  colgroup col.c-fkdr, colgroup col.c-wlr, colgroup col.c-bblr{min-width:70px;width:auto}
  colgroup col.c-fk, colgroup col.c-wins{min-width:80px;width:auto}
  colgroup col.c-actions{min-width:50px;width:50px}

  thead th{
    text-align:left;font-weight:600;color:var(--muted);font-size:12px;padding:3px 6px;cursor:pointer; /* reduced vertical padding */
    -webkit-app-region:no-drag;
  }
  th.metric-h, td.metric{ text-align:right;font-variant-numeric:tabular-nums; font-feature-settings:"tnum" 1,"lnum" 1 }
  tbody td{
    padding:2px 6px;border-top:1px solid rgba(255,255,255,0.06);white-space:nowrap;overflow:hidden;text-overflow:ellipsis; /* tighter rows */
    line-height:1.3;
  }
  tbody tr:hover{background:var(--row-hover)}
  .lvl{font-weight:600}
  .name{font-weight:600;color:#6bd3ff}
  .rank-tag{font-weight:700;margin-right:6px}
  .metric{text-align:right}
  .good{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)}

  /* sort indicators */
  thead th[data-sort-key]{position:relative}
  thead th.sort-asc::after, thead th.sort-desc::after{
    content:"";display:inline-block;margin-left:6px;border:5px solid transparent;opacity:.6
  }
  thead th.sort-asc::after{border-bottom-color:var(--muted)}
  thead th.sort-desc::after{border-top-color:var(--muted)}

  /* Row actions / menu */
  .actions{ text-align:right; position:relative; overflow:visible }
  .menu{
    position:absolute; right:8px; top:28px; background:var(--menu); border-radius:8px; box-shadow:var(--shadow);
    padding:6px; min-width:120px; display:none; z-index:10000;
  }
  .menu.open{display:block}
  .menu button{display:block;width:100%;text-align:left;background:transparent;border:0;color:var(--text);padding:8px 10px;border-radius:6px;cursor:pointer}
  .menu button:hover{background:var(--row-hover)}

  /* Resize grips */
  .grip{position:fixed;z-index:1000;-webkit-app-region:no-drag}
  .g-top{top:0;left:0;right:0;height:var(--grip);cursor:n-resize}
  .g-bottom{bottom:0;left:0;right:0;height:var(--grip);cursor:s-resize}
  .g-left{top:0;bottom:0;left:0;width:var(--grip);cursor:w-resize}
  .g-right{top:0;bottom:0;right:0;width:var(--grip);cursor:e-resize}
  .g-tl{top:0;left:0;width:var(--grip);height:var(--grip);cursor:nw-resize}
  .g-tr{top:0;right:0;width:var(--grip);height:var(--grip);cursor:ne-resize}
  .g-bl{bottom:0;left:0;width:var(--grip);height:var(--grip);cursor:sw-resize}
  .g-br{bottom:0;right:0;width:var(--grip);height:var(--grip);cursor:se-resize}

  /* Sidebar / Toolbar */
  .sidebar{
    position:fixed;left:0;top:0;bottom:0;width:260px;transform:translateX(-100%);
    transition:transform .22s cubic-bezier(.2,.9,.2,1);
    background:rgba(30,30,36,0.96);color:var(--text);box-shadow:var(--shadow);z-index:2000;
    -webkit-app-region:no-drag;display:flex;flex-direction:column;overflow:hidden;
  }
  .sidebar.open{transform:translateX(0)}
  .sidebar-inner{display:flex;flex-direction:column;height:100%;padding:14px}
  .nav{display:flex;flex-direction:column;gap:6px;margin-top:6px}
  .nav-item{
    display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:8px;background:transparent;color:var(--text);
    border:0;text-align:left;cursor:pointer;-webkit-app-region:no-drag;font-weight:500;
  }
  .nav-item:hover{background:var(--row-hover)}
  .nav-item.active{background:rgba(255,255,255,0.04);font-weight:700}
  .nav-icon{width:22px;display:inline-block;text-align:center}
  .nav-label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .nav-sep{height:1px;background:rgba(255,255,255,0.03);margin:10px 0;border-radius:2px}
  .sidebar-footer{margin-top:auto;display:flex;flex-direction:column;gap:8px;padding-bottom:0}
  .user-row{display:flex;align-items:center;gap:8px;margin-top:8px;color:var(--muted);padding-top:8px;border-top:1px solid rgba(255,255,255,0.02)}
  .user-icon{width:20px;display:inline-block;text-align:center}

  /* Buttons */
  .btn{border:0;padding:9px 10px;border-radius:6px;background:transparent;color:var(--text);cursor:pointer;-webkit-app-region:no-drag}
  .btn.primary{background:#ffb400;color:#111;font-weight:700}
  .btn.community{border:1px solid rgba(255,255,255,0.06);color:var(--accent)}

  /* Panels */
  .panel{display:none;padding:14px;height:calc(100vh - 50px);overflow-y:auto}
  .panel.active{display:block}

  /* Settings section containers */
  .settings-content{display:none}
  .settings-content.active{display:block}

  /* Nicks */
  .nicks-list{background:var(--panel);border-radius:12px;overflow:hidden}
  .nick-row{display:flex;align-items:center;padding:12px 16px;border-bottom:1px solid rgba(255,255,255,0.04)}
  .nick-row:last-child{border:0}
  .nick-name{flex:1;margin-right:14px;font-weight:500}
  .nick-real{color:var(--muted);margin-right:14px}
  .delete-btn{opacity:.5;padding:6px;cursor:pointer;border:0;background:transparent;color:var(--text)}
  .delete-btn:hover{opacity:1}
  .add-btn{
    position:fixed;right:20px;bottom:20px;width:48px;height:48px;border-radius:24px;background:var(--accent);color:#111;border:0;
    font-size:24px;cursor:pointer;box-shadow:0 4px 12px var(--accent-soft);transition:transform .2s ease
  }
  .add-btn:hover{transform:scale(1.05);box-shadow:0 6px 16px rgba(102,234,255,0.5)}

  .nick-indicator{display:inline-flex;align-items:center;margin-left:6px;opacity:.7;cursor:help}
  .nick-indicator .icon{width:16px;height:16px}

  /* Forms */
  .add-nick-form{background:var(--panel);border-radius:12px;padding:20px;margin-bottom:16px}
  .add-nick-form h2{margin:0 0 16px;font-size:18px;font-weight:600}
  .form-row{margin-bottom:12px}
  .form-label{display:flex;align-items:center;gap:10px;background:rgba(0,0,0,0.2);padding:8px 12px;border-radius:8px}
  .form-label .icon{opacity:.7}
  .form-label input{flex:1;background:transparent;border:0;outline:0;color:var(--text);font-size:14px;padding:4px 0}
  .form-submit{width:100%;background:var(--accent);color:#111;border:0;padding:10px;border-radius:8px;font-weight:600;cursor:pointer;margin-top:4px;transition:all .2s ease}
  .form-submit:hover{transform:scale(1.02);box-shadow:0 4px 12px var(--accent-soft)}

  /* Settings */
  .settings-section{background:var(--panel);border-radius:8px;margin-top:16px;padding:20px}
  .settings-section h2{margin:0 0 20px;font-size:18px;font-weight:600;display:flex;align-items:center;gap:8px}
  .settings-icon .icon{width:18px;height:18px}
  .settings-row{margin-bottom:16px;display:flex;align-items:center}
  .settings-label{flex:0 0 120px;color:var(--muted)}
  .settings-select{background:rgba(0,0,0,0.2);color:var(--text);border:0;padding:8px 12px;border-radius:6px;min-width:200px}

  /* Stats list */
  .stats-list{display:flex;flex-direction:column;gap:4px}
  .stat-row{display:flex;align-items:center;padding:8px 12px;background:rgba(0,0,0,0.2);border-radius:8px;gap:12px}
  .stat-drag{cursor:move;color:var(--muted);font-size:16px}
  .stat-toggle{flex:1;display:flex;align-items:center;gap:8px;cursor:pointer}
  .stat-settings-btn{background:transparent;border:0;color:var(--text);opacity:.7;cursor:pointer;padding:4px 8px;border-radius:4px}
  .stat-settings-btn:hover{opacity:1;background:rgba(255,255,255,0.05)}

  /* Dynamic stat layout editor */
  .layout-editor{margin-top:16px;padding:14px;background:var(--panel);border-radius:12px;display:flex;flex-direction:column;gap:14px}
  .layout-editor h3{margin:0;font-size:15px;font-weight:600;display:flex;align-items:center;gap:8px}
  .layout-palette{display:flex;flex-wrap:wrap;gap:8px}
  .stat-pill{padding:6px 10px;background:rgba(255,255,255,0.07);border-radius:24px;font-size:12px;font-weight:500;cursor:grab;user-select:none;display:flex;align-items:center;gap:6px;position:relative}
  .stat-pill[data-used="1"]{opacity:.35;filter:grayscale(60%);cursor:not-allowed}
  .layout-slots{display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:8px}
  .slot{background:rgba(255,255,255,0.05);border:1px dashed rgba(255,255,255,0.14);border-radius:10px;min-height:46px;display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted);position:relative;padding:4px;transition:.15s}
  .slot.filled{border-style:solid;color:var(--text);font-weight:500}
  .slot.drag-over{outline:2px solid var(--accent);outline-offset:2px}
  .slot .slot-remove{position:absolute;top:4px;right:4px;background:rgba(0,0,0,0.4);border:0;color:var(--muted);width:20px;height:20px;border-radius:6px;cursor:pointer;font-size:14px;display:flex;align-items:center;justify-content:center}
  .slot .slot-remove:hover{color:#fff;background:rgba(0,0,0,0.65)}
  .layout-help{font-size:11px;color:var(--muted);line-height:1.4}

  /* Modal / Color rules */
  .modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:9000}
  .modal.open{display:flex;align-items:center;justify-content:center;animation:fadeIn .25s ease}
  @keyframes fadeIn{from{opacity:0}to{opacity:1}}
  .modal-content{background:linear-gradient(145deg,rgba(25,28,32,0.95),rgba(30,34,38,0.95));backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.08);box-shadow:0 8px 32px -8px rgba(0,0,0,0.6);border-radius:16px;width:92%;max-width:560px;max-height:88vh;overflow:auto;display:flex;flex-direction:column}
  .modal-header{padding:18px 24px;border-bottom:1px solid rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:space-between}
  .modal-header h3{margin:0;font-size:17px;font-weight:600;letter-spacing:.5px;display:flex;align-items:center;gap:8px}
  .modal-header h3 .stat-full-name{opacity:.6;font-weight:400;font-size:13px}
  .modal-close{background:rgba(255,255,255,0.04);border:0;color:var(--muted);font-size:20px;cursor:pointer;width:36px;height:36px;border-radius:10px;display:flex;align-items:center;justify-content:center;transition:.15s}
  .modal-close:hover{background:rgba(255,255,255,0.08);color:#fff}
  .modal-body{padding:22px 24px;display:flex;flex-direction:column;gap:20px}
  .color-rules{display:flex;flex-direction:column;gap:10px;margin:0}
  .color-rule{display:grid;grid-template-columns:70px 90px 90px 1fr 40px;align-items:center;gap:10px;background:rgba(255,255,255,0.03);padding:10px 14px;border-radius:12px;border:1px solid rgba(255,255,255,0.05);position:relative;transition:.15s}
  .color-rule:hover{background:rgba(255,255,255,0.05);border-color:rgba(255,255,255,0.09)}
  .rule-operator,.rule-value{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.15);color:var(--text);border-radius:8px;padding:6px 8px;font-size:13px}
  .rule-operator:focus,.rule-value:focus{outline:2px solid var(--accent);outline-offset:2px}
  .color-picker{display:flex;align-items:center;gap:8px}
  .color-preview{width:34px;height:24px;border-radius:8px;border:1px solid rgba(255,255,255,0.15);box-shadow:inset 0 0 0 2px rgba(0,0,0,0.3)}
  .color-input{width:90px;height:32px;padding:0;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.15);border-radius:8px;cursor:pointer}
  .color-input::-webkit-color-swatch{border:0;border-radius:6px}
  .color-input::-webkit-color-swatch-wrapper{padding:4px}
  .rule-delete{background:rgba(255,255,255,0.05);border:0;color:var(--muted);cursor:pointer;border-radius:8px;width:32px;height:32px;display:flex;align-items:center;justify-content:center;font-size:18px;transition:.15s}
  .rule-delete:hover{background:rgba(255,0,0,0.25);color:#fff}
  .add-rule-btn{width:100%;padding:12px 16px;background:rgba(255,255,255,0.04);border:1px dashed rgba(255,255,255,0.15);color:var(--text);border-radius:12px;cursor:pointer;font-weight:500;letter-spacing:.5px}
  .add-rule-btn:hover{background:rgba(255,255,255,0.07);border-style:solid}

  /* Settings navigation */
  .settings-nav{display:flex;flex-direction:column;gap:1px;background:var(--panel);border-radius:12px;overflow:hidden}
  .settings-nav-item{display:flex;align-items:center;gap:10px;padding:14px 16px;background:var(--panel);border:0;color:var(--text);font-size:14px;text-align:left;cursor:pointer}
  .settings-nav-item:hover{background:rgba(255,255,255,0.03)}
  .settings-nav-item.active{font-weight:700}
  .settings-nav-item .nav-icon{width:20px;text-align:center;font-size:16px}
  .settings-nav-item .nav-label{flex:1;font-weight:500}
  .nav-arrow{font-size:12px;opacity:.5;margin-left:4px;transition:transform .2s}
  .settings-nav-item.active .nav-arrow{transform:rotate(180deg)}
  .nav-item.expanded .nav-arrow{transform:rotate(180deg)}
  .nav-item.expanded .nav-icon .icon{transform:rotate(45deg);}
  .nav-icon .icon{transition:transform .25s ease;}
  .settings-submenu{display:none;margin-left:24px;margin-top:4px;border-left:1px solid rgba(255,255,255,0.1)}
  .settings-submenu.expanded{display:block}
  .nav-item.sub-item{padding:8px 12px;font-size:13px}
  .nav-item.sub-item .nav-icon{font-size:14px}
  /* entfernt: grüne Schrift für Stats */

  /* Keyboard grid */
  .kb-grid{display:flex;flex-direction:column;gap:10px}
  .kb-row{display:flex;align-items:center;gap:12px;background:rgba(0,0,0,0.2);padding:12px;border-radius:8px}
  .kb-action{flex:1}
  .kb-input{min-width:160px; text-align:center; padding:10px 12px; border-radius:8px; background:rgba(255,255,255,0.06); cursor:pointer}
  .kb-input.listening{outline:2px solid var(--accent)}
  .kb-help{padding:10px 12px;background:rgba(255,255,255,0.03);border-radius:8px;font-size:13px;line-height:1.5}
  /* Nicks help box (analog kb-help) */
  .nicks-help{padding:10px 12px;background:rgba(255,255,255,0.03);border-radius:8px;font-size:13px;line-height:1.5;color:var(--muted);margin-bottom:16px}

  /* Settings inputs & controls */
  .settings-input{width:100%;padding:8px 12px;background:var(--row);border:1px solid rgba(255,255,255,0.1);border-radius:8px;color:var(--text);font-size:14px;outline:0}
  .settings-input:focus{border-color:var(--accent)}
  .settings-select{width:100%;padding:8px 12px;background:var(--row);border:1px solid rgba(255,255,255,0.1);border-radius:8px;color:var(--text);font-size:14px;cursor:pointer;outline:0}
  .settings-select:focus{border-color:var(--accent)}
  .settings-textarea{width:100%;padding:8px 12px;background:var(--row);border:1px solid rgba(255,255,255,0.1);border-radius:8px;color:var(--text);font-size:13px;outline:0;resize:vertical}
  .settings-textarea:focus{border-color:var(--accent)}
  
  /* Toggle switch */
  .toggle-switch{position:relative;width:44px;height:24px;display:inline-block}
  .toggle-switch input{opacity:0;width:0;height:0}
  .toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:rgba(255,255,255,0.1);border-radius:24px;transition:.3s}
  .toggle-slider:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background:white;border-radius:50%;transition:.3s}
  .toggle-switch input:checked + .toggle-slider{background:var(--accent)}
  .toggle-switch input:checked + .toggle-slider:before{transform:translateX(20px)}
  
  /* Checkbox */
  .settings-checkbox{display:flex;align-items:flex-start;gap:8px;padding:8px 0;cursor:pointer;user-select:none}
  .settings-checkbox input[type="checkbox"]{width:18px;height:18px;margin:2px 0 0 0;cursor:pointer;flex-shrink:0}
  .settings-checkbox span{flex:1}
  .settings-checkbox small{display:block;margin-top:4px}
  
  /* Premium badge */
  .premium-badge{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:2px 8px;border-radius:4px;font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:0.3px}
  
  /* Settings subsections */
  .settings-subsection{margin-bottom:24px;padding-bottom:24px;border-bottom:1px solid rgba(255,255,255,0.06)}
  .settings-subsection:last-child{border-bottom:0;margin-bottom:0;padding-bottom:0}
  .source-options{margin-left:0;display:flex;flex-direction:column;gap:4px}
  </style>
</head>

<body>
  <!-- Nebula icon sprite (stroke=2, round caps/joins, currentColor) -->
  <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
    <symbol id="i-refresh" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 12a9 9 0 0 1-9 9 9 9 0 1 1 6.3-15.3"/><path d="M21 3v6h-6"/>
    </symbol>
    <symbol id="i-clear" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M3 6h18"/><path d="M8 6V4h8v2"/><path d="M6 6l1 13h10l1-13"/><path d="M10 10v7M14 10v7"/>
    </symbol>
    <symbol id="i-min" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M5 12h14"/></symbol>
    <symbol id="i-close" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M18 6L6 18M6 6l12 12"/></symbol>

    <!-- Sidebar -->
    <symbol id="i-home" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M3 11l9-7 9 7"/><path d="M5 10v10h14V10"/>
    </symbol>
    <symbol id="i-nicks" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="8" cy="8.5" r="3"/><path d="M2.5 19c1.6-3 4-4.5 6.5-4.5s4.9 1.5 6.5 4.5"/>
      <path d="M16 5h4M16 9h6M16 13h5" />
    </symbol>
    <symbol id="i-settings" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="3"/>
      <path d="M4 12h2.5M17.5 12H20"/>
      <path d="M12 4v2.5M12 17.5V20"/>
      <path d="M6.6 6.6l1.8 1.8M15.6 15.6l1.8 1.8"/>
      <path d="M6.6 17.4l1.8-1.8M15.6 8.4l1.8-1.8"/>
    </symbol>
    <symbol id="i-basic" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M4 7h12"/><circle cx="16" cy="7" r="2.5"/>
      <path d="M4 17h8"/><circle cx="10" cy="17" r="2.5"/>
    </symbol>
    <symbol id="i-appearance" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="7"/><path d="M5 12h14M12 5v14"/>
    </symbol>
    <symbol id="i-sources" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M3 16l6-6 4 4 8-8"/><path d="M14 6h7v7"/>
    </symbol>
    <symbol id="i-stats" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <rect x="3" y="5" width="18" height="14" rx="2"/><path d="M9 5v14M15 5v14"/>
    </symbol>
    <symbol id="i-shortcuts" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <rect x="3" y="6" width="18" height="12" rx="2"/><path d="M7 10h2M11 10h2M15 10h2M9 14h6"/>
    </symbol>
    <symbol id="i-profile" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="8" r="4"/><path d="M4 20c1.8-3.2 4.7-5 8-5s6.2 1.8 8 5"/>
    </symbol>
    <!-- Additional icons for settings subitems -->
    <symbol id="i-file" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
      <path d="M14 2v6h6"/>
    </symbol>
    <symbol id="i-ghost" viewBox="0 0 24 24" fill="currentColor">
      <path d="M12 2c-4.42 0-8 3.58-8 8v12l2-2 2 2 2-2 2 2 2-2 2 2 2-2V10c0-4.42-3.58-8-8-8zM9 10a1 1 0 1 1 0 2 1 1 0 0 1 0-2zm6 1a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
    </symbol>
    <symbol id="i-target" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="10"/>
      <circle cx="12" cy="12" r="6"/>
      <circle cx="12" cy="12" r="2"/>
    </symbol>
  </svg>
  <div class="topbar">
    <button id="menuBtn" class="icon-btn" aria-label="Menu" title="Menu">
      <svg class="svg" viewBox="0 0 24 24" fill="currentColor">
        <path d="M3 6h18v2H3V6zm0 5h18v2H3v-2zm0 5h18v2H3v-2z"/>
      </svg>
    </button>
  <div class="brand"><img src="../../assets/nebula-logo.svg" alt="Nebula"></div>
    <div class="spacer"></div>

    <!-- Refresh -->
    <button id="refresh" class="icon-btn" aria-label="Refresh" title="Refresh">
      <svg class="icon" aria-hidden="true"><use href="#i-refresh"/></svg>
    </button>

    <!-- Clear all -->
    <button id="clearAll" class="icon-btn" aria-label="Clear all players" title="Clear all players">
      <svg class="icon" aria-hidden="true"><use href="#i-clear"/></svg>
    </button>

    <!-- Search -->
    <div class="search">
      <svg class="svg" viewBox="0 0 24 24" fill="currentColor">
        <path d="M15.5 14h-.79l-.28-.27A6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79L20 21.5 21.5 20 15.5 14zM9.5 14A4.5 4.5 0 1 1 14 9.5 4.5 4.5 0 0 1 9.5 14z"/>
      </svg>
      <input id="playerInput" placeholder="Search player(s), comma-separated" />
    </div>

    <!-- Minimize -->
    <button id="minBtn" class="icon-btn" aria-label="Minimize" title="Minimize">
      <svg class="icon" aria-hidden="true"><use href="#i-min"/></svg>
    </button>

    <!-- Close -->
    <button id="closeBtn" class="icon-btn icon-btn--danger" aria-label="Close" title="Close">
      <svg class="icon" aria-hidden="true"><use href="#i-close"/></svg>
    </button>


  </div>

  <aside id="sidebar" class="sidebar" aria-hidden="true">
    <div class="sidebar-inner">
      <nav class="nav">
        <button class="nav-item active" data-panel="home">
          <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-home"/></svg></span>
          <span class="nav-label">Overlay</span>
        </button>

        <button class="nav-item" data-panel="nicks">
          <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-nicks"/></svg></span>
          <span class="nav-label">Nicks</span>
        </button>

        <div class="nav-sep"></div>

        <button class="nav-item" data-panel="settings">
          <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-settings"/></svg></span>
          <span class="nav-label">Settings</span>
          <span class="nav-arrow">▾</span>
        </button>

        <!-- Untermenü für Settings -->
        <div class="settings-submenu">
          <button class="nav-item sub-item" data-panel="settings" data-settings="basic">
            <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-basic"/></svg></span>
            <span class="nav-label">Basic</span>
          </button>
          
          <button class="nav-item sub-item" data-panel="settings" data-settings="appearance">
            <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-appearance"/></svg></span>
            <span class="nav-label">Appearance</span>
          </button>
          
          <button class="nav-item sub-item" data-panel="settings" data-settings="sources">
            <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-sources"/></svg></span>
            <span class="nav-label">Sources</span>
          </button>
          
          <button class="nav-item sub-item" data-panel="settings" data-settings="columns">
            <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-stats"/></svg></span>
            <span class="nav-label">Columns</span>
          </button>
          
          <button class="nav-item sub-item" data-panel="settings" data-settings="keyboard">
            <span class="nav-icon"><svg class="icon" aria-hidden="true"><use href="#i-shortcuts"/></svg></span>
            <span class="nav-label">Keyboard Shortcuts</span>
          </button>
        
        </div>
      
      <div class="nav-sep"></div>

      <div class="sidebar-footer">
        <div class="user-row">
          <span class="user-icon"><svg class="icon" aria-hidden="true"><use href="#i-profile"/></svg></span>
          <span class="user-name" id="sidebarUsername">username</span>
        </div>
      </div>
    </div>
  </aside>

  <div class="content">
    <!-- Home Panel -->
    <div class="panel" id="panel-home">
      <div class="table-wrap">
        <table id="table">
          <colgroup>
            <col class="c-lvl"><col class="c-name"><col class="c-ws">
            <col class="c-fkdr"><col class="c-wlr"><col class="c-bblr">
            <col class="c-fk"><col class="c-wins"><col class="c-actions">
          </colgroup>
          <thead>
            <tr>
              <th data-sort-key="level">Lvl</th>
              <th>Name</th>
              <th class="metric-h" data-sort-key="ws">WS</th>
              <th class="metric-h" data-sort-key="fkdr">FKDR</th>
              <th class="metric-h" data-sort-key="wlr">WLR</th>
              <th class="metric-h" data-sort-key="bblr">BBLR</th>
              <th class="metric-h" data-sort-key="fk">F. Kills</th>
              <th class="metric-h" data-sort-key="wins">Wins</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </div>
    </div>

    <!-- Nicks Panel -->
    <div class="panel" id="panel-nicks">
      <h2 style="margin:0 0 16px;font-size:18px;font-weight:600;display:flex;align-items:center;gap:8px">
        <span class="settings-icon"><svg class="icon" aria-hidden="true"><use href="#i-nicks"/></svg></span>
        Nicks
      </h2>
      <div class="nicks-help">Create a small nickname dictionary here: assign nicknames to their real player names. If a player with a registered nickname appears in the overlay, a <svg class="icon icon-inline" style="width:16px;height:16px;vertical-align:middle" aria-hidden="true" title="Nick recognised"><use href="#i-ghost"/></svg> icon is displayed. This helps you immediately classify statistics from nicked players correctly.</div>
      <div class="nick-display-setting" style="margin:12px 0 16px;padding:10px 12px;border-radius:8px;background:var(--panel);display:flex;flex-direction:column;gap:8px">
        <label style="display:flex;flex-direction:column;gap:4px;font-size:12px;color:var(--muted)">
          <span>Overlay name display</span>
          <select id="nickDisplayMode" style="background:rgba(0,0,0,0.25);color:var(--text);border:0;padding:6px 8px;border-radius:6px;font-size:13px">
            <option value="nick">Nickname (real stats)</option>
            <option value="real">Real name</option>
          </select>
        </label>
        <div style="font-size:11px;color:var(--muted);line-height:1.4">
          Choose whether to show the nick or the real name — stats always reflect the real player. The
          <svg class="icon icon-inline" style="width:14px;height:14px" aria-hidden="true"><use href="#i-ghost"/></svg>
          icon is always shown, and the tooltip reveals the other name.
        </div>
      </div>
      <!-- Add Nick Form -->
      <div class="add-nick-form" id="addNickForm" style="display: none;">
        <h3 style="margin:0 0 16px;font-size:16px;font-weight:600">Add new nick</h3>
        <div class="form-row">
          <label class="form-label">
            <svg class="icon" aria-hidden="true"><use href="#i-nicks"/></svg>
            <input type="text" id="nickInput" placeholder="Nick" />
          </label>
        </div>
        <div class="form-row">
          <label class="form-label">
            <svg class="icon" aria-hidden="true"><use href="#i-target"/></svg>
            <input type="text" id="realNameInput" placeholder="Real name" />
          </label>
        </div>
        <button class="form-submit" id="saveNickBtn">ADD</button>
      </div>

      <!-- Nicks List -->
      <div class="nicks-list" id="nicksList">
        <!-- Nicks werden hier per JS eingefügt -->
      </div>
      <button class="add-btn" id="addNickBtn" title="Add nick">+</button>
    </div>

    <!-- Settings Panel -->
    <div class="panel" id="panel-settings">
      <!-- Basic Settings -->
      <div class="settings-content" data-section="basic">
        <div class="settings-section">
          <h2>
            <span class="settings-icon"><svg class="icon" aria-hidden="true"><use href="#i-basic"/></svg></span>
            Basic Settings
          </h2>

          <div class="settings-subsection">
            <h3 style="margin: 20px 0 12px; font-size: 16px; font-weight: 600;">Essential</h3>
            
            <!-- Log File Dropdown -->
            <div class="settings-row">
              <span class="settings-icon" style="width:24px;text-align:center"><svg class="icon" aria-hidden="true"><use href="#i-file"/></svg></span>
              <div style="flex: 1; display: flex; flex-direction: column; gap: 4px;">
                <label class="settings-label" style="margin: 0;">Log File</label>
                <select id="logFileSelect" class="settings-select" style="width: 100%;">
                  <option value="badlion">Badlion Client</option>
                  <option value="lunar">Lunar Client</option>
                  <option value="vanilla">Vanilla/Other</option>
                  <option value="custom">Custom Path...</option>
                </select>
                <small style="color: var(--muted); font-size: 12px;">Make sure that the log file is set correctly.</small>
              </div>
            </div>

            <!-- Username Input -->
            <div class="settings-row">
              <span class="settings-icon" style="width:24px;text-align:center"><svg class="icon" aria-hidden="true"><use href="#i-profile"/></svg></span>
              <div style="flex: 1; display: flex; flex-direction: column; gap: 4px;">
                <label class="settings-label" style="margin: 0;">Username</label>
                <input id="usernameInput" type="text" placeholder="Your Minecraft username" class="settings-input" style="width: 100%; padding: 8px 12px; background: var(--row); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: var(--text); font-size: 14px;" />
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Sources Settings -->
      <div class="settings-content" data-section="sources">
        <div class="settings-section">
          <h2>
            <span class="settings-icon"><svg class="icon" aria-hidden="true"><use href="#i-sources"/></svg></span>
            Sources Settings
          </h2>

          <!-- Game Section -->
          <div class="settings-subsection">
            <div style="display: flex; align-items: center; justify-content: space-between; margin: 20px 0 12px;">
              <h3 style="margin: 0; font-size: 16px; font-weight: 600;">Game</h3>
              <label class="toggle-switch">
                <input type="checkbox" id="sourceGameToggle" checked />
                <span class="toggle-slider"></span>
              </label>
            </div>

            <div class="source-options" id="gameSourceOptions">
              <label class="settings-checkbox">
                <input type="checkbox" id="gameAddFromChat" checked />
                <span>Add From Chat</span>
              </label>
              <label class="settings-checkbox">
                <input type="checkbox" id="gameRemoveOnDeath" checked />
                <span>Remove on Final Death</span>
              </label>
              <label class="settings-checkbox">
                <input type="checkbox" id="gameRemoveOnReconnect" checked />
                <span>Remove/Add on Disconnect/Reconnect</span>
                <small style="display: block; color: var(--muted); margin-left: 24px; font-size: 12px;">Players who disconnect while respawning will not be removed.</small>
              </label>
              <label class="settings-checkbox">
                <input type="checkbox" id="gameRemoveOnServerChange" checked />
                <span>Remove All on Server Change</span>
              </label>
            </div>
          </div>

          <!-- Party Section -->
          <div class="settings-subsection">
            <div style="display: flex; align-items: center; justify-content: space-between; margin: 20px 0 12px;">
              <h3 style="margin: 0; font-size: 16px; font-weight: 600;">Party</h3>
              <label class="toggle-switch">
                <input type="checkbox" id="sourcePartyToggle" checked />
                <span class="toggle-slider"></span>
              </label>
            </div>

            <div class="source-options" id="partySourceOptions">
              <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                <span style="width:24px;text-align:center"><svg class="icon" aria-hidden="true"><use href="#i-refresh"/></svg></span>
                <span style="font-weight: 500;">Auto-Refresh</span>
              </div>
              <label class="settings-checkbox" style="margin-left: 32px;">
                <input type="checkbox" id="partyRefreshServerChange" />
                <span>On Server Change</span>
              </label>
              <label class="settings-checkbox" style="margin-left: 32px;">
                <input type="checkbox" id="partyRefreshGameEnd" />
                <span>On Game End</span>
              </label>
            </div>
          </div>

          <!-- Party Invites Section -->
          <div class="settings-subsection">
            <div style="display: flex; align-items: center; justify-content: space-between; margin: 20px 0 12px;">
              <h3 style="margin: 0; font-size: 16px; font-weight: 600;">Party Invites</h3>
              <label class="toggle-switch">
                <input type="checkbox" id="sourcePartyInvitesToggle" checked />
                <span class="toggle-slider"></span>
              </label>
            </div>
          </div>

          <!-- Chat Section -->
          <div class="settings-subsection">
            <div style="display: flex; align-items: center; justify-content: space-between; margin: 20px 0 12px;">
              <h3 style="margin: 0; font-size: 16px; font-weight: 600;">Chat</h3>
              <label class="toggle-switch">
                <input type="checkbox" id="sourceChatToggle" checked />
                <span class="toggle-slider"></span>
              </label>
            </div>

            <div class="source-options" id="chatSourceOptions">
              <label class="settings-checkbox">
                <input type="checkbox" id="chatRemoveOnServerChange" checked />
                <span>Remove All on Server Change</span>
              </label>
              
              <div style="margin-top: 12px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                  <span style="width:24px;text-align:center"><svg class="icon" aria-hidden="true"><use href="#i-file"/></svg></span>
                  <label class="settings-label" style="margin: 0;">Strings</label>
                </div>
                <textarea id="chatStrings" rows="3" placeholder="Enter chat strings (one per line)" class="settings-textarea" style="width: 100%; padding: 8px 12px; background: var(--row); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: var(--text); font-size: 13px; font-family: monospace; resize: vertical;"></textarea>
                <small style="display: block; color: var(--muted); margin-top: 4px; font-size: 12px;">Automatically add players who send a message containing one of the provided strings. Case-insensitive.</small>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Appearance Settings -->
      <div class="settings-content" data-section="appearance">
        <div class="settings-section">
          <h2>
            <span class="settings-icon"><svg class="icon" aria-hidden="true"><use href="#i-appearance"/></svg></span>
            Appearance Settings
          </h2>

          <!-- Opacity -->
          <div class="settings-row">
            <label class="settings-label">Opacity</label>
            <input id="opacityRange" type="range" min="0.2" max="1" step="0.01" style="flex:1" />
            <span id="opacityValue" style="width:48px;text-align:right;margin-left:10px"></span>
          </div>

          <!-- Players Table Font Size -->
          <div class="settings-row">
            <label class="settings-label">Players Table Font Size</label>
            <input id="fontSizeRange" type="range" min="10" max="18" step="1" style="flex:1" />
            <span id="fontSizeValue" style="width:48px;text-align:right;margin-left:10px"></span>
          </div>

          <!-- Always on top -->
          <div class="settings-row">
            <label class="settings-label">Always On Top</label>
            <label style="display:flex;align-items:center;gap:8px">
              <input id="alwaysOnTopToggle" type="checkbox" />
            </label>
          </div>

          <!-- Auto-resize overlay -->
          <div class="settings-row">
            <label class="settings-label">Auto-Resize Overlay</label>
            <label style="display:flex;align-items:center;gap:8px">
              <input id="autoResizeToggle" type="checkbox" />
            </label>
          </div>

          <!-- Background Color -->
          <div class="settings-row">
            <label class="settings-label">Background Color</label>
            <input id="bgColorInput" type="color" style="width:44px;height:32px;border:0;background:transparent;padding:0" />
          </div>
        </div>
      </div>

      <!-- Columns Settings -->
      <div class="settings-content active" data-section="columns">
        <div class="settings-section">
          <h2>
            <span class="settings-icon"><svg class="icon" aria-hidden="true"><use href="#i-stats"/></svg></span>
            Columns Settings
          </h2>
        
        <div class="layout-editor" id="statLayoutEditor">
          <div class="layout-help">Drag stats from the palette into slots below. Empty slots are not shown in the overlay. Level and Name are always fixed at the beginning. Click on a filled slot to configure color rules.</div>
          <div class="layout-palette" id="layoutPalette"></div>
          <div class="layout-slots" id="layoutSlots"></div>
        </div>
        </div>
      </div>

      <!-- Keyboard Shortcuts Settings -->
      <div class="settings-content" data-section="keyboard">
        <div class="settings-section">
          <h2>
            <span class="settings-icon"><svg class="icon" aria-hidden="true"><use href="#i-shortcuts"/></svg></span>
            Keyboard Shortcuts
          </h2>
          <div class="kb-help" style="color: var(--muted); margin-bottom: 12px;">
            Click a field and press the desired key (F-keys or key with modifiers). Press <b>Escape</b> to clear (no shortcut).
            Shortcuts are global while Nebula is running.
          </div>
          <div class="kb-grid" id="kbGrid"></div>
        </div>
      </div>

      <!-- Color Rules Modal -->
      <div class="modal" id="colorRulesModal">
        <div class="modal-content">
          <div class="modal-header">
            <h3>Color Rules: <span id="colorRuleTitle"></span></h3>
            <button class="modal-close">×</button>
          </div>
          <div class="modal-body">
            <div class="color-rules" id="colorRulesList">
              <!-- Regeln werden per JS eingefügt -->
              <div class="color-rule">
                <select class="rule-operator">
                  <option value=">=">≥</option>
                  <option value="<"><</option>
                </select>
                <input type="number" class="rule-value" step="0.1">
                <div class="color-picker">
                  <div class="color-preview"></div>
                  <select class="color-select">
                    <option value="good">Good (Green)</option>
                    <option value="warn">Warning (Yellow)</option>
                    <option value="bad">Danger (Red)</option>
                  </select>
                </div>
                <button class="rule-delete">×</button>
              </div>
            </div>
            <button class="add-rule-btn">+ Add Rule</button>
          </div>
        </div>
      </div>
    </div>

  <!-- invisible grips -->
  <div class="grip g-top" data-edge="top"></div>
  <div class="grip g-bottom" data-edge="bottom"></div>
  <div class="grip g-left" data-edge="left"></div>
  <div class="grip g-right" data-edge="right"></div>
  <div class="grip g-tl" data-edge="top-left"></div>
  <div class="grip g-tr" data-edge="top-right"></div>
  <div class="grip g-bl" data-edge="bottom-left"></div>
  <div class="grip g-br" data-edge="bottom-right"></div>

  <script>
    console.log('NEBULA LOADED - Version:', new Date().toISOString());
    
    const { ipcRenderer } = require("electron");
    const rows = document.getElementById("rows");
    const input = document.getElementById("playerInput");
    let queue = [];

    // Auto-resize overlay logic (defined early so it can be called anywhere)
  const TOPBAR_HEIGHT = 50; // fallback topbar height (will be measured dynamically)
    const MIN_HEIGHT = 220; // minimum window height
    const DEFAULT_HEIGHT = 560; // default full height
    let resizeTimeout = null;

    function updateOverlaySize() {
      if (resizeTimeout) clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const activePanel = document.querySelector('.panel.active');
        const panelHome = document.getElementById('panel-home');
        const sidebar = document.getElementById('sidebar');

        // Get appearance settings safely
        const appearanceSettings = JSON.parse(localStorage.getItem('appearanceSettings') || '{}');

        // Only auto-resize if:
        // 1. Feature is enabled
        // 2. Home panel is active
        // 3. Sidebar is closed
        const allowAuto = appearanceSettings.autoResize !== false; // default true
        if (sidebar?.classList.contains('open')) {
          // Sidebar offen: auf Default-Höhe gehen (volle Ansicht)
            ipcRenderer.invoke('window:setBounds', { height: DEFAULT_HEIGHT });
            return;
        }
        if (!allowAuto || !activePanel || activePanel !== panelHome) {
          const table = document.getElementById('table');
          const rc = table?.querySelectorAll('tbody tr').length || 0;
          if (rc === 0) ipcRenderer.invoke('window:setBounds', { height: MIN_HEIGHT });
          return;
        }

        // Calculate table content height
        const table = document.getElementById('table');
        const rowCount = table?.querySelectorAll('tbody tr').length || 0;
        
        if (rowCount === 0) {
          // No players: minimal overlay
          ipcRenderer.invoke('window:setBounds', { height: MIN_HEIGHT });
          return;
        }

        // Calculate needed height: topbar + thead + rows + padding
        const theadHeight = table?.querySelector('thead')?.offsetHeight || 40;
        
        // Get actual row height from first row, or estimate based on font size
        let rowHeight = 24; // base minimum
        const firstRow = table?.querySelector('tbody tr');
        if (firstRow) {
          rowHeight = firstRow.offsetHeight;
        } else {
          // Estimate: font size + padding (4px top + 4px bottom) + line-height
          const fontSize = appearanceSettings.fontSize || 14;
          rowHeight = Math.ceil(fontSize * 1.4) + 8; // line-height 1.4 + 8px padding
        }
        
  const padding = 8; // minimal breathing room

  // Dynamic measurements
  const topbarEl = document.querySelector('.topbar');
  const topbarHeight = topbarEl?.offsetHeight || TOPBAR_HEIGHT;
  const contentEl = document.querySelector('.content');
  const wrapEl = document.querySelector('.table-wrap');
  const contentPadTop = contentEl ? parseInt(getComputedStyle(contentEl).paddingTop) || 0 : 0;
  const wrapPadTop = wrapEl ? parseInt(getComputedStyle(wrapEl).paddingTop) || 0 : 0;

  // Total needed height: topbar + content top padding + table-wrap top padding + header + rows + padding
  const extra = 12; // small extra slack below table
  const neededHeight = topbarHeight + contentPadTop + wrapPadTop + theadHeight + (rowCount * rowHeight) + padding + extra;
  const finalHeight = Math.min(neededHeight, DEFAULT_HEIGHT);

        ipcRenderer.invoke('window:setBounds', { height: finalHeight });
      }, 100); // debounce
    }

  // Track currently displayed players and their sources
  // displayedPlayers: set of normalized names (lowercase of displayed name)

  const displayedPlayers = new Set();
  const nickedPlayers = new Set(); // tracks players originally added via nick
  // playerSources: map normalized name -> set of sources ('username'|'manual'|'party'|'who'|'chat')
  const playerSources = new Map();
  // Cache for all loaded player objects (keyed by normalized name)
  let playerCache = {};
  console.log('displayedPlayers initialized:', displayedPlayers);
  const originalNicks = {}; // realName(lower) -> originally eingegebener Nick
  let nickDisplayMode = localStorage.getItem('nickDisplayMode') || 'nick';

  // Sorting state
  let sortKey = null; // 'level' | 'ws' | 'fkdr' | 'wlr' | 'bblr' | 'fk' | 'wins'
  let sortDir = 'asc'; // 'asc' | 'desc'

  function getNumeric(value) {
    const n = Number(value);
    return Number.isFinite(n) ? n : NaN;
  }

  function getSortValue(player, key) {
    switch (key) {
      case 'level': {
        if (player?.level != null) return getNumeric(player.level);
        const exp = player?.stats?.Bedwars?.Experience ?? player?.experience;
        return exp != null ? Math.floor(getBedWarsLevel(Number(exp))) : 0;
      }
      case 'networkLevel': return getNumeric(player?.networkLevel ?? 0);
      case 'ws': return getNumeric(player?.ws ?? 0);
      case 'fkdr': return getNumeric(player?.fkdr ?? 0);
      case 'wlr': return getNumeric(player?.wlr ?? 0);
      case 'bblr': return getNumeric(player?.bblr ?? 0);
      case 'fk': return getNumeric(player?.fk ?? 0);
      case 'fd': return getNumeric(player?.fd ?? 0);
      case 'wins': return getNumeric(player?.wins ?? 0);
      case 'losses': return getNumeric(player?.losses ?? 0);
      case 'bedsBroken': return getNumeric(player?.bedsBroken ?? 0);
      case 'bedsLost': return getNumeric(player?.bedsLost ?? 0);
      case 'kills': return getNumeric(player?.kills ?? 0);
      case 'deaths': return getNumeric(player?.deaths ?? 0);
      case 'winsPerLevel': return getNumeric(STATS.winsPerLevel.calc(player));
      case 'fkPerLevel': return getNumeric(STATS.fkPerLevel.calc(player));
      case 'bedwarsScore': return getNumeric(STATS.bedwarsScore.calc(player));
      case 'mfkdr': return getNumeric(player?.mfkdr ?? NaN);
      case 'mwlr': return getNumeric(player?.mwlr ?? NaN);
      case 'mbblr': return getNumeric(player?.mbblr ?? NaN);
      default: return 0;
    }
  }

  // Insert row for this player (used by both fetchPlayerStats and renderTable)
  function renderPlayerRow(player, wasNick, dynamicStats) {
    console.log('[DEBUG] renderPlayerRow', player?.name, player);
    const levelHTML = updatePlayerLevel(player);
    const realName = player.name;
    const originalNick = originalNicks[realName.toLowerCase()] || getNickFromReal(realName);
    const hasNick = !!originalNick;
    const showNick = hasNick && nickDisplayMode === 'nick';
    const displayName = showNick ? originalNick : realName;
    const tooltipOther = hasNick ? (showNick ? realName : originalNick) : '';
    const selectedStats = dynamicStats || statSettings.layout.filter(k => k && statSettings.visible.includes(k));
    const dynamicCells = selectedStats.map(key => {
      if (key === 'level' || key === 'name') return '';
      let val = player[key];
      // Support calc functions for derived stats if backend didn't send field
      const statDef = STATS[key];
      if ((val == null || (typeof val === 'number' && isNaN(val))) && statDef && typeof statDef.calc === 'function') {
        try { val = statDef.calc(player); } catch { val = null; }
      }
      const colorStyle = getColorForValue(key, typeof val === 'number' ? val : Number(val));
      return `<td class="metric" ${colorStyle}>${fmt(val)}</td>`;
    }).join('');
    const orderedCells = [
      `<td class="lvl">${levelHTML}</td>`,
      `<td class="name">
        ${(() => {
          if (showNick) return `<span class="rank-tag" style="color:#ffffff">[NICK]</span>`;
          return player.rankTag ? `<span class="rank-tag" style="color:${player.rankColor || '#ffffff'}">${player.rankTag}</span>` : '';
        })()}
        ${showNick ? `<span class="player-name" style="color:#ffffff">${esc(displayName)}</span>` : (player.rankColor ? `<span class="player-name" style="color:${player.rankColor}">${esc(displayName)}</span>` : `${esc(displayName)}`)}
        ${hasNick ? `<span class="nick-indicator" title="${esc(tooltipOther)}"><svg class="icon" aria-hidden="true"><use href="#i-ghost"/></svg></span>` : ''}
      </td>`,
      dynamicCells
    ].join('');
    rows.insertAdjacentHTML("beforeend", `
      <tr data-name="${escAttr(player.name)}">
        ${orderedCells}
        <td class="actions">
          <button class="icon-btn row-menu-btn">⋮</button>
          <div class="menu">
            <button class="remove-btn">Remove</button>
          </div>
        </td>
      </tr>
    `);
  }

    // Hypixel color constants (used for level/star coloring)
    const HypixelColors = {
        "AQUA": "#55FFFF",
        "BLACK": "#000000",
        "BLUE": "#5555FF",
        "DARK_AQUA": "#00AAAA",
        "DARK_BLUE": "#0000AA",
        "DARK_GRAY": "#555555",
        "DARK_GREEN": "#00AA00",
        "DARK_PURPLE": "#AA00AA",
        "DARK_RED": "#AA0000",
        "GOLD": "#FFAA00",
        "GRAY": "#AAAAAA",
        "GREEN": "#55FF55",
        "LIGHT_PURPLE": "#FF55FF",
        "RED": "#FF5555",
        "WHITE": "#FFFFFF",
        "YELLOW": "#FFFF55"
    };

    function formatStars(level, star, ...colors) {
      const span = (color, string) => `<span style="color: ${color}">${string}</span>`;
      let template = ``;
      const levelString = level.toString();

      if (colors.length === levelString.length + 3) {
        const digits = levelString.split('');
        template += span(colors[0], "[");
        for (let i = 0; i < digits.length; i++) {
          template += span(colors[i + 1], digits[i]);
        }
        template += span(colors[colors.length - 2], star);
        template += span(colors[colors.length - 1], "]");
      } else {
        template += span(colors.length == 1 ? colors[0] : '#AAAAAA', `[${level}${star}]`);
      }

      return template;
    }

    function starColor(stars) {
      const { AQUA, BLACK, BLUE, DARK_AQUA, DARK_BLUE, DARK_GRAY, DARK_GREEN, DARK_PURPLE, DARK_RED, GOLD, GRAY, GREEN, LIGHT_PURPLE, RED, WHITE, YELLOW } = HypixelColors;

      if (stars < 100) return formatStars(stars, '✫', GRAY);
      else if (stars < 200) return formatStars(stars, '✫', WHITE);
      else if (stars < 300) return formatStars(stars, '✫', GOLD);
      else if (stars < 400) return formatStars(stars, '✫', AQUA);
      else if (stars < 500) return formatStars(stars, '✫', DARK_GREEN);
      else if (stars < 600) return formatStars(stars, '✫', DARK_AQUA);
      else if (stars < 700) return formatStars(stars, '✫', DARK_RED);
      else if (stars < 800) return formatStars(stars, '✫', LIGHT_PURPLE);
      else if (stars < 900) return formatStars(stars, '✫', BLUE);
      else if (stars < 1000) return formatStars(stars, '✫', DARK_PURPLE);
      else if (stars < 1100) return formatStars(stars, '✫', RED, GOLD, YELLOW, GREEN, AQUA, LIGHT_PURPLE, DARK_PURPLE);
      else if (stars < 1200) return formatStars(stars, '✪', GRAY, WHITE, WHITE, WHITE, WHITE, GRAY, GRAY);
      else if (stars < 1300) return formatStars(stars, '✪', GRAY, YELLOW, YELLOW, YELLOW, YELLOW, GOLD, GRAY);
      else if (stars < 1400) return formatStars(stars, '✪', GRAY, AQUA, AQUA, AQUA, AQUA, DARK_AQUA, GRAY);
      else if (stars < 1500) return formatStars(stars, '✪', GRAY, GREEN, GREEN, GREEN, GREEN, DARK_GREEN, GRAY);
      else if (stars < 1600) return formatStars(stars, '✪', GRAY, DARK_AQUA, DARK_AQUA, DARK_AQUA, DARK_AQUA, BLUE, GRAY);
      else if (stars < 1700) return formatStars(stars, '✪', GRAY, RED, RED, RED, RED, DARK_RED, GRAY);
      else if (stars < 1800) return formatStars(stars, '✪', GRAY, LIGHT_PURPLE, LIGHT_PURPLE, LIGHT_PURPLE, LIGHT_PURPLE, DARK_PURPLE, GRAY);
      else if (stars < 1900) return formatStars(stars, '✪', GRAY, BLUE, BLUE, BLUE, BLUE, DARK_BLUE, GRAY);
      else if (stars < 2000) return formatStars(stars, '✪', GRAY, DARK_PURPLE, DARK_PURPLE, DARK_PURPLE, DARK_PURPLE, DARK_GRAY, GRAY);
      else if (stars < 2100) return formatStars(stars, '✪', DARK_GRAY, GRAY, WHITE, WHITE, GRAY, GRAY, DARK_GRAY);
      else if (stars < 2200) return formatStars(stars, '⚝', WHITE, WHITE, YELLOW, YELLOW, GOLD, GOLD, GOLD);
      else if (stars < 2300) return formatStars(stars, '⚝', GOLD, GOLD, WHITE, WHITE, AQUA, DARK_AQUA, DARK_AQUA);
      else if (stars < 2400) return formatStars(stars, '⚝', DARK_PURPLE, DARK_PURPLE, LIGHT_PURPLE, LIGHT_PURPLE, GOLD, YELLOW, YELLOW);
      else if (stars < 2500) return formatStars(stars, '⚝', AQUA, AQUA, WHITE, WHITE, GRAY, GRAY, DARK_GRAY);
      else if (stars < 2600) return formatStars(stars, '⚝', WHITE, WHITE, GREEN, GREEN, DARK_GRAY, DARK_GRAY, DARK_GRAY);
      else if (stars < 2700) return formatStars(stars, '⚝', DARK_RED, DARK_RED, RED, RED, LIGHT_PURPLE, LIGHT_PURPLE, DARK_PURPLE);
      else if (stars < 2800) return formatStars(stars, '⚝', YELLOW, YELLOW, WHITE, WHITE, DARK_GRAY, DARK_GRAY, DARK_GRAY);
      else if (stars < 2900) return formatStars(stars, '⚝', GREEN, GREEN, DARK_GREEN, DARK_GREEN, GOLD, GOLD, YELLOW);
      else if (stars < 3000) return formatStars(stars, '⚝', AQUA, AQUA, DARK_AQUA, DARK_AQUA, BLUE, BLUE, DARK_BLUE);
      else if (stars < 3100) return formatStars(stars, '⚝', YELLOW, YELLOW, GOLD, GOLD, RED, RED, DARK_RED);
      else if (stars < 3200) return formatStars(stars, '✥', BLUE, BLUE, AQUA, AQUA, GOLD, GOLD, YELLOW);
      else if (stars < 3300) return formatStars(stars, '✥', RED, DARK_RED, GRAY, GRAY, DARK_RED, RED, RED);
      else if (stars < 3400) return formatStars(stars, '✥', BLUE, BLUE, BLUE, LIGHT_PURPLE, RED, RED, DARK_RED);
      else if (stars < 3500) return formatStars(stars, '✥', DARK_GREEN, GREEN, LIGHT_PURPLE, LIGHT_PURPLE, DARK_PURPLE, DARK_PURPLE, DARK_GREEN);
      else if (stars < 3600) return formatStars(stars, '✥', RED, RED, DARK_RED, DARK_RED, DARK_GREEN, GREEN, GREEN);
      else if (stars < 3700) return formatStars(stars, '✥', GREEN, GREEN, GREEN, AQUA, BLUE, BLUE, DARK_BLUE);
      else if (stars < 3800) return formatStars(stars, '✥', DARK_RED, DARK_RED, RED, RED, AQUA, DARK_AQUA, DARK_AQUA);
      else if (stars < 3900) return formatStars(stars, '✥', DARK_BLUE, DARK_BLUE, BLUE, DARK_PURPLE, DARK_PURPLE, LIGHT_PURPLE, DARK_BLUE);
      else if (stars < 4000) return formatStars(stars, '✥', RED, RED, GREEN, GREEN, AQUA, BLUE, BLUE);
      else if (stars < 4100) return formatStars(stars, '✥', DARK_PURPLE, DARK_PURPLE, RED, RED, GOLD, GOLD, YELLOW);
      else if (stars < 4200) return formatStars(stars, '✥', YELLOW, YELLOW, GOLD, RED, LIGHT_PURPLE, LIGHT_PURPLE, DARK_PURPLE);
      else if (stars < 4300) return formatStars(stars, '✥', DARK_BLUE, BLUE, DARK_AQUA, AQUA, WHITE, GRAY, GRAY);
      else if (stars < 4400) return formatStars(stars, '✥', BLACK, DARK_PURPLE, DARK_GRAY, DARK_GRAY, DARK_PURPLE, DARK_PURPLE, BLACK);
      else if (stars < 4500) return formatStars(stars, '✥', DARK_GREEN, DARK_GREEN, GREEN, YELLOW, GOLD, DARK_PURPLE, LIGHT_PURPLE);
      else if (stars < 4600) return formatStars(stars, '✥', WHITE, WHITE, AQUA, AQUA, DARK_AQUA, DARK_AQUA, DARK_AQUA);
      else if (stars < 4700) return formatStars(stars, '✥', DARK_AQUA, AQUA, YELLOW, YELLOW, GOLD, LIGHT_PURPLE, DARK_PURPLE);
      else if (stars < 4800) return formatStars(stars, '✥', WHITE, DARK_RED, RED, RED, BLUE, DARK_BLUE, BLUE);
      else if (stars < 4900) return formatStars(stars, '✥', DARK_PURPLE, DARK_PURPLE, RED, GOLD, YELLOW, AQUA, DARK_AQUA);
      else if (stars < 5000) return formatStars(stars, '✥', DARK_GREEN, GREEN, WHITE, WHITE, GREEN, GREEN, DARK_GREEN);
      else return formatStars(stars, '✥', DARK_RED, DARK_RED, DARK_PURPLE, BLUE, BLUE, DARK_BLUE, BLACK);
    }

    function getBedWarsLevel(exp) {
      let level = 100 * (Math.floor(exp / 487000));
      exp = exp % 487000;
      if (exp < 500) return level + exp / 500;
      level++;
      if (exp < 1500) return level + (exp - 500) / 1000;
      level++;
      if (exp < 3500) return level + (exp - 1500) / 2000;
      level++;
      if (exp < 7000) return level + (exp - 3500) / 3500;
      level++;
      exp -= 7000;
      return level + exp / 5000;
    }

    // Update player level display. Accepts either a player object with stats or a stats-like object
    function updatePlayerLevel(player) {
      const exp = player?.stats?.Bedwars?.Experience ?? player?.experience;
      if (exp != null && !isNaN(Number(exp))) {
        const level = Math.floor(getBedWarsLevel(Number(exp)));
        return starColor(level);
      }
      const levelNum = player?.level ?? 0;
      return `[${fmt(levelNum)}✫]`;
    }

    // Fetch stats for a single player and update UI
    async function fetchPlayerStats(name) {
      console.log('[DEBUG] fetchPlayerStats called for', name);
      // Normalize by real name to reduce duplicates
      const realName = getRealName(name);
      const key = realName.toLowerCase();
      if (displayedPlayers.has(key)) return; // Skip if already displayed
      const wasNick = isNick(name);
      
      const res = await ipcRenderer.invoke("bedwars:stats", realName);

      if (res.error) {
        console.error('[DEBUG] Stats error for', realName, ':', res.error);
        return;
      }

  console.log('Received stats for', realName, ':', res);

  const normName = String(res.name || realName).toLowerCase();
  displayedPlayers.add(normName);
  playerCache[normName] = res;
  if (wasNick) { nickedPlayers.add(normName); originalNicks[res.name.toLowerCase()] = name; } else nickedPlayers.delete(normName);
      
      // After caching stats simply re-render table (row rendering centralised there)
      renderTable();

      // Rebind menu events for the new row
      bindMenus();
    }

    // Remove a player row and all state completely
    function removePlayer(name) {
      const row = rows.querySelector(`tr[data-name="${escAttr(name)}"]`);
      const key = String(getRealName(name) || name).toLowerCase();
      if (row) row.remove();
      displayedPlayers.delete(key);
      playerSources.delete(key);
  nickedPlayers.delete(key);
      delete originalNicks[key];
      updateOverlaySize();
    }

    // Add/track a source for a player
    function addPlayerSource(name, source) {
      const key = String(getRealName(name) || name).toLowerCase();
      const set = playerSources.get(key) || new Set();
      set.add(source);
      playerSources.set(key, set);
    }

    function removePlayerSource(name, source) {
      const key = String(getRealName(name) || name).toLowerCase();
      const set = playerSources.get(key);
      if (!set) return;
      set.delete(source);
      if (set.size === 0) {
        removePlayer(name);
      } else {
        playerSources.set(key, set);
        updateOverlaySize();
      }
    }

    function clearAllButUsername() {
      // Remove all non-username-backed players; keep username-only
      for (const [key, set] of Array.from(playerSources.entries())) {
        if (set.has('username')) {
          // Keep only username source
          playerSources.set(key, new Set(['username']));
          continue;
        }
        // remove entirely
        const tr = rows.querySelector(`tr[data-name="${escAttr(key)}"]`);
        if (tr) tr.remove();
        displayedPlayers.delete(key);
        playerSources.delete(key);
  nickedPlayers.delete(key);
    delete originalNicks[key];
      }
      // Clean any stray rows
      rows.querySelectorAll('tr[data-name]').forEach(tr => {
        const dn = tr.getAttribute('data-name')?.toLowerCase();
        if (dn && !playerSources.has(dn)) tr.remove();
      });
      updateOverlaySize(); // Update window size after clearing
    }

    function addPlayer(name, source) {
      if (!name) return;
      addPlayerSource(name, source);
      const key = String(getRealName(name) || name).toLowerCase();
      if (!displayedPlayers.has(key)) {
        fetchPlayerStats(name).then(() => {
          updateOverlaySize();
          renderTable();
        });
      }
    }

    // Handle incoming player lists (from chat logger)
    ipcRenderer.on('chat:players', (_e, newPlayers) => {
      try {
        if (!Array.isArray(newPlayers)) return;
        // Treat as /who list → source 'who'
        newPlayers.forEach(player => {
          if (!player || typeof player !== 'string') return;
          addPlayer(player, 'who');
        });

      } catch (err) {
        console.error('Error handling chat:players', err);
      }
    });

    // Remove on Final Death (if enabled in settings)
    ipcRenderer.on('chat:finalKill', (_e, name) => {
      try {
        if (!name || typeof name !== 'string') return;
        if (sourcesSettings?.game?.removeOnDeath) {
          // Only remove the 'who' source; keep other sources (manual, party, chat, username)
          removePlayerSource(name, 'who');
        }
      } catch (err) {
        console.error('Error handling chat:finalKill', err);
      }
    });

    // Party members handling (similar to players but always add)
    ipcRenderer.on('chat:party', (_e, members) => {
      try {
        if (!Array.isArray(members)) return;
        members.forEach(member => {
          if (!member || typeof member !== 'string') return;
          addPlayer(member, 'party');
        });
      } catch (err) {
        console.error('Error handling chat:party', err);
      }
    });

    function esc(s) { return s.replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c])); }
    function escAttr(s) { return esc(s).replace(/"/g, "&quot;"); }
    function fmt(n) { return (n == null || isNaN(n)) ? "—" : n; }
    
    // Nick management
    let nicks = JSON.parse(localStorage.getItem('nicks') || '[]');

    function saveNicks() {
      localStorage.setItem('nicks', JSON.stringify(nicks));
    }

    function getRealName(name) {
      const nick = nicks.find(n => n.nick.toLowerCase() === name.toLowerCase());
      return nick ? nick.real : name;
    }
    function getNickFromReal(realName) {
      const entry = nicks.find(n => n.real.toLowerCase() === realName.toLowerCase());
      return entry ? entry.nick : undefined;
    }

    function isNick(name) {
      return nicks.some(n => n.nick.toLowerCase() === name.toLowerCase());
    }

    // Nicks Panel UI
    function renderNicks() {
      const list = document.getElementById('nicksList');
      if (!list) return;

      list.innerHTML = nicks.map(({nick, real}) => `
        <div class="nick-row" data-nick="${escAttr(nick)}">
          <span class="nick-name">${esc(nick)}</span>
          <span class="nick-real">${esc(real)}</span>
          <button class="delete-btn" title="Remove nick">✕</button>
        </div>
      `).join('');

      list.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', e => {
          const row = e.target.closest('.nick-row');
          const nick = row.getAttribute('data-nick');
          nicks = nicks.filter(n => n.nick !== nick);
          saveNicks();
          renderNicks();
          renderTable();
        });
      });
    }

    // Nick form handling
    const addNickBtn = document.getElementById('addNickBtn');
    const addNickForm = document.getElementById('addNickForm');
    const nickInput = document.getElementById('nickInput');
    const realNameInput = document.getElementById('realNameInput');
    const saveNickBtn = document.getElementById('saveNickBtn');
    const nickDisplayModeSelect = document.getElementById('nickDisplayMode');
    if (nickDisplayModeSelect) {
      nickDisplayModeSelect.value = nickDisplayMode;
      nickDisplayModeSelect.addEventListener('change', () => {
        nickDisplayMode = nickDisplayModeSelect.value;
        localStorage.setItem('nickDisplayMode', nickDisplayMode);
        renderTable();
      });
    }

    // Show/hide form when + button is clicked
    addNickBtn?.addEventListener('click', () => {
      addNickForm.style.display = 'block';
      nickInput.focus();
    });

    // Save nick when form is submitted
    saveNickBtn?.addEventListener('click', () => {
      const nick = nickInput.value.trim();
      const real = realNameInput.value.trim();
      
      if (nick && real) {
        if (!nicks.some(n => n.nick.toLowerCase() === nick.toLowerCase())) {
          nicks.push({nick, real});
          saveNicks();
          renderNicks();
          renderTable();
          
          // Reset form
          nickInput.value = '';
          realNameInput.value = '';
          addNickForm.style.display = 'none';
        }
      }
    });

    // Enter in second input also submits
    realNameInput?.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        saveNickBtn.click();
      }
    });

    // Escape closes form
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape' && addNickForm.style.display === 'block') {
        addNickForm.style.display = 'none';
        nickInput.value = '';
        realNameInput.value = '';
      }
    });

    // Chat strings → add player who matches any configured string (case-insensitive)
    ipcRenderer.on('chat:message', (_e, payload) => {
      try {
        if (!payload || !sourcesSettings?.chat?.enabled) return;
        const { name, text } = payload;
        if (!name || !text) return;
        const patterns = (sourcesSettings.chat.strings || []).filter(Boolean).map(String);
        if (!patterns.length) return;
        const t = String(text).toLowerCase();
        if (patterns.some(p => t.includes(String(p).toLowerCase()))) {
          addPlayer(name, 'chat');
        }
      } catch (err) {
        console.error('Error handling chat:message', err);
      }
    });

    async function fetchAll() {
      // Add all queued players as manual entries (does not clear current list)
      for (const inputName of queue) {
        addPlayer(inputName, 'manual');
      }
      queue = [];
    }

    function bindMenus() {
      const btns = Array.from(document.querySelectorAll(".row-menu-btn"));
      const removes = Array.from(document.querySelectorAll(".remove-btn"));

      btns.forEach(btn => {
        btn.addEventListener("click", e => {
          e.stopPropagation();
          closeAllMenus();
          const menu = btn.nextElementSibling;
          menu.classList.add("open");
        });
      });

      removes.forEach(b => {
        b.addEventListener("click", e => {
          e.stopPropagation();
          const tr = b.closest("tr");
          const name = tr.getAttribute("data-name");
          queue = queue.filter(n => n.toLowerCase() !== name.toLowerCase());
          removePlayer(name);
          closeAllMenus();
        });
      });

      document.addEventListener("click", closeAllMenus);
    }

    function closeAllMenus() {
      document.querySelectorAll(".menu.open").forEach(m => m.classList.remove("open"));
    }

    input.addEventListener("keydown", e => {
      if (e.key === "Enter") {
        const names = input.value.split(",").map(s => s.trim()).filter(Boolean);
        queue.push(...names);
        input.value = "";
        fetchAll();
      }
    });

    document.getElementById("clearAll").addEventListener("click", () => {
      queue = [];
      clearAllButUsername();
      updateOverlaySize();
    });

    document.getElementById("refresh").addEventListener("click", fetchAll);
    document.getElementById("minBtn").addEventListener("click", () => ipcRenderer.send("window:minimize"));
    document.getElementById("closeBtn").addEventListener("click", () => ipcRenderer.send("window:close"));

    // Shortcut-triggered actions from main
    ipcRenderer.on('shortcut:refresh', () => fetchAll());
    ipcRenderer.on('shortcut:clear', () => {
      queue = [];
      clearAllButUsername();
    });

    // --- resize grips
    let resizing = null;
    function onDown(e) {
      const edge = e.target.getAttribute("data-edge");
      if (!edge) return;
      resizing = { edge, startX: e.screenX, startY: e.screenY };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp, { once: true });
    }
    function onMove(e) {
      if (!resizing) return;
      const dx = e.screenX - resizing.startX;
      const dy = e.screenY - resizing.startY;
      ipcRenderer.invoke("window:resize", { edge: resizing.edge, dx, dy });
      resizing.startX = e.screenX;
      resizing.startY = e.screenY;
    }
    function onUp() {
      resizing = null;
      window.removeEventListener("mousemove", onMove);
    }

    // Sidebar toggle + interactions
    const menuBtn = document.getElementById('menuBtn');
    const sidebar = document.getElementById('sidebar');

    if (menuBtn && sidebar) {
      menuBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const opened = sidebar.classList.toggle('open');
        sidebar.setAttribute('aria-hidden', String(!opened));
        updateOverlaySize(); // recalculate when sidebar opens/closes
      });

      // Close sidebar when clicking outside
      document.addEventListener('click', (e) => {
        if (!sidebar.classList.contains('open')) return;
        if (e.target.closest && (e.target.closest('#sidebar') || e.target.closest('#menuBtn'))) return;
        sidebar.classList.remove('open');
        sidebar.setAttribute('aria-hidden', 'true');
        updateOverlaySize(); // recalculate
      });

      // Close with Escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && sidebar.classList.contains('open')) {
          sidebar.classList.remove('open');
          sidebar.setAttribute('aria-hidden', 'true');
          updateOverlaySize(); // recalculate
        }
      });

      // Entfernt: generische Aktivierung aller Nav-Items (führte zu Konflikten mit Sub-Items)
    }

    document.querySelectorAll(".grip").forEach(g => g.addEventListener("mousedown", onDown));
    
    // --- Panel switching
    function showPanel(id) {
      document.querySelectorAll('.panel').forEach(p => {
        p.classList.toggle('active', p.id === `panel-${id}`);
      });
      localStorage.setItem('activePanel', id);

      // Update nur Top-Level-Navigation (Home, Nicks, Settings) – keine Sub-Items
      document.querySelectorAll('.nav > .nav-item:not(.sub-item)').forEach(b => {
        b.classList.toggle('active', b.getAttribute('data-panel') === id);
      });

      updateOverlaySize(); // recalculate when panel switches
    }

    // Update nav item click handler
    document.querySelectorAll('.nav-item').forEach(btn => {
      btn.addEventListener('click', () => {
        const panel = btn.getAttribute('data-panel');
        showPanel(panel);
      });
    });

    // Immer mit Home starten
    showPanel('home');

    // Sorting header click handling
    (function initSorting(){
      const thead = document.querySelector('#table thead');
      if (!thead) return;
      thead.addEventListener('click', (e) => {
        const th = e.target.closest('th');
        if (!th || !th.dataset.sortKey) return;
        const key = th.dataset.sortKey;
        if (sortKey === key) {
          sortDir = sortDir === 'asc' ? 'desc' : 'asc';
        } else {
          sortKey = key; sortDir = 'asc';
        }
        // visual state
        document.querySelectorAll('#table thead th').forEach(h => h.classList.remove('sort-asc','sort-desc'));
        th.classList.add(sortDir === 'asc' ? 'sort-asc' : 'sort-desc');
        renderTable();
      });
    })();

    // Add new nick
    document.getElementById('addNickBtn')?.addEventListener('click', () => {
      const nick = prompt('Enter nick:');
      if (!nick) return;
      const real = prompt('Enter real name:');
      if (!real) return;

      if (!nicks.some(n => n.nick === nick)) {
        nicks.push({nick, real});
        saveNicks();
        renderNicks();
        renderTable();
      }
    });

    // Initial render
    renderNicks();

    // Stat column definitions
    const STATS = {
      // Core identity
      level: { name: 'Level', short: 'Lvl', type: 'number', colorRules: true },
      name: { name: 'Name', short: 'Name', type: 'text' },
      networkLevel: { name: 'Network Level', short: 'Nwl', type: 'number', colorRules: true },

      // Streaks
      ws: { name: 'Win Streak', short: 'WS', type: 'number', colorRules: true },

      // Ratios
      fkdr: { name: 'Final K/D Ratio', short: 'FKDR', type: 'number', colorRules: true },
      wlr: { name: 'Win/Loss Ratio', short: 'WLR', type: 'number', colorRules: true },
      bblr: { name: 'Bed Break/Loss Ratio', short: 'BBLR', type: 'number', colorRules: true },
      mfkdr: { name: 'Monthly Final K/D Ratio', short: 'MFKDR', type: 'number', colorRules: true },
      mwlr: { name: 'Monthly Win/Loss Ratio', short: 'MWLR', type: 'number', colorRules: true },
      mbblr: { name: 'Monthly Bed Break/Loss Ratio', short: 'MBBLR', type: 'number', colorRules: true },

      // Totals
      fk: { name: 'Final Kills', short: 'FK', type: 'number', colorRules: true },
      fd: { name: 'Final Deaths', short: 'FD', type: 'number', colorRules: true },
      wins: { name: 'Wins', short: 'Wins', type: 'number', colorRules: true },
      losses: { name: 'Losses', short: 'Losses', type: 'number', colorRules: true },
      bedsBroken: { name: 'Beds Broken', short: 'BB', type: 'number', colorRules: true },
      bedsLost: { name: 'Beds Lost', short: 'BL', type: 'number', colorRules: true },
      kills: { name: 'Kills', short: 'K', type: 'number', colorRules: true },
      deaths: { name: 'Deaths', short: 'D', type: 'number', colorRules: true },

      // Per-Level metrics (derived)
      winsPerLevel: { name: 'Wins per Level', short: 'W/Lvl', type: 'number', colorRules: true, calc: (p) => +( (p.wins ?? 0) / Math.max(1, p.level ?? 0) ).toFixed(2) },
      fkPerLevel: { name: 'Final Kills per Level', short: 'FK/Lvl', type: 'number', colorRules: true, calc: (p) => +( (p.fk ?? 0) / Math.max(1, p.level ?? 0) ).toFixed(2) },

      // Derived score
      bedwarsScore: { name: 'Bedwars Score', short: 'Score', type: 'number', colorRules: true, calc: (p) => +(((p.fkdr ?? 0) * (p.wlr ?? 0) * ((p.level ?? 0)/100))).toFixed(2) },

      // Guild (meta)
      guildName: { name: 'Guild Name', short: 'Guild', type: 'text' },
      guildTag: { name: 'Guild Tag', short: 'Tag', type: 'text' },
    };

    // Load/save stat settings
    let statSettings = JSON.parse(localStorage.getItem('statSettings') || JSON.stringify({
      visible: Object.keys(STATS),
      order: Object.keys(STATS),
      layout: ['ws','fkdr','wlr','bblr','fk','wins',null,null,null,null],
      colorRules: {
        level: [
          { op: '>=', value: 300, color: '#00ff00' },
          { op: '>=', value: 100, color: '#ffff00' }
        ],
        fkdr: [
          { op: '>=', value: 100, color: '#ff00ff' },
          { op: '>=', value: 50, color: '#ff69b4' },
          { op: '>=', value: 30, color: '#dc143c' },
          { op: '>=', value: 20, color: '#ff7f50' },
          { op: '>=', value: 10, color: '#ffa500' },
          { op: '>=', value: 7, color: '#ffff00' },
          { op: '>=', value: 5, color: '#00ff00' },
          { op: '>=', value: 3, color: '#00ff00' },
          { op: '>=', value: 1, color: '#ffffff' },
          { op: '>=', value: 0, color: '#808080' }
        ],
        wlr: [
          { op: '>=', value: 5, color: '#ff0000' },
          { op: '>=', value: 3, color: '#ffff00' }
        ],
        ws: [
          { op: '>=', value: 100, color: '#ff0000' },
          { op: '>=', value: 50, color: '#ffff00' }
        ]
      }
    }));
    if (!Array.isArray(statSettings.layout)) {
      statSettings.layout = ['ws','fkdr','wlr','bblr','fk','wins','bedwarsScore','winsPerLevel','fkPerLevel',null];
    }

    // Migration: convert legacy color names to hex once on load
    (function migrateColorRules() {
      const map = { good: '#00ff00', warn: '#ffff00', bad: '#ff0000' };
      try {
        if (statSettings && statSettings.colorRules) {
          let changed = false;
          for (const key of Object.keys(statSettings.colorRules)) {
            const arr = statSettings.colorRules[key];
            if (!Array.isArray(arr)) continue;
            for (const rule of arr) {
              if (rule && typeof rule.color === 'string' && map[rule.color]) {
                rule.color = map[rule.color];
                changed = true;
              }
            }
          }
          if (changed) {
            localStorage.setItem('statSettings', JSON.stringify(statSettings));
          }
        }
      } catch {}
    })();

    function saveStatSettings() {
      localStorage.setItem('statSettings', JSON.stringify(statSettings));
      renderTable();
      renderStatLayoutSlots();
      renderStatLayoutPalette();
    }

    // Rebuild the entire table from cache (used when stat settings change)
    function renderTable() {
      const table = document.getElementById('table');
      if (!table) return;
      console.log('[DEBUG] renderTable called. displayedPlayers:', Array.from(displayedPlayers));
      const dynamicStats = statSettings.layout.filter(k => k && statSettings.visible.includes(k));
      const colgroup = table.querySelector('colgroup');
      const thead = table.querySelector('thead');
      if (colgroup) {
        colgroup.innerHTML = ['c-lvl','c-name', ...dynamicStats.map(s => 'c-'+s), 'c-actions']
          .map(cls => `<col class="${cls}">`).join('');
      }
      if (thead) {
        thead.innerHTML = `<tr>
          <th data-sort-key="level">Lvl</th>
          <th>Name</th>
          ${dynamicStats.map(s => {
            const stat = STATS[s];
            const sortable = stat.type === 'number';
            const label = stat.short || stat.name;
            return `<th class="metric-h" ${sortable ? `data-sort-key="${s}"` : ''}>${label}</th>`;
          }).join('')}
          <th></th>
        </tr>`;
      }
      const tbody = document.getElementById('rows');
      if (!tbody) return;
      tbody.innerHTML = '';
      let entries = Array.from(displayedPlayers).map(n => [n, playerCache[n]]).filter(([,p]) => Boolean(p));
      if (sortKey) {
        const dir = sortDir === 'asc' ? 1 : -1;
        entries.sort(([, a], [, b]) => {
          const va = getSortValue(a, sortKey);
          const vb = getSortValue(b, sortKey);
          const na = Number.isFinite(va) ? va : -Infinity;
          const nb = Number.isFinite(vb) ? vb : -Infinity;
          return dir * (na - nb);
        });
      }
      for (const [normName, player] of entries) {
        const wasNick = typeof nickedPlayers !== 'undefined' && nickedPlayers.has(normName);
        renderPlayerRow(player, wasNick, dynamicStats);
      }
      bindMenus();
      updateOverlaySize();
    }

    // Color rules modal
    function showColorRules(column) {
      const modal = document.getElementById('colorRulesModal');
      const title = document.getElementById('colorRuleTitle');
      const rulesList = document.getElementById('colorRulesList');
      
      title.textContent = STATS[column].name;
      modal.classList.add('open');

      function renderRules() {
        const rules = statSettings.colorRules[column] || [];
        rulesList.innerHTML = rules.map((rule, i) => {
          // Migration: convert old CSS variable names to hex colors
          let color = rule.color;
          if (color === 'good') color = '#00ff00';
          if (color === 'warn') color = '#ffff00';
          if (color === 'bad') color = '#ff0000';
          return `
          <div class="color-rule" data-index="${i}">
            <select class="rule-operator">
              <option value=">=" ${rule.op === '>=' ? 'selected' : ''}>≥</option>
              <option value="<" ${rule.op === '<' ? 'selected' : ''}>＜</option>
            </select>
            <input type="number" class="rule-value" value="${rule.value}" step="0.1">
            <div class="color-picker">
              <div class="color-preview" style="background: ${color}"></div>
              <input type="color" class="color-input" value="${color}">
            </div>
            <button class="rule-delete">×</button>
          </div>
        `;
        }).join('');

        // Bind rule events
        rulesList.querySelectorAll('.color-rule').forEach(rule => {
          const i = parseInt(rule.dataset.index);
          
          rule.querySelector('.rule-operator').addEventListener('change', e => {
            statSettings.colorRules[column][i].op = e.target.value;
            saveStatSettings();
          });

          rule.querySelector('.rule-value').addEventListener('change', e => {
            statSettings.colorRules[column][i].value = parseFloat(e.target.value);
            saveStatSettings();
          });

          rule.querySelector('.color-input').addEventListener('change', e => {
            statSettings.colorRules[column][i].color = e.target.value;
            rule.querySelector('.color-preview').style.background = e.target.value;
            saveStatSettings();
          });

          rule.querySelector('.rule-delete').addEventListener('click', () => {
            statSettings.colorRules[column].splice(i, 1);
            saveStatSettings();
            renderRules();
          });
        });
      }

      renderRules();

      // Add rule button
      document.querySelector('.add-rule-btn').onclick = () => {
        if (!statSettings.colorRules[column]) {
          statSettings.colorRules[column] = [];
        }
        statSettings.colorRules[column].push({
          op: '>=',
          value: 0,
          color: '#00ff00'
        });
        saveStatSettings();
        renderRules();
      };

      // Close modal
      modal.querySelector('.modal-close').onclick = () => {
        modal.classList.remove('open');
      };
    }

    // Initialize settings
    renderStatLayoutPalette();
    renderStatLayoutSlots();

    // --- Layout Editor Functions ---
    function renderStatLayoutPalette() {
      const palette = document.getElementById('layoutPalette');
      if (!palette) return;
      const used = new Set(statSettings.layout.filter(Boolean));
      const stats = Object.keys(STATS).filter(k => !['level','name'].includes(k));
  palette.innerHTML = stats.map(k => `<div class="stat-pill" draggable="${used.has(k)?'false':'true'}" data-stat="${k}" ${used.has(k)?'data-used="1"':''}>${STATS[k].short || STATS[k].name}</div>`).join('');
      palette.querySelectorAll('.stat-pill[draggable="true"]').forEach(pill => {
        pill.addEventListener('dragstart', e => {
          e.dataTransfer.setData('text/stat', pill.dataset.stat);
        });
      });
    }
    function renderStatLayoutSlots() {
      const slotsEl = document.getElementById('layoutSlots');
      if (!slotsEl) return;
      const layout = statSettings.layout;
      slotsEl.innerHTML = layout.map((stat, i) => {
        if (!stat) return `<div class="slot" data-slot="${i}" data-empty="1">Empty</div>`;
  const label = STATS[stat]?.short || STATS[stat]?.name || stat;
  return `<div class="slot filled" data-slot="${i}" data-stat="${stat}">${label}<button class="slot-remove" title="Remove">×</button></div>`;
      }).join('');
      slotsEl.querySelectorAll('.slot').forEach(slot => {
        slot.addEventListener('dragover', e => {
          e.preventDefault();
          slot.classList.add('drag-over');
        });
        slot.addEventListener('dragleave', () => slot.classList.remove('drag-over'));
        slot.addEventListener('drop', e => {
          e.preventDefault();
          slot.classList.remove('drag-over');
          const stat = e.dataTransfer.getData('text/stat');
          if (!stat) return;
          // Remove existing occurrence
          const idxExisting = statSettings.layout.indexOf(stat);
          if (idxExisting !== -1) statSettings.layout[idxExisting] = null;
          // Put into this slot
          const idx = parseInt(slot.dataset.slot);
          statSettings.layout[idx] = stat;
          saveStatSettings();
        });
        // Click on filled slot: open color rules (if stat supports it)
        if (!slot.dataset.empty && slot.dataset.stat) {
          const statKey = slot.dataset.stat;
          if (STATS[statKey]?.colorRules) {
            slot.style.cursor = 'pointer';
            slot.addEventListener('click', e => {
              // Ignore click if user clicked remove button
              if (e.target.closest('.slot-remove')) return;
              showColorRules(statKey);
            });
          }
        }
        const removeBtn = slot.querySelector('.slot-remove');
        if (removeBtn) {
          removeBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // prevent triggering slot click
            const idx = parseInt(slot.dataset.slot);
            statSettings.layout[idx] = null;
            saveStatSettings();
          });
        }
      });
    }

    // --- Keyboard Shortcuts
    const ACTIONS = [
      { id: 'toggleOverlay', label: 'Hide or show' },
      { id: 'refreshAll', label: 'Refresh all players' },
      { id: 'clearAll', label: 'Remove all players' },
      { id: 'toggleClickThrough', label: 'Toggle click-through' }
    ];

    const DEFAULT_SHORTCUTS = {
      toggleOverlay: 'F9',
      refreshAll: '',
      clearAll: 'F8',
      toggleClickThrough: ''
    };

    let shortcuts = JSON.parse(localStorage.getItem('shortcuts') || JSON.stringify(DEFAULT_SHORTCUTS));

    function saveShortcuts() {
      localStorage.setItem('shortcuts', JSON.stringify(shortcuts));
      // Inform main to (re)register
      ipcRenderer.invoke('shortcuts:register', shortcuts);
    }

    function renderShortcuts() {
      const grid = document.getElementById('kbGrid');
      if (!grid) return;
      grid.innerHTML = ACTIONS.map(a => `
        <div class="kb-row" data-action="${a.id}">
          <div class="kb-action">${a.label}</div>
          <div class="kb-input" tabindex="0">${shortcuts[a.id] || '—'}</div>
        </div>
      `).join('');

      grid.querySelectorAll('.kb-input').forEach(inputEl => {
        inputEl.addEventListener('click', () => startListen(inputEl));
        inputEl.addEventListener('keydown', (e) => startListen(inputEl, e));
      });
    }

    function startListen(inputEl, evt) {
      const row = inputEl.closest('.kb-row');
      const action = row.getAttribute('data-action');
      inputEl.classList.add('listening');
      inputEl.textContent = 'Press key…';

      const onKey = (e) => {
        e.preventDefault(); e.stopPropagation();
        // ESC clears the shortcut (unassigned)
        if (e.key === 'Escape') {
          shortcuts[action] = '';
          inputEl.textContent = '—';
          inputEl.classList.remove('listening');
          window.removeEventListener('keydown', onKey, true);
          saveShortcuts();
          return;
        }
        const acc = toAccelerator(e);
        shortcuts[action] = acc;
        inputEl.textContent = acc || '—';
        inputEl.classList.remove('listening');
        window.removeEventListener('keydown', onKey, true);
        saveShortcuts();
      };
      window.addEventListener('keydown', onKey, true);
    }

    function toAccelerator(e) {
      // Allow only F-keys or simple combos
      const parts = [];
      if (e.ctrlKey) parts.push('Ctrl');
      if (e.shiftKey) parts.push('Shift');
      if (e.altKey) parts.push('Alt');
      const k = e.key;
      let key = '';
      if (/^F\d{1,2}$/i.test(k)) key = k.toUpperCase();
      else if (k.length === 1) key = k.toUpperCase();
      else if (k === 'Escape') key = 'Esc';
      else if (k === ' ') key = 'Space';
      else return '';
      return [...parts, key].join('+');
    }

    // initial render and register
    renderShortcuts();
    ipcRenderer.invoke('shortcuts:register', shortcuts);

    // --- Appearance Settings
    const defaultAppearance = {
      opacity: 0.78,
      fontSize: 14,
      alwaysOnTop: true,
      autoResize: false,
      bgColor: '#14141c' // matches rgba(20,20,28,alpha)
    };

    let appearance = JSON.parse(localStorage.getItem('appearanceSettings') || JSON.stringify(defaultAppearance));

    function saveAppearance() {
      localStorage.setItem('appearanceSettings', JSON.stringify(appearance));
    }

    function hexToRgb(hex) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (!m) return { r: 20, g: 20, b: 28 };
      return { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) };
    }

    function applyAppearance() {
      const { r,g,b } = hexToRgb(appearance.bgColor);
      const rgba = `rgba(${r},${g},${b},${appearance.opacity})`;
      document.documentElement.style.setProperty('--bg', rgba);
      document.documentElement.style.setProperty('--table-font-size', appearance.fontSize + 'px');
      // also set body background directly to ensure immediate effect
      document.body && (document.body.style.background = rgba);
      // sync always-on-top with main
      ipcRenderer.invoke('window:setAlwaysOnTop', !!appearance.alwaysOnTop);
      // Update UI labels
      const ov = document.getElementById('opacityValue'); if (ov) ov.textContent = Math.round(appearance.opacity*100)+'%';
      const fv = document.getElementById('fontSizeValue'); if (fv) fv.textContent = appearance.fontSize+'px';
    }

    // Bind inputs
    const opacityRange = document.getElementById('opacityRange');
    const fontSizeRange = document.getElementById('fontSizeRange');
    const alwaysOnTopToggle = document.getElementById('alwaysOnTopToggle');
    const autoResizeToggle = document.getElementById('autoResizeToggle');
    const bgColorInput = document.getElementById('bgColorInput');

    if (opacityRange) {
      opacityRange.value = String(appearance.opacity);
      opacityRange.addEventListener('input', () => {
        appearance.opacity = Number(opacityRange.value);
        saveAppearance();
        applyAppearance();
      });
    }

    if (fontSizeRange) {
      fontSizeRange.value = String(appearance.fontSize);
      fontSizeRange.addEventListener('input', () => {
        appearance.fontSize = parseInt(fontSizeRange.value,10);
        saveAppearance();
        applyAppearance();
      });
    }

    if (alwaysOnTopToggle) {
      alwaysOnTopToggle.checked = !!appearance.alwaysOnTop;
      alwaysOnTopToggle.addEventListener('change', () => {
        appearance.alwaysOnTop = !!alwaysOnTopToggle.checked;
        saveAppearance();
        applyAppearance();
      });
    }

    if (autoResizeToggle) {
      autoResizeToggle.checked = !!appearance.autoResize;
      autoResizeToggle.addEventListener('change', () => {
        appearance.autoResize = !!autoResizeToggle.checked;
        saveAppearance();
        updateOverlaySize();
      });
    }

    if (bgColorInput) {
      bgColorInput.value = appearance.bgColor;
      bgColorInput.addEventListener('input', () => {
        appearance.bgColor = bgColorInput.value;
        saveAppearance();
        applyAppearance();
      });
    }

    // Apply on load
    applyAppearance();

    // --- Basic Settings
    const defaultBasic = {
      logFile: 'badlion',
      customLogPath: '',
      username: ''
    };

    let basicSettings = JSON.parse(localStorage.getItem('basicSettings') || JSON.stringify(defaultBasic));

    function saveBasicSettings() {
      localStorage.setItem('basicSettings', JSON.stringify(basicSettings));
      console.log('Basic settings saved:', basicSettings);
        updateSidebarUsername();
        // Ensure username entry exists when set
        if (basicSettings.username && basicSettings.username.trim()) {
          addPlayer(basicSettings.username.trim(), 'username');
        }
    }

      function updateSidebarUsername() {
        const sidebarUsernameEl = document.getElementById('sidebarUsername');
        if (sidebarUsernameEl) {
          sidebarUsernameEl.textContent = basicSettings.username || 'username';
        }
      }

    // Bind Basic inputs
    const logFileSelect = document.getElementById('logFileSelect');
    const usernameInput = document.getElementById('usernameInput');

    if (logFileSelect) {
      logFileSelect.value = basicSettings.logFile || 'badlion';
      logFileSelect.addEventListener('change', () => {
        basicSettings.logFile = logFileSelect.value;
        saveBasicSettings();
        // TODO: wenn custom, zeige Datei-Dialog oder Input-Feld
      });
    }

    if (usernameInput) {
      usernameInput.value = basicSettings.username || '';
      usernameInput.addEventListener('input', () => {
        const prev = (basicSettings.username || '').trim();
        const next = (usernameInput.value || '').trim();
        if (prev && prev.toLowerCase() !== next.toLowerCase()) {
          // Remove old username source (but keep row if other sources exist)
          removePlayerSource(prev, 'username');
        }
        basicSettings.username = next;
        saveBasicSettings();
      });
    }

      // Initialize sidebar username on load and ensure presence in list
      updateSidebarUsername();
      if (basicSettings.username && basicSettings.username.trim()) {
        addPlayer(basicSettings.username.trim(), 'username');
        renderTable();
      }

    // --- Sources Settings
    const defaultSources = {
      game: {
        enabled: true,
        addFromChat: true,
        removeOnDeath: true,
        removeOnReconnect: true,
        removeOnServerChange: true
      },
      party: {
        enabled: true,
        autoRefreshServerChange: false, // premium
        autoRefreshGameEnd: false // premium
      },
      partyInvites: {
        enabled: true
      },
      chat: {
        enabled: true,
        removeOnServerChange: true,
        strings: []
      }
    };

    let sourcesSettings = JSON.parse(localStorage.getItem('sourcesSettings') || JSON.stringify(defaultSources));

    function saveSourcesSettings() {
      localStorage.setItem('sourcesSettings', JSON.stringify(sourcesSettings));
      console.log('Sources settings saved:', sourcesSettings);
    }

    // Bind Sources inputs
    const sourceGameToggle = document.getElementById('sourceGameToggle');
    const gameAddFromChat = document.getElementById('gameAddFromChat');
    const gameRemoveOnDeath = document.getElementById('gameRemoveOnDeath');
    const gameRemoveOnReconnect = document.getElementById('gameRemoveOnReconnect');
    const gameRemoveOnServerChange = document.getElementById('gameRemoveOnServerChange');
    
    const sourcePartyToggle = document.getElementById('sourcePartyToggle');
    const partyRefreshServerChange = document.getElementById('partyRefreshServerChange');
    const partyRefreshGameEnd = document.getElementById('partyRefreshGameEnd');
    
    const sourcePartyInvitesToggle = document.getElementById('sourcePartyInvitesToggle');
    
    const sourceChatToggle = document.getElementById('sourceChatToggle');
    const chatRemoveOnServerChange = document.getElementById('chatRemoveOnServerChange');
    const chatStrings = document.getElementById('chatStrings');

    if (sourceGameToggle) {
      sourceGameToggle.checked = sourcesSettings.game.enabled;
      sourceGameToggle.addEventListener('change', () => {
        sourcesSettings.game.enabled = sourceGameToggle.checked;
        saveSourcesSettings();
      });
    }

    if (gameAddFromChat) {
      gameAddFromChat.checked = sourcesSettings.game.addFromChat;
      gameAddFromChat.addEventListener('change', () => {
        sourcesSettings.game.addFromChat = gameAddFromChat.checked;
        saveSourcesSettings();
      });
    }

    if (gameRemoveOnDeath) {
      gameRemoveOnDeath.checked = sourcesSettings.game.removeOnDeath;
      gameRemoveOnDeath.addEventListener('change', () => {
        sourcesSettings.game.removeOnDeath = gameRemoveOnDeath.checked;
        saveSourcesSettings();
      });
    }

    if (gameRemoveOnReconnect) {
      gameRemoveOnReconnect.checked = sourcesSettings.game.removeOnReconnect;
      gameRemoveOnReconnect.addEventListener('change', () => {
        sourcesSettings.game.removeOnReconnect = gameRemoveOnReconnect.checked;
        saveSourcesSettings();
      });
    }

    if (gameRemoveOnServerChange) {
      gameRemoveOnServerChange.checked = sourcesSettings.game.removeOnServerChange;
      gameRemoveOnServerChange.addEventListener('change', () => {
        sourcesSettings.game.removeOnServerChange = gameRemoveOnServerChange.checked;
        saveSourcesSettings();
      });
    }

    if (sourcePartyToggle) {
      sourcePartyToggle.checked = sourcesSettings.party.enabled;
      sourcePartyToggle.addEventListener('change', () => {
        sourcesSettings.party.enabled = sourcePartyToggle.checked;
        saveSourcesSettings();
      });
    }

    // Party auto-refresh are premium (disabled for now)
    if (partyRefreshServerChange) {
      partyRefreshServerChange.checked = sourcesSettings.party.autoRefreshServerChange;
      partyRefreshServerChange.addEventListener('change', () => {
        sourcesSettings.party.autoRefreshServerChange = partyRefreshServerChange.checked;
        saveSourcesSettings();
      });
    }

    if (partyRefreshGameEnd) {
      partyRefreshGameEnd.checked = sourcesSettings.party.autoRefreshGameEnd;
      partyRefreshGameEnd.addEventListener('change', () => {
        sourcesSettings.party.autoRefreshGameEnd = partyRefreshGameEnd.checked;
        saveSourcesSettings();
      });
    }

    if (sourcePartyInvitesToggle) {
      sourcePartyInvitesToggle.checked = sourcesSettings.partyInvites.enabled;
      sourcePartyInvitesToggle.addEventListener('change', () => {
        sourcesSettings.partyInvites.enabled = sourcePartyInvitesToggle.checked;
        saveSourcesSettings();
      });
    }

    if (sourceChatToggle) {
      sourceChatToggle.checked = sourcesSettings.chat.enabled;
      sourceChatToggle.addEventListener('change', () => {
        sourcesSettings.chat.enabled = sourceChatToggle.checked;
        saveSourcesSettings();
      });
    }

    if (chatRemoveOnServerChange) {
      chatRemoveOnServerChange.checked = sourcesSettings.chat.removeOnServerChange;
      chatRemoveOnServerChange.addEventListener('change', () => {
        sourcesSettings.chat.removeOnServerChange = chatRemoveOnServerChange.checked;
        saveSourcesSettings();
      });
    }

    if (chatStrings) {
      chatStrings.value = (sourcesSettings.chat.strings || []).join('\n');
      chatStrings.addEventListener('input', () => {
        sourcesSettings.chat.strings = chatStrings.value.split('\n').map(s => s.trim()).filter(Boolean);
        saveSourcesSettings();
      });
    }

    // Update table rendering to use stat settings
    function getColorForValue(column, value) {
      const rules = statSettings.colorRules[column];
      if (!rules) return '';

      for (const rule of rules) {
        if (rule.op === '>=' && value >= rule.value) {
          return `style="color:${rule.color}"`;
        }
        if (rule.op === '<' && value < rule.value) {
          return `style="color:${rule.color}"`;
        }
      }
      return '';
    }

    // Settings submenu toggle
    const settingsBtn = document.querySelector('.nav-item[data-panel="settings"]');
    const settingsSubmenu = document.querySelector('.settings-submenu');

    // Toggle submenu when settings is clicked
    settingsBtn?.addEventListener('click', (e) => {
      // We still stop propagation so the generic listener does not fire twice,
      // but we explicitly invoke the panel switch here to ensure the Settings panel becomes visible.
      e.stopPropagation();
      const expanded = settingsBtn.classList.toggle('expanded');
      settingsSubmenu.classList.toggle('expanded', expanded);
      // Activate Settings top-level panel
      showPanel('settings');
      // Mark only Basic subsection active initially when expanding
      document.querySelectorAll('.nav-item.sub-item').forEach(b => b.classList.remove('active'));
      const basicBtn = document.querySelector('.nav-item.sub-item[data-settings="basic"]');
      if (basicBtn) basicBtn.classList.add('active');
      showSettingsSection('basic');
      localStorage.setItem('activeSettingsSection', 'basic');
      // Persist expanded state
      localStorage.setItem('settingsExpanded', expanded);
    });

    // Handle settings section clicks
    document.querySelectorAll('.nav-item.sub-item').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const section = btn.getAttribute('data-settings');
        // Nur diese Kategorie als aktiv markieren
        document.querySelectorAll('.nav-item.sub-item').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        // Show settings panel und Section
        showPanel('settings');
        showSettingsSection(section);
        // Save active section
        localStorage.setItem('activeSettingsSection', section);
      });
    });

    // Show specific settings section
    function showSettingsSection(section) {
      document.querySelectorAll('.settings-content').forEach(content => {
        content.classList.toggle('active', 
          content.getAttribute('data-section') === section);
      });
    }

    // Restore settings state on load
    const settingsExpanded = localStorage.getItem('settingsExpanded') === 'true';
    if (settingsExpanded) {
      settingsBtn.classList.add('expanded');
      settingsSubmenu.classList.add('expanded');
    }

    // Restore active settings section
    const activeSection = localStorage.getItem('activeSettingsSection') || 'basic';
    document.querySelectorAll('.nav-item.sub-item').forEach(b => b.classList.remove('active'));
    const activeBtn = document.querySelector(`.nav-item.sub-item[data-settings="${activeSection}"]`);
    if (activeBtn) {
      activeBtn.classList.add('active');
      showSettingsSection(activeSection);
    }
  </script>
</body>
</html>
